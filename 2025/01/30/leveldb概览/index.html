<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>leveldb分析 | Infinity Code</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">leveldb分析</h1><a id="logo" href="/.">Infinity Code</a><p class="description">Simplicity is the soul of efficiency.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">leveldb分析</h1><div class="post-meta">创建: 2025-01-30<span> | 更新: 2025-02-15</span><span> | </span><category class="name"></category><span class="category"><a href="/categories/single-machine/">single-machine</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 本文共 3.5k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 阅读需要 18</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#db"><span class="toc-number">1.</span> <span class="toc-text">db</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Open"><span class="toc-number">1.1.</span> <span class="toc-text">Open</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Write"><span class="toc-number">1.2.</span> <span class="toc-text">Write</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Get"><span class="toc-number">1.3.</span> <span class="toc-text">Get</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#version"><span class="toc-number">3.</span> <span class="toc-text">version</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#memtable-log"><span class="toc-number">4.</span> <span class="toc-text">memtable+log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tablefile"><span class="toc-number">5.</span> <span class="toc-text">tablefile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%9F%E5%8A%A9%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81"><span class="toc-number">6.</span> <span class="toc-text">借助单元测试分析源码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#case1-Empty"><span class="toc-number">6.1.</span> <span class="toc-text">case1 Empty</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case02%EF%BC%8C03-EmptyKey-EmptyValue"><span class="toc-number">6.2.</span> <span class="toc-text">case02，03 EmptyKey, EmptyValue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case04-ReadWrite"><span class="toc-number">6.3.</span> <span class="toc-text">case04 ReadWrite</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case05-PutDeleteGet"><span class="toc-number">6.4.</span> <span class="toc-text">case05 PutDeleteGet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case06-GetFromImmutableLayer"><span class="toc-number">6.5.</span> <span class="toc-text">case06 GetFromImmutableLayer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case-08%EF%BC%8CGetFromVersions"><span class="toc-number">6.6.</span> <span class="toc-text">case 08，GetFromVersions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GetSnapshot"><span class="toc-number">6.7.</span> <span class="toc-text">GetSnapshot</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DeletionMarkers1"><span class="toc-number">6.8.</span> <span class="toc-text">DeletionMarkers1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TODO"><span class="toc-number">7.</span> <span class="toc-text">TODO</span></a></li></ol></div></div><div class="post-content"><p>leveldb 可分为五大块。db, iterator，version, memtable+log, tablefile。</p>
<p>leveldb 的架构图资料上有很多，可以参考<a target="_blank" rel="noopener" href="https://youjiali1995.github.io/storage/leveldb-architecture/">网站</a></p>
<span id="more"></span>

<h3 id="db"><a href="#db" class="headerlink" title="db"></a>db</h3><p>主要接口Open，Put&#x2F;Write，Delete，Get</p>
<h4 id="Open"><a href="#Open" class="headerlink" title="Open"></a>Open</h4><p><code>Status DB::Open(const Options&amp; options, const std::string&amp; dbname, DB** dbptr)</code><br>Open 需要传入options，options记录了1. 限制参数，例如max_open_files，max_file_size，block_size 2. Env* env; env提供创建文件等接口</p>
<p>open的执行过程</p>
<ol>
<li>利用manifest recover；impl-&gt;Recover(&amp;edit, &amp;save_manifest);<ol>
<li>包含两部分1. versions_-&gt;Recover(save_manifest);  2. <code>RecoverLogFile(logs[i], (i == logs.size() - 1), save_manifest, edit, &amp;max_sequence);</code></li>
<li>在dbdir 里找到logfile，根据文件名的序号排序，将排序后的logfile按序执行RecoverLogFile</li>
</ol>
</li>
<li>version和logfile replay后将状态记录给versionEdit，versionEdit的内容主要包括log_number_、last_sequence_、next_file_number_和new_files_(tablefile)。</li>
<li>最后执行VersionSet::LogAndApply，将VersionEdit SaveTo Version，然后把version append到versionSet</li>
</ol>
<h4 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h4><p>Write的执行过程</p>
<ol>
<li><code>MakeRoomForWrite(updates == nullptr);</code> 如果mem空间不够，将mem设置成imm，新建mem，触发dump</li>
<li><code>WriteBatch* write_batch = BuildBatchGroup(&amp;last_writer);</code> 将writer放入到WriteBatchInternal::Append</li>
<li><code>log_-&gt;AddRecord(WriteBatchInternal::Contents(write_batch));</code></li>
<li><code>WriteBatchInternal::InsertInto(write_batch, mem_);</code></li>
<li><code>DB::Write</code>可以多线程执行，使用生产者消费者作为线程切换。线程同时可以是生产者，也可以是消费者。线程申请锁，把write放入队列，然后检查writer队列，如果有writer则执行具体write</li>
</ol>
<h4 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h4><p>Get的执行过程</p>
<ol>
<li>如果没有传入snapshot，设置snapshot为snapshot &#x3D; versions_-&gt;LastSequence();</li>
<li>LookupKey lkey(key, snapshot); lookup key包含了seq</li>
<li>mem-&gt;Get(lkey, value, &amp;s)</li>
<li>imm-&gt;Get(lkey, value, &amp;s)</li>
<li>current-&gt;Get(options, lkey, value, &amp;stats) (即Version::Get)<ol>
<li>对L0的文件按照filenumber从大到小排序，遍历检索(L0 tablefile内部key有序，文件之间key无序, 文件有number顺序)</li>
<li>对L1以下的文件，每层使用二分查找找到指定的tablefile</li>
<li>对tablefile内部，首先使用TableCache::Get 尝试在cache中查找。cache是tablefile共享的，key是filenumber。如果tablefile没有cache，则读取文件插入cache。注意到tablecache只是pagecache上面的一层，tablecache 会cache住tablefile的metaindex_handle、index_block等元数据信息</li>
<li>tablefile内的检索过程 1. rep_-&gt;index_block-&gt;NewIterator 迭代器seek index_block 2. Iterator* block_iter &#x3D; BlockReader(this, options, iiter-&gt;value()); seek block</li>
</ol>
</li>
</ol>
<p>skiplist的元素顺序</p>
<ol>
<li>元素格式| key_size | key | seq,type | value_size | value</li>
<li>从key部分之后开始排序</li>
<li>对于key相同的，包括delete标签，按照seq从大到小排序</li>
<li>mem-&gt;Get 主要调用的是SkipList<code>&lt;Key, Comparator&gt;::FindGreaterOrEqual</code>，默认get key的seq是最近的seq，FindGreaterOrEqual会直接得到第一个key（也就是seq最大的key）。设置快照后get key会得到&lt;&#x3D;某seq的key。</li>
</ol>
<p>Delete 和Write实现一致，key会有个标签标志该key是delete。</p>
<p>db检索元素使用的是迭代器的seek，例如<br><code>inline void SkipList&lt;Key, Comparator&gt;::Iterator::Seek(const Key&amp; target)</code></p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器基本接口</p>
<ol>
<li>检索void Seek(const Key&amp; target);</li>
<li>获得前后元素void Next(); void Prev();</li>
<li>获得指向的节点</li>
<li>插入元素void Insert(const Key&amp; key);</li>
</ol>
<p>主要迭代器<br>SkipList::Iterator 用于操作mem和Imm table</p>
<p>TwoLevelIterator 用于检索tablefile，一次性需要把一个tablefile完全加载到内存</p>
<p>Block::Iter，操作tablefile的一个datablock，用于检索。1. 检索到RestartPoint 2. 从RestartPoint进一步检索得到key</p>
<p>MergingIterator 用于compaction。管理一层的若干tablefile，用来合并成为新的tablefile。采用多路败者树进行多个有序文件合并</p>
<p>只有skiplist需要插入修改，tablefile的修改只有append写。</p>
<h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>versionEdit对应manifest的一条记录</p>
<p>version只记录了tablefile的分布，不记录redolog和skiplist部分。redolog和skiplist 使用seq记录版本。<br>seq+version构成了快照，一个快照在tablefile中对应一个版本，被快照引用的tablefile不会被回收（即使被compaction了）</p>
<p>恢复版本就是选择版本包含的tablefile进行管理；恢复快照还需要把redolog 全量恢复，其中log_number用来恢复memtable，prev_log_number用来恢复immutable。切换logfile时会向manifest写入新的log_number。</p>
<h3 id="memtable-log"><a href="#memtable-log" class="headerlink" title="memtable+log"></a>memtable+log</h3><p>memtable就是skiplist，节点格式</p>
<p>| key_size | key | seq,type | value_size | value</p>
<p>log的记录是writebatch序列化的结果，对于write操作，格式</p>
<p>| kTypeValue, seq | key_size | key | value_size | value |  … </p>
<p>对于delete操作，格式</p>
<p>| kTypeDeletion，seq |  key_size | key |</p>
<h3 id="tablefile"><a href="#tablefile" class="headerlink" title="tablefile"></a>tablefile</h3><p>tablefile使用TableBuilder构建</p>
<p>tablefile没有header<br>格式</p>
<ol>
<li>data block</li>
<li>Write filter block</li>
<li>Write metaindex block</li>
<li>Write index block</li>
<li>Write footer</li>
</ol>
<p>indexblock 每个元素是datablock的最后一个key</p>
<p>metaindex block记录除datablock, indexblock之外的block的位置，例如filter block（布隆过滤器）</p>
<p>footer<br>| metaindex_handle_ | index_handle_ | kTableMagicNumber | </p>
<p>metaindex_handle_，index_handle_ 记录了metaindex block和index block的位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Footer::EncodeTo</span><span class="params">(std::string* dst)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> original_size = dst-&gt;<span class="built_in">size</span>();</span><br><span class="line">  metaindex_handle_.<span class="built_in">EncodeTo</span>(dst);</span><br><span class="line">  index_handle_.<span class="built_in">EncodeTo</span>(dst);</span><br><span class="line">  dst-&gt;<span class="built_in">resize</span>(<span class="number">2</span> * BlockHandle::kMaxEncodedLength);  <span class="comment">// Padding</span></span><br><span class="line">  <span class="built_in">PutFixed32</span>(dst, <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(kTableMagicNumber &amp; <span class="number">0xffffffffu</span>));</span><br><span class="line">  <span class="built_in">PutFixed32</span>(dst, <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(kTableMagicNumber &gt;&gt; <span class="number">32</span>));</span><br><span class="line">  <span class="built_in">assert</span>(dst-&gt;<span class="built_in">size</span>() == original_size + kEncodedLength);</span><br><span class="line">  (<span class="type">void</span>)original_size;  <span class="comment">// Disable unused variable warning.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="借助单元测试分析源码"><a href="#借助单元测试分析源码" class="headerlink" title="借助单元测试分析源码"></a>借助单元测试分析源码</h3><p>unittest是分析代码的有效入口，以db_test为例</p>
<h4 id="case1-Empty"><a href="#case1-Empty" class="headerlink" title="case1 Empty"></a>case1 Empty</h4><p>DBTest, Empty，尝试以不同option配置打开db<br>可选择的配置，<code>&#123; kDefault, kReuse, kFilter, kUncompressed, kEnd &#125;</code></p>
<p>执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(DBTest, Empty) &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">ASSERT_TRUE</span>(db_ != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;NOT_FOUND&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">ChangeOptions</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Switch to a fresh database with the next option configuration to</span></span><br><span class="line">  <span class="comment">// test.  Return false if there are no more configurations to test.</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">ChangeOptions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    option_config_++;</span><br><span class="line">    <span class="keyword">if</span> (option_config_ &gt;= kEnd) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">DestroyAndReopen</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">OptionConfig</span> &#123; kDefault, kReuse, kFilter, kUncompressed, kEnd &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">DestroyAndReopen</span><span class="params">(Options* options = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> db_;</span><br><span class="line">    db_ = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">DestroyDB</span>(dbname_, <span class="built_in">Options</span>());</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">TryReopen</span>(options));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Status TryReopen(Options* options) 需要传入Option</span></span><br><span class="line">  <span class="function">Status <span class="title">TryReopen</span><span class="params">(Options* options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> db_;</span><br><span class="line">    db_ = <span class="literal">nullptr</span>;</span><br><span class="line">    Options opts;</span><br><span class="line">    <span class="keyword">if</span> (options != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      opts = *options;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      opts = <span class="built_in">CurrentOptions</span>();</span><br><span class="line">      opts.create_if_missing = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    last_options_ = opts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DB::<span class="built_in">Open</span>(opts, dbname_, &amp;db_);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>cmake debug模式编译<br>cmake -DCMAKE_BUILD_TYPE&#x3D;Debug ..</p>
<h4 id="case02，03-EmptyKey-EmptyValue"><a href="#case02，03-EmptyKey-EmptyValue" class="headerlink" title="case02，03 EmptyKey, EmptyValue"></a>case02，03 EmptyKey, EmptyValue</h4><p>不同option打开db，put key同时可以get到</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(DBTest, EmptyKey) &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">Put</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;v1&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v1&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">Put</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;v2&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v2&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">ChangeOptions</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST_F</span>(DBTest, EmptyValue) &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">Put</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;v1&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v1&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;key&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">Put</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;key&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">Put</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;v2&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v2&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;key&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">ChangeOptions</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="case04-ReadWrite"><a href="#case04-ReadWrite" class="headerlink" title="case04 ReadWrite"></a>case04 ReadWrite</h4><p>读写</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(DBTest, ReadWrite) &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">Put</span>(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;v1&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v1&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">Put</span>(<span class="string">&quot;bar&quot;</span>, <span class="string">&quot;v2&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">Put</span>(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;v3&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v3&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v2&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;bar&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">ChangeOptions</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="case05-PutDeleteGet"><a href="#case05-PutDeleteGet" class="headerlink" title="case05 PutDeleteGet"></a>case05 PutDeleteGet</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(DBTest, PutDeleteGet) &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(db_-&gt;<span class="built_in">Put</span>(<span class="built_in">WriteOptions</span>(), <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;v1&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v1&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(db_-&gt;<span class="built_in">Put</span>(<span class="built_in">WriteOptions</span>(), <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;v2&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v2&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(db_-&gt;<span class="built_in">Delete</span>(<span class="built_in">WriteOptions</span>(), <span class="string">&quot;foo&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;NOT_FOUND&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">ChangeOptions</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPECT_LEVELDB_OK(expression) \</span></span><br><span class="line"><span class="meta">  EXPECT_THAT(expression, leveldb::test::IsOK())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT_LEVELDB_OK(expression) \</span></span><br><span class="line"><span class="meta">  ASSERT_THAT(expression, leveldb::test::IsOK())</span></span><br></pre></td></tr></table></figure>

<h4 id="case06-GetFromImmutableLayer"><a href="#case06-GetFromImmutableLayer" class="headerlink" title="case06 GetFromImmutableLayer"></a>case06 GetFromImmutableLayer</h4><p>核心是三行</p>
<p>env_-&gt;delay_data_sync_.store(true, std::memory_order_release);<br>Put(“k1”, std::string(100000, ‘x’));  &#x2F;&#x2F; Fill memtable.<br>Put(“k2”, std::string(100000, ‘y’));  &#x2F;&#x2F; Trigger compaction.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(DBTest, GetFromImmutableLayer) &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    Options options = <span class="built_in">CurrentOptions</span>();</span><br><span class="line">    options.env = env_;</span><br><span class="line">    options.write_buffer_size = <span class="number">100000</span>;  <span class="comment">// Small write buffer</span></span><br><span class="line">    <span class="built_in">Reopen</span>(&amp;options);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">Put</span>(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;v1&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v1&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Block sync calls.</span></span><br><span class="line">    env_-&gt;delay_data_sync_.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">    <span class="built_in">Put</span>(<span class="string">&quot;k1&quot;</span>, std::<span class="built_in">string</span>(<span class="number">100000</span>, <span class="string">&#x27;x&#x27;</span>));  <span class="comment">// Fill memtable.</span></span><br><span class="line">    <span class="built_in">Put</span>(<span class="string">&quot;k2&quot;</span>, std::<span class="built_in">string</span>(<span class="number">100000</span>, <span class="string">&#x27;y&#x27;</span>));  <span class="comment">// Trigger compaction.</span></span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v1&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">    <span class="comment">// Release sync calls.</span></span><br><span class="line">    env_-&gt;delay_data_sync_.<span class="built_in">store</span>(<span class="literal">false</span>, std::memory_order_release);</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">ChangeOptions</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>put key2时，1. 将mem变成imm 2. 后台触发compaction</p>
<p>如果delay_data_sync_ 设置true，后台compaction线程阻塞在L0-&gt;L1的DBImpl::WriteLevel0Table。imm_尚未被删除，foo还是会在imm_中读取</p>
<p>write_buffer_size 作用<br>DBImpl::MakeRoomForWrite 发现mem_-&gt;ApproximateMemoryUsage() &gt; options_.write_buffer_size)，认为没有空间，然后执行</p>
<ol>
<li>s &#x3D; env_-&gt;NewWritableFile(LogFileName(dbname_, new_log_number), &amp;lfile);</li>
<li>设置Imm,imm_ &#x3D; mem_;<br>   has_imm_.store(true, std::memory_order_release);<br>   mem_ &#x3D; new MemTable(internal_comparator_);</li>
<li>MaybeScheduleCompaction();</li>
</ol>
<p>delay_data_sync_ 的作用，从取名上作用是延迟sync。其实就是datafile的sync()函数一直阻塞。</p>
<p>什么时候执行Sync()</p>
<ol>
<li>recover时，如果db不存在，执行DBImpl::NewDB()。执行manifest file-&gt;Sync();</li>
<li> DBImpl::FinishCompactionOutputFile 执行compact-&gt;outfile-&gt;Sync();<ol>
<li>FinishCompactionOutputFile函数在minor compaction和major compaction执行完之后都会执行</li>
</ol>
</li>
<li>DBImpl::Write 执行logfile_-&gt;Sync();</li>
<li>DBImpl::WriteLevel0Table 执行BuildTable，最后执行s &#x3D; file-&gt;Sync();</li>
</ol>
<p>如果delay_data_sync_ 设置true，会卡在L0-&gt;L1的DBImpl::WriteLevel0Table。imm_尚未被删除，数据还是会在imm_中读取</p>
<p>MaybeScheduleCompaction 函数逻辑</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::MaybeScheduleCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="keyword">if</span> (background_compaction_scheduled_) &#123;</span><br><span class="line">    <span class="comment">// Already scheduled</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// DB is being deleted; no more background compactions</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// Already got an error; no more changes</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp; manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             !versions_-&gt;<span class="built_in">NeedsCompaction</span>()) &#123;</span><br><span class="line">    <span class="comment">// No work to be done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    background_compaction_scheduled_ = <span class="literal">true</span>;</span><br><span class="line">    env_-&gt;<span class="built_in">Schedule</span>(&amp;DBImpl::BGWork, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PosixEnv::Schedule<br>作为生产者</p>
<ol>
<li>如果background_work_queue_为空，唤醒background_work_cv_（消费线程会重新申请锁</li>
<li>将任务加入到background_work_queue_，线程保护<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PosixEnv::Schedule</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> (*background_work_function)(<span class="type">void</span>* background_work_arg),</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* background_work_arg)</span> </span>&#123;</span><br><span class="line">  background_work_mutex_.<span class="built_in">Lock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start the background thread, if we haven&#x27;t done so already.</span></span><br><span class="line">  <span class="keyword">if</span> (!started_background_thread_) &#123;</span><br><span class="line">    started_background_thread_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">background_thread</span><span class="params">(PosixEnv::BackgroundThreadEntryPoint, <span class="keyword">this</span>)</span></span>;</span><br><span class="line">    background_thread.<span class="built_in">detach</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the queue is empty, the background thread may be waiting for work.</span></span><br><span class="line">  <span class="keyword">if</span> (background_work_queue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    background_work_cv_.<span class="built_in">Signal</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  background_work_queue_.<span class="built_in">emplace</span>(background_work_function, background_work_arg);</span><br><span class="line">  background_work_mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  port::Mutex background_work_mutex_;</span><br><span class="line">  <span class="function">port::CondVar background_work_cv_ <span class="title">GUARDED_BY</span><span class="params">(background_work_mutex_)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> started_background_thread_ <span class="title">GUARDED_BY</span><span class="params">(background_work_mutex_)</span></span>;</span><br><span class="line">  <span class="function">std::queue&lt;BackgroundWorkItem&gt; background_work_queue_</span></span><br><span class="line"><span class="function">      <span class="title">GUARDED_BY</span><span class="params">(background_work_mutex_)</span></span>;</span><br></pre></td></tr></table></figure>
GUARDED_BY 是一种在多线程编程中用于静态代码分析的注解（或宏），其核心作用是声明某个共享变量必须通过特定的锁（或其他同步机制）来保护，以避免数据竞争和并发安全问题。</li>
</ol>
<p>BackgroundWorkItem</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Stores the work item data in a Schedule() call.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Instances are constructed on the thread calling Schedule() and used on the</span></span><br><span class="line">  <span class="comment">// background thread.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// This structure is thread-safe beacuse it is immutable.</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">BackgroundWorkItem</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BackgroundWorkItem</span><span class="params">(<span class="type">void</span> (*function)(<span class="type">void</span>* arg), <span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function">        : function(function), arg(arg) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span> (*<span class="type">const</span> function)(<span class="type">void</span>*);</span><br><span class="line">    <span class="type">void</span>* <span class="type">const</span> arg;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PosixEnv::BackgroundThreadMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    background_work_mutex_.<span class="built_in">Lock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until there is work to be done.</span></span><br><span class="line">    <span class="keyword">while</span> (background_work_queue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      background_work_cv_.<span class="built_in">Wait</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(!background_work_queue_.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">auto</span> background_work_function = background_work_queue_.<span class="built_in">front</span>().function;</span><br><span class="line">    <span class="type">void</span>* background_work_arg = background_work_queue_.<span class="built_in">front</span>().arg;</span><br><span class="line">    background_work_queue_.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    background_work_mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="built_in">background_work_function</span>(background_work_arg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动，可以看到只有一个消费者线程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PosixEnv::Schedule</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> (*background_work_function)(<span class="type">void</span>* background_work_arg),</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* background_work_arg)</span> </span>&#123;</span><br><span class="line">  background_work_mutex_.<span class="built_in">Lock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start the background thread, if we haven&#x27;t done so already.</span></span><br><span class="line">  <span class="keyword">if</span> (!started_background_thread_) &#123;</span><br><span class="line">    started_background_thread_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">background_thread</span><span class="params">(PosixEnv::BackgroundThreadEntryPoint, <span class="keyword">this</span>)</span></span>;</span><br><span class="line">    background_thread.<span class="built_in">detach</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="case-08，GetFromVersions"><a href="#case-08，GetFromVersions" class="headerlink" title="case 08，GetFromVersions"></a>case 08，GetFromVersions</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(DBTest, GetFromVersions) &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">Put</span>(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;v1&quot;</span>));</span><br><span class="line">    <span class="built_in">dbfull</span>()-&gt;<span class="built_in">TEST_CompactMemTable</span>();</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v1&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">ChangeOptions</span>());  <span class="comment">// 会执行DestroyAndReopen();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dbfull()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function">DBImpl* <span class="title">dbfull</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;DBImpl*&gt;(db_); &#125;</span><br></pre></td></tr></table></figure>

<p>DBImpl::TEST_CompactMemTable()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::TEST_CompactMemTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// nullptr batch means just wait for earlier writes to be done</span></span><br><span class="line">  Status s = <span class="built_in">Write</span>(<span class="built_in">WriteOptions</span>(), <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// Wait until the compaction completes</span></span><br><span class="line">    <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (imm_ != <span class="literal">nullptr</span> &amp;&amp; bg_error_.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      background_work_finished_signal_.<span class="built_in">Wait</span>();  <span class="comment">// 主动释放锁并进入阻塞状态</span></span><br><span class="line">    <span class="comment">// CompactMemTable(); 执行完会调用</span></span><br><span class="line">    <span class="comment">// background_work_finished_signal_.SignalAll(); 唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      s = bg_error_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GetSnapshot"><a href="#GetSnapshot" class="headerlink" title="GetSnapshot"></a>GetSnapshot</h4><p>db_-&gt;GetSnapshot();</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(DBTest, GetSnapshot) &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// Try with both a short key and a long key</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">      std::string key = (i == <span class="number">0</span>) ? std::<span class="built_in">string</span>(<span class="string">&quot;foo&quot;</span>) : std::<span class="built_in">string</span>(<span class="number">200</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">      <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">Put</span>(key, <span class="string">&quot;v1&quot;</span>));</span><br><span class="line">      <span class="type">const</span> Snapshot* s1 = db_-&gt;<span class="built_in">GetSnapshot</span>();</span><br><span class="line">      <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">Put</span>(key, <span class="string">&quot;v2&quot;</span>));</span><br><span class="line">      <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v2&quot;</span>, <span class="built_in">Get</span>(key));</span><br><span class="line">      <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v1&quot;</span>, <span class="built_in">Get</span>(key, s1));</span><br><span class="line">      <span class="built_in">dbfull</span>()-&gt;<span class="built_in">TEST_CompactMemTable</span>();</span><br><span class="line">      <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v2&quot;</span>, <span class="built_in">Get</span>(key));</span><br><span class="line">      <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v1&quot;</span>, <span class="built_in">Get</span>(key, s1));</span><br><span class="line">      db_-&gt;<span class="built_in">ReleaseSnapshot</span>(s1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">ChangeOptions</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Snapshot* <span class="title">DBImpl::GetSnapshot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> snapshots_.<span class="built_in">New</span>(versions_-&gt;<span class="built_in">LastSequence</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Creates a SnapshotImpl and appends it to the end of the list.</span></span><br><span class="line">  <span class="function">SnapshotImpl* <span class="title">New</span><span class="params">(SequenceNumber sequence_number)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">empty</span>() || <span class="built_in">newest</span>()-&gt;sequence_number_ &lt;= sequence_number);</span><br><span class="line"></span><br><span class="line">    SnapshotImpl* snapshot = <span class="keyword">new</span> <span class="built_in">SnapshotImpl</span>(sequence_number);</span><br><span class="line"></span><br><span class="line">    snapshot-&gt;next_ = &amp;head_;</span><br><span class="line">    snapshot-&gt;prev_ = head_.prev_;</span><br><span class="line">    snapshot-&gt;prev_-&gt;next_ = snapshot;</span><br><span class="line">    snapshot-&gt;next_-&gt;prev_ = snapshot;</span><br><span class="line">    <span class="keyword">return</span> snapshot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="DeletionMarkers1"><a href="#DeletionMarkers1" class="headerlink" title="DeletionMarkers1"></a>DeletionMarkers1</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(DBTest, DeletionMarkers1) &#123;</span><br><span class="line">  <span class="built_in">Put</span>(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">  <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">dbfull</span>()-&gt;<span class="built_in">TEST_CompactMemTable</span>());</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> last = config::kMaxMemCompactLevel;</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="built_in">NumTableFilesAtLevel</span>(last), <span class="number">1</span>);  <span class="comment">// foo =&gt; v1 is now in last level</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Place a table at level last-1 to prevent merging with preceding mutation</span></span><br><span class="line">  <span class="built_in">Put</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;begin&quot;</span>);</span><br><span class="line">  <span class="built_in">Put</span>(<span class="string">&quot;z&quot;</span>, <span class="string">&quot;end&quot;</span>);</span><br><span class="line">  <span class="built_in">dbfull</span>()-&gt;<span class="built_in">TEST_CompactMemTable</span>();</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="built_in">NumTableFilesAtLevel</span>(last), <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="built_in">NumTableFilesAtLevel</span>(last - <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Delete</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">  <span class="built_in">Put</span>(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="built_in">AllEntriesFor</span>(<span class="string">&quot;foo&quot;</span>), <span class="string">&quot;[ v2, DEL, v1 ]&quot;</span>);</span><br><span class="line">  <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">dbfull</span>()-&gt;<span class="built_in">TEST_CompactMemTable</span>());  <span class="comment">// Moves to level last-2</span></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="built_in">AllEntriesFor</span>(<span class="string">&quot;foo&quot;</span>), <span class="string">&quot;[ v2, DEL, v1 ]&quot;</span>);</span><br><span class="line">  <span class="function">Slice <span class="title">z</span><span class="params">(<span class="string">&quot;z&quot;</span>)</span></span>;</span><br><span class="line">  <span class="built_in">dbfull</span>()-&gt;<span class="built_in">TEST_CompactRange</span>(last - <span class="number">2</span>, <span class="literal">nullptr</span>, &amp;z);</span><br><span class="line">  <span class="comment">// DEL eliminated, but v1 remains because we aren&#x27;t compacting that level</span></span><br><span class="line">  <span class="comment">// (DEL can be eliminated because v2 hides v1).</span></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="built_in">AllEntriesFor</span>(<span class="string">&quot;foo&quot;</span>), <span class="string">&quot;[ v2, v1 ]&quot;</span>);</span><br><span class="line">  <span class="built_in">dbfull</span>()-&gt;<span class="built_in">TEST_CompactRange</span>(last - <span class="number">1</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// Merging last-1 w/ last, so we are the base level for &quot;foo&quot;, so</span></span><br><span class="line">  <span class="comment">// DEL is removed.  (as is v1).</span></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="built_in">AllEntriesFor</span>(<span class="string">&quot;foo&quot;</span>), <span class="string">&quot;[ v2 ]&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Delete的实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DB::Delete</span><span class="params">(<span class="type">const</span> WriteOptions&amp; opt, <span class="type">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  WriteBatch batch;</span><br><span class="line">  batch.<span class="built_in">Delete</span>(key);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Write</span>(opt, &amp;batch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatch::Delete</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  WriteBatchInternal::<span class="built_in">SetCount</span>(<span class="keyword">this</span>, WriteBatchInternal::<span class="built_in">Count</span>(<span class="keyword">this</span>) + <span class="number">1</span>);</span><br><span class="line">  rep_.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(kTypeDeletion));</span><br><span class="line">  <span class="built_in">PutLengthPrefixedSlice</span>(&amp;rep_, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AllEntriesFor</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">AllEntriesFor</span><span class="params">(<span class="type">const</span> Slice&amp; user_key)</span> </span>&#123;</span><br><span class="line">  Iterator* iter = <span class="built_in">dbfull</span>()-&gt;<span class="built_in">TEST_NewInternalIterator</span>();</span><br><span class="line">  <span class="function">InternalKey <span class="title">target</span><span class="params">(user_key, kMaxSequenceNumber, kTypeValue)</span></span>;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  iter-&gt;<span class="built_in">Seek</span>(target.<span class="built_in">Encode</span>());</span><br><span class="line">  std::string result;</span><br><span class="line">  <span class="keyword">if</span> (!iter-&gt;<span class="built_in">status</span>().<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    result = iter-&gt;<span class="built_in">status</span>().<span class="built_in">ToString</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = <span class="string">&quot;[ &quot;</span>;</span><br><span class="line">    <span class="type">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (iter-&gt;<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">      ParsedInternalKey ikey;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">ParseInternalKey</span>(iter-&gt;<span class="built_in">key</span>(), &amp;ikey)) &#123;</span><br><span class="line">        result += <span class="string">&quot;CORRUPTED&quot;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (last_options_.comparator-&gt;<span class="built_in">Compare</span>(ikey.user_key, user_key) != <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!first) &#123;</span><br><span class="line">          result += <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        first = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">switch</span> (ikey.type) &#123;</span><br><span class="line">          <span class="keyword">case</span> kTypeValue:</span><br><span class="line">            result += iter-&gt;<span class="built_in">value</span>().<span class="built_in">ToString</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> kTypeDeletion:</span><br><span class="line">            result += <span class="string">&quot;DEL&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      iter-&gt;<span class="built_in">Next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!first) &#123;</span><br><span class="line">      result += <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result += <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> iter;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Iterator* iter &#x3D; dbfull()-&gt;TEST_NewInternalIterator();</p>
<p>InternalKey target(user_key, kMaxSequenceNumber, kTypeValue);<br>&#x2F;&#x2F;<br>iter-&gt;Seek(target.Encode());</p>
<p>这里的target 封装了seq和type</p>
<p>Iterator::Seek</p>
<p>SSTable 文件由数据块和索引块组成。索引块存储了数据块的元信息，比如每个数据块的起始键和位置。当需要查找某个键时，首先通过索引块找到对应的数据块，然后在数据块内进行查找。TwoLevelIterator负责这种两级查找过程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> <span class="title class_">Comparator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> SkipList&lt;Key, Comparator&gt;::Iterator::<span class="built_in">Seek</span>(<span class="type">const</span> Key&amp; target) &#123;</span><br><span class="line">  node_ = list_-&gt;<span class="built_in">FindGreaterOrEqual</span>(target, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 负责sst file的遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TwoLevelIterator::Seek</span><span class="params">(<span class="type">const</span> Slice&amp; target)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// seek索引块</span></span><br><span class="line">  index_iter_.<span class="built_in">Seek</span>(target);</span><br><span class="line">  <span class="built_in">InitDataBlock</span>();</span><br><span class="line">  <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span>) data_iter_.<span class="built_in">Seek</span>(target);</span><br><span class="line">  <span class="built_in">SkipEmptyDataBlocksForward</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MergingIterator</span> : <span class="keyword">public</span> Iterator &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Seek</span><span class="params">(<span class="type">const</span> Slice&amp; target)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">	  <span class="comment">// 每个children是一个SkipList::Iterator或者TwoLevelIterator</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">      children_[i].<span class="built_in">Seek</span>(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FindSmallest</span>();</span><br><span class="line">    direction_ = kForward;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure that all children are positioned after key().</span></span><br><span class="line">    <span class="comment">// If we are moving in the forward direction, it is already</span></span><br><span class="line">    <span class="comment">// true for all of the non-current_ children since current_ is</span></span><br><span class="line">    <span class="comment">// the smallest child and key() == current_-&gt;key().  Otherwise,</span></span><br><span class="line">    <span class="comment">// we explicitly position the non-current_ children.</span></span><br><span class="line">    <span class="keyword">if</span> (direction_ != kForward) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">        IteratorWrapper* child = &amp;children_[i];</span><br><span class="line">        <span class="keyword">if</span> (child != current_) &#123;</span><br><span class="line">          child-&gt;<span class="built_in">Seek</span>(<span class="built_in">key</span>());</span><br><span class="line">          <span class="keyword">if</span> (child-&gt;<span class="built_in">Valid</span>() &amp;&amp;</span><br><span class="line">              comparator_-&gt;<span class="built_in">Compare</span>(<span class="built_in">key</span>(), child-&gt;<span class="built_in">key</span>()) == <span class="number">0</span>) &#123;</span><br><span class="line">            child-&gt;<span class="built_in">Next</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      direction_ = kForward;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current_-&gt;<span class="built_in">Next</span>();</span><br><span class="line">    <span class="built_in">FindSmallest</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Which direction is the iterator moving?</span></span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">Direction</span> &#123; kForward, kReverse &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">FindSmallest</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">FindLargest</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We might want to use a heap in case there are lots of children.</span></span><br><span class="line">  <span class="comment">// For now we use a simple array since we expect a very small number</span></span><br><span class="line">  <span class="comment">// of children in leveldb.</span></span><br><span class="line">  <span class="type">const</span> Comparator* comparator_;</span><br><span class="line">  IteratorWrapper* children_;</span><br><span class="line">  <span class="type">int</span> n_;</span><br><span class="line">  IteratorWrapper* current_;</span><br><span class="line">  Direction direction_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InternalKey</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::string rep_;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">InternalKey</span>() &#123;&#125;  <span class="comment">// Leave rep_ as empty to indicate it is invalid</span></span><br><span class="line">  <span class="built_in">InternalKey</span>(<span class="type">const</span> Slice&amp; user_key, SequenceNumber s, ValueType t) &#123;</span><br><span class="line">    <span class="built_in">AppendInternalKey</span>(&amp;rep_, <span class="built_in">ParsedInternalKey</span>(user_key, s, t));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>迭代器具体使用</p>
<p>详细线程模型和并发控制</p>
<p>模块依赖和编译依赖</p>
<p>性能分析</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>leveldb分析</p><p><span>文章作者：</span>Infinity</p><p><span>发布时间：</span>2025-01-30</p><p><span>最后更新：</span>2025-02-15</p><p><span>原始链接：</span><a href="/2025/01/30/leveldb概览/">https://larrystd.github.io/2025/01/30/leveldb%E6%A6%82%E8%A7%88/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://larrystd.github.io/2025/01/30/leveldb%E6%A6%82%E8%A7%88/"></i></span></p><p><span>版权声明：</span>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p></div><br><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leveldb/" rel="tag">leveldb</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/single-machine/" rel="tag">single-machine</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/storage/" rel="tag">storage</a></li></ul></div><div class="post-nav"><a class="pre" href="/2025/02/09/redis(1)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">redis(1)——数据结构</a><a class="next" href="/2025/01/06/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%BA%95%E5%BA%A7/">分布式存储底座</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="https://unpkg.com/blueimp-md5/js/md5.js"></script><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: 'Ov23lifIyMlBwTu1yQhW',
  clientSecret: '8a6951b810e0f8c75acc7af48be63e53e7d6b5ad',
  repo: 'blogtalk',
  owner: 'larrystd',
  admin: ['larrystd'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>To be a better man.</p><a class="info-icon" href="venray.kong@outlook.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/larrystd" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/application/">application</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/base/">base</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hello/">hello</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/multi-machine/">multi-machine</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/single-machine/">single-machine</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/hello/" style="font-size: 15px;">hello</a> <a href="/tags/single-machine/" style="font-size: 15px;">single-machine</a> <a href="/tags/storage/" style="font-size: 15px;">storage</a> <a href="/tags/application/" style="font-size: 15px;">application</a> <a href="/tags/base/" style="font-size: 15px;">base</a> <a href="/tags/os/" style="font-size: 15px;">os</a> <a href="/tags/language/" style="font-size: 15px;">language</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/leveldb/" style="font-size: 15px;">leveldb</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/02/14/leveldb%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/">leveldb线程模型和并发控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/12/redis(2)%E2%80%94%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86%E5%92%8Crdb,aof%E6%8C%81%E4%B9%85%E5%8C%96/">redis(2)——网络处理、线程模型和rdb,aof持久化</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/09/redis(1)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">redis(1)——数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/30/leveldb%E6%A6%82%E8%A7%88/">leveldb分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/06/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%BA%95%E5%BA%A7/">分布式存储底座</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(6)%E2%80%94%E7%BC%96%E8%AF%91%E3%80%81%E8%BF%90%E8%A1%8C%E5%92%8C%E8%B0%83%E8%AF%95/">编程语言(6)—编译、运行和调试</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/12/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(5)%E2%80%94%E6%96%87%E4%BB%B6IO%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%93/">编程语言(5)—文件IO和网络库</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/12/21/%E7%BC%93%E5%AD%98/">缓存</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/12/21/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0/">静态变量和函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/12/19/%E5%B9%B6%E5%8F%91%E6%80%BB%E8%A7%88/">并发</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="todo" target="_blank">todo</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Infinity Code.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>