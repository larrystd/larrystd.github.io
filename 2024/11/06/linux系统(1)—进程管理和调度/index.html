<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>linux系统(1)——进程管理和调度 | Infinity Code</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">linux系统(1)——进程管理和调度</h1><a id="logo" href="/.">Infinity Code</a><p class="description">Simplicity is the soul of efficiency.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">linux系统(1)——进程管理和调度</h1><div class="post-meta">2024-11-06<span> | </span><span class="category"><a href="/categories/linux/">linux</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%98%9F%E5%88%97"><span class="toc-number">1.1.</span> <span class="toc-text">进程队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%B1%E7%BB%AA%E9%98%9F%E5%88%97%EF%BC%88Ready-Queue%EF%BC%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">就绪队列（Ready Queue）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%EF%BC%88Wait-Queue%EF%BC%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">等待队列（Wait Queue）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E9%98%9F%E5%88%97%EF%BC%88Stopped-Queue%EF%BC%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">停止队列（Stopped Queue）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E9%98%9F%E5%88%97%EF%BC%88Zombie-Queue%EF%BC%89"><span class="toc-number">1.1.4.</span> <span class="toc-text">僵尸队列（Zombie Queue）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.2.</span> <span class="toc-text">进程优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.2.1.</span> <span class="toc-text">普通进程优先级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E5%85%AC%E5%B9%B3%E8%B0%83%E5%BA%A6CFS"><span class="toc-number">1.3.</span> <span class="toc-text">完全公平调度CFS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%8D%8F%E8%B0%83"><span class="toc-number">2.</span> <span class="toc-text">进程协调</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%B0%83%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">2.1.</span> <span class="toc-text">协调进程切换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%B8%AD%E6%96%AD%E5%92%8C%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8"><span class="toc-number">2.1.2.</span> <span class="toc-text">硬中断和中断向量表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="toc-number">2.1.3.</span> <span class="toc-text">软中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">2.1.4.</span> <span class="toc-text">信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5"><span class="toc-number">2.1.5.</span> <span class="toc-text">事件通知</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">2.1.6.</span> <span class="toc-text">锁</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><p>linux操作系统大致可分为进程管理、进程协调、内存管理、文件系统、网络管理等五大部分。本文讲述进程管理和进程协调。</p>
<span id="more"></span>

<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>进程管理的目的是将用户和内核创建的进程&#x2F;程序调度到cpu上执行，这些进程有三种</p>
<ol>
<li>用户程序创建的一次性运行完的进程</li>
<li>systemd等维护了常驻后台的后台进程，例如nginx，sshd</li>
<li>操作系统内核进程，例如kworker处理硬中断、信号、IO操作（包括cpu时间片硬中断调度、软中断抢占），kswapd管理页缓存和内存淘汰swap空间，watchdog检查内核死锁、防止系统卡死，ksoftirqd处理软中断，kblockd处理块设备IO，系统空闲线程（idle 线程）。这些进程一般定时执行。</li>
</ol>
<p>为什么cpu要执行idle线程？因为CPU需要执行指令才能保持正常运行。CPU按照“取指令（Fetch）—解码（Decode）—执行（Execute）”的周期运行。如果没有指令可以取，或者取到的指令无法正确解码，CPU无法正常工作。程序计数器（PC）用于指示下一条需要执行的指令地址。如果没有明确的任务，PC可能指向无效地址，导致不可预测的行为。</p>
<h3 id="进程队列"><a href="#进程队列" class="headerlink" title="进程队列"></a>进程队列</h3><p>进程管理器需要把已经创建的进程放入队列中, 进程排队接受多核cpu的处理。</p>
<p>进程调度器有很多设计值得学习的，例如</p>
<ol>
<li>就绪任务采用优先级队列组织，支持任务公平调度和任务抢占</li>
<li>存在等待队列存放需要等待较长时间，需要唤醒的任务</li>
<li>停止队列支持任务暂停和断点继续执行</li>
<li>任务执行前创建结构，执行完销毁结构</li>
</ol>
<h4 id="就绪队列（Ready-Queue）"><a href="#就绪队列（Ready-Queue）" class="headerlink" title="就绪队列（Ready Queue）"></a>就绪队列（Ready Queue）</h4><p>就绪队列是一个<strong>优先级队列</strong>。</p>
<p>新创建的进程会放入就绪队列Ready Queue，等待队列是进程调度的对象，将这些进程调度给CPU执行。Linux使用 CFS调度器（完全公平调度器） 管理就绪队列。CFS调度器通过一个红黑树（rb_tree）来组织进程，就绪队列中的每个进程以其虚拟运行时间作为排序依据。</p>
<p>调度器从红黑树中选择虚拟运行时间最小的进程进行执行。当进程时间片用完，或被抢占，进程更新虚拟运行时间后重新插入到就绪队列</p>
<p>就绪队列中进程的状态是R (TASK_RUNNING)</p>
<h4 id="等待队列（Wait-Queue）"><a href="#等待队列（Wait-Queue）" class="headerlink" title="等待队列（Wait Queue）"></a>等待队列（Wait Queue）</h4><p>进程在等待某些事件（如IO完成、信号到达、锁释放）时进入该队列。对应进程S状态和D状态</p>
<p>进程S状态TASK_INTERRUPTIBLE，可中断的睡眠状态。例如等待锁，等待socket事件。该状态进程可被调度器调度。</p>
<p>D状态TASK_UNINTERRUPTIBLE，不可中断的睡眠状态。该状态进程无法响应信号，无法被调度，只能等待IO执行完毕（但可以响应硬中断）。例如进程等待磁盘IO期间无法中断，原因1. 进程没必要被中断，数据到不了中断也处理不了什么 2. 简化实现，防止IO读写没有进程处理导致问题 3. 避免由于磁盘等故障导致大量进程持续中断。</p>
<p>对于持有spinlock的进程需要屏蔽中断，但这时候的进程不是等待状态。</p>
<h4 id="停止队列（Stopped-Queue）"><a href="#停止队列（Stopped-Queue）" class="headerlink" title="停止队列（Stopped Queue）"></a>停止队列（Stopped Queue）</h4><p>进程被暂停（例如接收到SIGSTOP信号）后进入该队列，例如ptrace机制调试进程时会暂停某些进程，放入停止队列中。</p>
<p>停止队列中的进程不会被调度器调度，直到接收到恢复信号（如SIGCONT）。</p>
<h4 id="僵尸队列（Zombie-Queue）"><a href="#僵尸队列（Zombie-Queue）" class="headerlink" title="僵尸队列（Zombie Queue）"></a>僵尸队列（Zombie Queue）</h4><p>包含所有处于TASK_ZOMBIE状态的进程。僵尸进程是已结束执行但尚未被其父进程回收的进程。</p>
<p>父进程调用wait族函数等待子进程执行完并回收时，僵尸进程会被从队列中移除。</p>
<p>TASK_DEAD状态的进程会被系统回收所有资源，释放进程控制块（PCB）。</p>
<h3 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h3><p>实时进程优先级：范围从 1 到 99（高优先级）。实时进程调度时，高优先级的进程必须执行完毕或主动放弃 CPU，低优先级的进程才能运行。</p>
<p>普通进程优先级：范围从 100 到 139（低优先级）。默认优先级为 120。普通进程使用 完全公平调度器（CFS），CFS中，执行时间少的进程在计算时会有较高的动态优先级。</p>
<h4 id="普通进程优先级"><a href="#普通进程优先级" class="headerlink" title="普通进程优先级"></a>普通进程优先级</h4><p>可以通过 nice 或 renice 命令设置普通进程的静态优先级。范围：-20（最高优先级）到 19（最低优先级）。<strong>nice默认值为 0。</strong><br>nice 值越低，进程优先级越高。</p>
<p>内核线程是由内核创建并运行的任务，通常用于关键系统功能，优先级由内核自行分配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进程类别	优先级范围	优先级特点</span><br><span class="line">kswapd	高	内存页面交换线程，优先级较高</span><br><span class="line">kworker	高	内核工作队列处理线程</span><br><span class="line">khugepaged	中	大页面分配优化</span><br><span class="line">jbd2	中	日志缓冲区管理线程</span><br></pre></td></tr></table></figure>

<p>系统服务和守护进程通常负责后台任务，默认优先级设置中等，以确保它们不会过多占用 CPU，但仍能及时响应。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">进程类别	默认 Nice 值	优先级特点</span><br><span class="line">init/systemd	0	系统初始化进程，优先级适中</span><br><span class="line">cron	0	定时任务调度器，重要但无需实时响应</span><br><span class="line">sshd	0	远程登录服务，优先级适中</span><br><span class="line">udevd	0	设备管理服务，实时性要求中等</span><br><span class="line">NetworkManager	0	网络管理，重要性较高</span><br><span class="line">rsyslogd	0	日志服务，优先级适中</span><br></pre></td></tr></table></figure>

<h3 id="完全公平调度CFS"><a href="#完全公平调度CFS" class="headerlink" title="完全公平调度CFS"></a>完全公平调度CFS</h3><ol>
<li>操作系统统计周期内每个进程的执行时间，这个执行时间是个虚拟执行时间vriture_runtime，计算时会考虑进程优先级，优先级高的进程统计的执行时间会偏少。</li>
<li>执行时间少的进程在下个周期优先执行</li>
</ol>
<p>进程切换，Linux内核使用定时器硬中断来实现时间片轮转调度。当定时器中断发生时，内核会检查当前运行的进程是否超过其时间片。是则进行进程切换。定时器中断的频率通常为100Hz或1000Hz，表示每隔10ms或1ms中断一次。</p>
<h2 id="进程协调"><a href="#进程协调" class="headerlink" title="进程协调"></a>进程协调</h2><p>进程协调的手段包括两个部分</p>
<ol>
<li>协调进程切换，包括信号、硬&#x2F;软中断、系统调用</li>
<li>协调进程&#x2F;线程同步，包括锁、条件变量、信号量等</li>
</ol>
<h3 id="协调进程切换"><a href="#协调进程切换" class="headerlink" title="协调进程切换"></a>协调进程切换</h3><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>当进程从执行用户代码转向执行内核代码时，就发生系统调用。需要注意该过程不发生进程切换。</p>
<ol>
<li>进入内核代码前，进程首先调用<code>int $0x80</code>或<code>syscall指令</code>，该指令会让CPU转向执行（entry_INT80_32或entry_SYSCALL_64）汇编代码，即根据系统调⽤号调⽤对应的内核处理函数。</li>
<li>执行内核处理函数前，cpu 将当前寄存器内容保存到用户栈，使用内核栈执行内核处理函数</li>
<li>内核处理函数执行完后，调用sysret 指令从用户栈恢复寄存器内容，使用用户栈继续执行用户程序</li>
</ol>
<p>为什么执行内核代码需要调用<code>int $0x80</code>或syscall指令，而不是直接函数调用的形式执行？<br>因为系统调用状态的保存是CPU硬件实现的，CPU的两个寄存器</p>
<p>MSR_LSTAR：保存内核系统调用入口的地址。<br>MSR_STAR：保存用户态和内核态的代码段选择器。</p>
<p>在syscall指令中，寄存器保存用户栈，执行内核函数，恢复用户栈都是硬件实现的。只需要调用CPU指令。操作系统只需要配置相关寄存器然后调用指令即可。</p>
<p>在<code>int $0x80</code>中，寄存器保存用户栈，执行内核函数，恢复用户栈是操作系统软件实现的（性能差于syscall，现代CPU基本使用后者），操作系统把处理函数注册到中断向量表IDT的0x80位置。当进程执行int $0x80指令，CPU会自动从寄存器找到IDT地址，转向执行处理函数（IDT的地址存放在寄存器IDT 寄存器（IDTR））。“CPU从寄存器找到IDT，转向执行处理函数”这是硬件实现的。</p>
<h4 id="硬中断和中断向量表"><a href="#硬中断和中断向量表" class="headerlink" title="硬中断和中断向量表"></a>硬中断和中断向量表</h4><p>上面说到，系统调用可以通过发起<code>int $0x80</code>指令，CPU自动从中断向量表找到处理函数。中断向量表IDT是中断执行的核心，中断函数由操作系统注册，但无法直接执行，只能借助cpu中断表执行。中断优先级与向量号直接相关，向量号越低优先级越高。</p>
<p>硬中断和中断向量表，中断的对象是CPU。通过CPU引脚信号&#x2F;CPU指令来触发中断。硬中断可以抢占CPU，一般来说，如果用户态进程发生了硬中断&#x2F;异常，执行硬中断处理函数的进程和用户态进程是一个。如果硬中断不是由用户态进程产生，例如时间片用尽、磁盘网络IO中断，中断处理函数由kworker 执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  Vectors   0 ...  31 : system traps and exceptions - hardcoded events</span></span><br><span class="line"><span class="comment">*  Vectors  32 ... 127 : device interrupts</span></span><br><span class="line"><span class="comment">*  Vector  128         : legacy int80 syscall interface</span></span><br><span class="line"><span class="comment">*  Vectors 129 ... INVALIDATE_TLB_VECTOR_START-1 except 204 : device interrupts</span></span><br><span class="line"><span class="comment">*  Vectors INVALIDATE_TLB_VECTOR_START ... 255 : special interrupts</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>0-31中保存的是异常的中断向量，这些异常包括除0、断点调试、边界溢出、段错误、浮点数异常等，中断处理会转向执行查找进程对应的异常处理函数，默认是异常退出进程（向进程发SIGINT信号,程序异常退出）</p>
<p>为什么使用中断处理异常？因为异常是运行态的，程序编译后并不知道异常会不会执行。<strong>当CPU执行遇到异常后，不能继续执行原程序的指令。</strong> 只能去IDT执行异常函数的处理指令。</p>
<p>CPU转向执行异常，需要1. 停止当前指令执行; 2. 保存 CPU 状态; 3. 跳转到指定的处理程序处理。</p>
<p>CPU&#x2F;进程上下文切换也是通过硬中断实现，同样需要1. 停止当前进程指令执行; 2. 保存 CPU 状态; 3. 跳转转型下一个进程的指令。CPU&#x2F;进程上下文是否切换 等价于 是否出现硬中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Interrupts/Exceptions */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	X86_TRAP_DE = <span class="number">0</span>,	<span class="comment">/*  0, Divide-by-zero */</span></span><br><span class="line">	X86_TRAP_DB,		<span class="comment">/*  1, Debug */</span></span><br><span class="line">	X86_TRAP_NMI,		<span class="comment">/*  2, Non-maskable Interrupt */</span></span><br><span class="line">	X86_TRAP_BP,		<span class="comment">/*  3, Breakpoint */</span></span><br><span class="line">	X86_TRAP_OF,		<span class="comment">/*  4, Overflow */</span></span><br><span class="line">	X86_TRAP_BR,		<span class="comment">/*  5, Bound Range Exceeded */</span></span><br><span class="line">	X86_TRAP_UD,		<span class="comment">/*  6, Invalid Opcode */</span></span><br><span class="line">	X86_TRAP_NM,		<span class="comment">/*  7, Device Not Available */</span></span><br><span class="line">	X86_TRAP_DF,		<span class="comment">/*  8, Double Fault */</span></span><br><span class="line">	X86_TRAP_OLD_MF,	<span class="comment">/*  9, Coprocessor Segment Overrun */</span></span><br><span class="line">	X86_TRAP_TS,		<span class="comment">/* 10, Invalid TSS */</span></span><br><span class="line">	X86_TRAP_NP,		<span class="comment">/* 11, Segment Not Present */</span></span><br><span class="line">	X86_TRAP_SS,		<span class="comment">/* 12, Stack Segment Fault */</span></span><br><span class="line">	X86_TRAP_GP,		<span class="comment">/* 13, General Protection Fault */</span></span><br><span class="line">	X86_TRAP_PF,		<span class="comment">/* 14, Page Fault */</span></span><br><span class="line">	X86_TRAP_SPURIOUS,	<span class="comment">/* 15, Spurious Interrupt */</span></span><br><span class="line">	X86_TRAP_MF,		<span class="comment">/* 16, x87 Floating-Point Exception */</span></span><br><span class="line">	X86_TRAP_AC,		<span class="comment">/* 17, Alignment Check */</span></span><br><span class="line">	X86_TRAP_MC,		<span class="comment">/* 18, Machine Check */</span></span><br><span class="line">	X86_TRAP_XF,		<span class="comment">/* 19, SIMD Floating-Point Exception */</span></span><br><span class="line">	X86_TRAP_IRET = <span class="number">32</span>,	<span class="comment">/* 32, IRET Exception */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>向量 32 到 127，分配给硬件中断和其他系统用途。硬件中断的触发，连接cpu引脚的硬件会向引脚发送信号，cpu收到信号会立即暂停当前程序处理（屏蔽中断的除外），从idt中找到硬件中断处理函数执行。</p>
<p>对需要较长时间处理的中断，例如网卡磁盘收发数据。为了时效性，硬件中断处理函数只是创建一个异步任务到队列就返回，任务具体的处理由后续软中断负责。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">IRQ	    中断号	用途</span><br><span class="line">IRQ 0	32	系统定时器（时钟中断）</span><br><span class="line">IRQ 1	33	键盘</span><br><span class="line">IRQ 2	34	可编程中断控制器级联</span><br><span class="line">IRQ 3	35	串口 2</span><br><span class="line">IRQ 4	36	串口 1</span><br><span class="line">IRQ 5	37	并口 2 / 声卡</span><br><span class="line">IRQ 6	38	软盘控制器</span><br><span class="line">IRQ 7	39	并口 1</span><br><span class="line">IRQ 8	40	CMOS 实时时钟</span><br><span class="line">IRQ 9	41	可用（通常用于 ACPI）</span><br><span class="line">IRQ 10	42	可用</span><br><span class="line">IRQ 11	43	可用</span><br><span class="line">IRQ 12	44	PS/2 鼠标</span><br><span class="line">IRQ 13	45	协处理器 / FPU</span><br><span class="line">IRQ 14	46	主 IDE 控制器</span><br><span class="line">IRQ 15	47	从 IDE 控制器</span><br></pre></td></tr></table></figure>


<p>向量 128（0x80），用于系统调用（如 int $0x80）。</p>
<p>向量 129 到 255，用户自定义的硬中断。例如，int 0x81：某些调试工具可能使用该中断来与内核交互；int 0xFF：某些实时系统可能定义为特殊的系统功能调用；APIC 定时器通常分配到高向量。</p>
<h4 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h4><p>软中断和软中断向量表，是内核软件层实现的（软中断号，处理函数）的映射，目的是异步任务延迟调度，没有直接影响到CPU，不抢占CPU。软中断和是否出现CPU&#x2F;进程上下文切换没有联系。</p>
<p>软中断通过内核代码调用 raise_softirq() 触发。主要可以分为1. 定时器（很重要，比如处理超时锁等待，sleep超时） 2. 网络发送接收 3. 块设备IO 4. Tasklet 等类型。Tasklet是用户注册的一种函数，该函数和软中断一起被执行。</p>
<p>每个cpu维护一个软中断队列，软中断的执行不会切换CPU。如果CPU软中断占用时间长，可能是网络包是大量的小包，也可能是磁盘&#x2F;网络处理慢。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">软中断号	名称	用途</span><br><span class="line">0	HI_SOFTIRQ	高优先级任务，通常用于调度紧急操作。</span><br><span class="line">1	TIMER_SOFTIRQ	定时器中断，用于触发周期性任务，如更新系统时间，超时唤醒等待的进程。</span><br><span class="line">2	NET_TX_SOFTIRQ	网络发送中断，用于网络数据的发送操作。</span><br><span class="line">3	NET_RX_SOFTIRQ	网络接收中断，用于处理接收到的网络数据包。</span><br><span class="line">4	BLOCK_SOFTIRQ	块设备中断，用于处理块设备的异步 I/O 操作。</span><br><span class="line">5	IRQ_POLL_SOFTIRQ	中断轮询，用于处理某些设备的中断轮询机制。</span><br><span class="line">6	TASKLET_SOFTIRQ	Tasklet 中断，用于调度较低优先级的任务。</span><br><span class="line">7	SCHED_SOFTIRQ	调度中断，用于进程调度器的运行队列更新。</span><br><span class="line">8	HRTIMER_SOFTIRQ	高精度定时器中断，用于处理精确的定时器任务。</span><br><span class="line">9	RCU_SOFTIRQ	RCU（Read-Copy-Update）机制，用于内存管理。</span><br></pre></td></tr></table></figure>

<p>软中断的处理时机</p>
<ol>
<li><strong>硬中断处理完成后</strong>，内核会检查是否有挂起的软中断。如果有则执行</li>
<li><strong>在某些内核路径中</strong>，内核会主动调用 do_softirq() 来检查和执行挂起的软中断。例如网络协议栈处理数据包时，通过 net_rx_action() 调用软中断；高精度定时器中，触发 hrtimer 相关软中断。</li>
</ol>
<p>软中断的优先级高于普通任务。当软中断执行时间较长、内核会将剩余未处理的软中断交给专用线程 ksoftirqd 来执行。</p>
<h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><p>软中断和信号的区别是，软中断是CPU级别的，软中断得到的网络包、磁盘数据包需要另外拷贝到进程空间才能被进程使用。而信号是针对进程的。也就是说，操作系统为每个CPU维护一个软中断任务队列，但每个进程都维护了自己的信号任务队列。</p>
<p>信号执行的时机</p>
<ol>
<li>进程从系统态返回到用户态的前夕，也就是一个用户态的进程由于系统调用、硬中断（进程切换）或异常而进入系统空间，执行完后返回用户态前，处理信号</li>
<li>进程在进入等待队列后刚被唤醒的时候</li>
</ol>
<p>信号可以由内核发起（内核想影响某进程的执行，主要是通知某进程终止）就给该进程发个信号，虽然都是通知进程退出，但退出原因不同。退出原因可以是终端中断，中断退出，杀死，运算错误，段错误等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#define SIGHUP 1	终端挂起或控制进程终止</span><br><span class="line">#define SIGINT 2	终端中断(Ctrl+C 组合键)</span><br><span class="line">#define SIGQUIT 3	终端退出(Ctrl+\组合键)</span><br><span class="line">#define SIGILL 4	非法指令</span><br><span class="line">#define SIGTRAP 5	debug 使用，有断点指令产生</span><br><span class="line">#define SIGABRT 6	由 abort(3)发出的退出指令</span><br><span class="line">#define SIGIOT 6	IOT 指令</span><br><span class="line">#define SIGBUS 7	总线错误</span><br><span class="line">#define SIGFPE 8	浮点运算错误</span><br><span class="line">#define SIGKILL 9	杀死、终止进程</span><br><span class="line">#define SIGUSR1 10	用户自定义信号 1</span><br><span class="line">#define SIGSEGV 11	段违例(无效的内存段)</span><br><span class="line">#define SIGUSR2 12	用户自定义信号 2</span><br><span class="line">#define SIGPIPE 13	向非读管道写入数据</span><br><span class="line">#define SIGALRM 14	闹钟</span><br><span class="line">#define SIGTERM 15	软件终止</span><br><span class="line">#define SIGSTKFLT 16	栈异常</span><br><span class="line">#define SIGCHLD 17	子进程结束</span><br><span class="line">#define SIGCONT 18	进程继续</span><br><span class="line">#define SIGSTOP 19	停止进程的执行，只是暂停</span><br><span class="line">#define SIGTSTP 20	停止进程的运行(Ctrl+Z 组合键)</span><br><span class="line">#define SIGTTIN 21	后台进程需要从终端读取数据</span><br><span class="line">#define SIGTTOU 22	后台进程需要向终端写数据</span><br><span class="line">#define SIGURG 23	有&quot;紧急&quot;数据</span><br><span class="line">#define SIGXCPU 24	超过 CPU 资源限制</span><br><span class="line">#define SIGXFSZ 25	文件大小超额</span><br><span class="line">#define SIGVTALRM 26	虚拟时钟信号</span><br><span class="line">#define SIGPROF 27	时钟信号描述</span><br><span class="line">#define SIGWINCH 28	窗口大小改变</span><br><span class="line">#define SIGIO 29	可以进行输入/输出操作</span><br><span class="line">#define SIGPOLL	SIGIO</span><br><span class="line">#define SIGPWR 30	断点重启</span><br><span class="line">#define SIGSYS 31	非法的系统调用</span><br><span class="line">#define SIGUNUSED 32	未使用信号</span><br></pre></td></tr></table></figure>

<p>磁盘&#x2F;网络数据可读可写也可以通过SIGIO信号通知到进程，也就是所说的“信号驱动式IO”。但更广泛的是通过事件通知。除了信号驱动和事件通知（非阻塞IO），进程默认是阻塞等待数据可读可写，这是通过软中断实现。软中断获得数据并把数据拷贝到进程空间后，会唤醒正在睡眠的进程，将进程从等待队列转到就绪队列。</p>
<h4 id="事件通知"><a href="#事件通知" class="headerlink" title="事件通知"></a>事件通知</h4><p>采用阻塞IO的进程会有先进入等待队列，数据就绪后重新进入就绪队列的逻辑。如果采用非阻塞IO，进程不会进入等待队列。</p>
<p>linux的字符设备&#x2F;块设备&#x2F;网络IO ，在进程中可以用文件描述符fd标识。设置文件描述符为非阻塞模式（O_NONBLOCK）从而采用非阻塞IO。</p>
<p>文件描述符可以与多个事件关联，这些事件表示文件描述符的状态变化，例如数据可读、可写或发生错误。linux 内部采用了事件通知的模型</p>
<ol>
<li>消费者（进程）注册感兴趣的事件和事件回调函数，例如进程注册感兴趣的读写事件</li>
<li>软中断将数据拷贝到用户进程空间后，会匹配注册的事件，执行对应的事件处理函数。<ol>
<li>如果是select&#x2F;poll，事件处理函数就是把事件设置到select 列表对应的fd，等待进程轮询找到满足事件的fd</li>
<li>如果是epoll，事件处理函数就是从红黑树找到对应等待的文件描述符，将fd转移到就绪队列，唤醒阻塞在epoll_wait等待的进程。epoll_wait还会通过超时解除阻塞。</li>
</ol>
</li>
</ol>
<p>事件通知驱动和主动轮询驱动 对协调模块的设计，例如消息队列， 也具有很大参考意义</p>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>锁是协调多个任务对临界区的执行，锁保证，一个任务要么独占执行完临界区，要么不执行临界区，不允许临界区同时被多个任务执行。</p>
<p>单机锁主要有三种，自旋锁，互斥锁，读写锁。自旋锁是互斥锁一种特殊实现</p>
<ol>
<li>spinlock 主要是保护多cpu操作对象的安全，可以是cpu共享的硬件变量，为了防止死锁，加spinlock需要屏蔽当前cpu的中断。<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dream397/p/15902203.html">为了防止死锁，spinlock需要关中断和禁止抢占</a></li>
<li>mutex，存放在内存的共享变量，维护多线程的安全</li>
<li>读写锁，使用count实现。读锁count-1，写锁count-很大的magic number。通过count值能知道目前持有读锁还是写锁。读写锁问题是读操作不需要等待，如果对象持续被读，写会被饿死。</li>
</ol>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul></div><div class="post-nav"><a class="pre" href="/2024/11/10/linux%E7%B3%BB%E7%BB%9F(2)%E2%80%94%E5%86%85%E5%AD%98%E5%92%8CIO%E7%BD%91%E7%BB%9C/">linux系统(2)——内存和IO网络</a><a class="next" href="/2024/11/05/hello-world/">Hello World</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://larrystd.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>To be a better man.</p><a class="info-icon" href="https://twitter.com/username" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:admin@domain.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/application/">application</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/compute/">compute</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hello/">hello</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/language/">language</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/storage/">storage</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/hello/" style="font-size: 15px;">hello</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/brpc/" style="font-size: 15px;">brpc</a> <a href="/tags/storage/" style="font-size: 15px;">storage</a> <a href="/tags/leveldb/" style="font-size: 15px;">leveldb</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/application/" style="font-size: 15px;">application</a> <a href="/tags/base/" style="font-size: 15px;">base</a> <a href="/tags/language/" style="font-size: 15px;">language</a> <a href="/tags/cpp/" style="font-size: 15px;">cpp</a> <a href="/tags/coroutine/" style="font-size: 15px;">coroutine</a> <a href="/tags/compute/" style="font-size: 15px;">compute</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/07/06/brpc(1)%E2%80%94bthread%E5%92%8Cbrpc/">brpc(1)—bthread和brpc</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/03/%E8%AE%A1%E7%AE%97(2)%E2%80%94GPU%E8%AE%A1%E7%AE%97%E5%92%8C%E5%A4%A7%E6%A8%A1%E5%9E%8B/">计算(2)——GPU计算和大模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/27/%E8%AE%A1%E7%AE%97(1)%E2%80%94CPU%E8%AE%A1%E7%AE%97%E5%92%8C%E5%A4%A7%E6%95%B0%E6%8D%AE/">计算(1)——CPU计算和大数据</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94C++%E5%8F%B3%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/">编程语言——C++右值和右值引用</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/20/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94C++%E5%8D%8F%E7%A8%8B%E5%92%8C%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/">编程语言——C++协程和高性能编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/07/%E5%AD%98%E5%82%A8%E2%80%94%E8%B0%88%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">存储——谈存储文件系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/15/leveldb(2)%E2%80%94%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/">leveldb(2)—线程模型和并发控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/12/redis(2)%E2%80%94%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/">redis(2)——网络处理和持久化</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/10/redis(1)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">redis(1)——数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/31/leveldb(1)%E2%80%94%E6%A6%82%E8%A7%88/">leveldb(1)—概览</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2026 <a href="/." rel="nofollow">Infinity Code.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>