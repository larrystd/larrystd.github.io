<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>redis(2)——网络处理和rdb,aof持久化 | Infinity Code</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">redis(2)——网络处理和rdb,aof持久化</h1><a id="logo" href="/.">Infinity Code</a><p class="description">Simplicity is the soul of efficiency.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">redis(2)——网络处理和rdb,aof持久化</h1><div class="post-meta">创建: 2025-02-12<span> | 更新: 2025-02-11</span><span> | </span><category class="name"></category><span class="category"><a href="/categories/single-machine/">single-machine</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 本文共 1.9k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 阅读需要 8</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">网络处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%92%8Ceventloop-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.1.</span> <span class="toc-text">事件和eventloop 事件循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">事件处理函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rdb%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">rdb持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rdbsave"><span class="toc-number">2.1.</span> <span class="toc-text">rdbsave</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdbsave-%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">rdbsave 的调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdbLoadRio"><span class="toc-number">2.3.</span> <span class="toc-text">rdbLoadRio</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aof%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">aof持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#aof-rewrite"><span class="toc-number">3.1.</span> <span class="toc-text">aof rewrite</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pub-sub"><span class="toc-number">4.</span> <span class="toc-text">pub-sub</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SubscribeChannel"><span class="toc-number">4.1.</span> <span class="toc-text">SubscribeChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pubsubPublishMessage"><span class="toc-number">4.2.</span> <span class="toc-text">pubsubPublishMessage</span></a></li></ol></li></ol></div></div><div class="post-content"><p>redis 通过网络服务接收远程命令，进行处理，将执行结果返回</p>
<span id="more"></span>

<h3 id="网络处理"><a href="#网络处理" class="headerlink" title="网络处理"></a>网络处理</h3><p>redis 的网络处理类似常见的IO多路复用网络库，通过事件通知实现单线程处理大量来自不同客户端的事件。</p>
<h4 id="事件和eventloop-事件循环"><a href="#事件和eventloop-事件循环" class="headerlink" title="事件和eventloop 事件循环"></a>事件和eventloop 事件循环</h4><p>三种事件aeFileEvent（注册的网络事件），aeTimeEvent（定时事件），firedEvent用来存放epoll返回的就绪事件（即需要处理的事件）</p>
<p>网络事件通过epoll 监听fd可读可写（即网络包可读可写）触发；定时事件通过获得下一个最近事件的执行时间、定时触发；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">aeFileEvent</span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">/* File event structure */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">aeFileEvent</span> &#123;</span><br><span class="line">    <span class="type">int</span> mask; <span class="comment">/* one of AE_(READABLE|WRITABLE) */</span></span><br><span class="line">    aeFileProc *rfileProc;</span><br><span class="line">    aeFileProc *wfileProc;</span><br><span class="line">    <span class="type">void</span> *clientData;</span><br><span class="line">&#125; aeFileEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Time event structure */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">aeTimeEvent</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> id; <span class="comment">/* time event identifier. */</span></span><br><span class="line">    <span class="type">long</span> when_sec; <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">long</span> when_ms; <span class="comment">/* milliseconds */</span></span><br><span class="line">    aeTimeProc *timeProc;</span><br><span class="line">    aeEventFinalizerProc *finalizerProc;</span><br><span class="line">    <span class="type">void</span> *clientData;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">aeTimeEvent</span> *next;</span><br><span class="line">&#125; aeTimeEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A fired event */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">aeFiredEvent</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line">&#125; aeFiredEvent;</span><br></pre></td></tr></table></figure>

<p>eventloop的核心是aeProcessEvents函数，执行逻辑如下</p>
<ol>
<li>计算最近的定时事件需要等待的时间t。shortest &#x3D; aeSearchNearestTimer(eventLoop) </li>
<li>numevents &#x3D; aeApiPoll(eventLoop, tvp); 执行epoll_wait，超时时间为上述需要等待的时间t</li>
<li>遍历eventLoop-&gt;fired[j].fd获得触发的事件，根据事件读写类型执行处理函数；fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);  fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</li>
<li>处理定时事件processTimeEvents</li>
</ol>
<h4 id="事件处理函数"><a href="#事件处理函数" class="headerlink" title="事件处理函数"></a>事件处理函数</h4><ol>
<li>acceptTcpHandler<br>用来接受和建立连接，acceptTcpHandler会创建client</li>
</ol>
<p>创建Client时，同时创建对该client的fileevent 可读事件，处理函数是readQueryFromClient。linux的accept() 会从监听 socket 的已完成连接队列中取出一个客户端连接，并为其创建一个 新的 socket。该fd标志了client和filevent可读事件。</p>
<ol start="2">
<li>readQueryFromClient</li>
</ol>
<p><code>void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask)</code></p>
<ol>
<li>生成c-&gt;querybuf &#x3D; sdsMakeRoomFor(c-&gt;querybuf, readlen);</li>
<li>nread &#x3D; read(fd, c-&gt;querybuf+qblen, readlen);</li>
<li>调用processInputBuffer(c);函数</li>
</ol>
<p>processInputBuffer 内部是processCommand，主要执行两步</p>
<ol>
<li>获取命令<code>c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[0]-&gt;ptr);</code></li>
<li>处理命令call(c,CMD_CALL_FULL);</li>
</ol>
<h3 id="rdb持久化"><a href="#rdb持久化" class="headerlink" title="rdb持久化"></a>rdb持久化</h3><p>rdb, replicate db</p>
<p>暂只看rdbsave和rdbload</p>
<h4 id="rdbsave"><a href="#rdbsave" class="headerlink" title="rdbsave"></a>rdbsave</h4><p><code>int rdbSave(char *filename, rdbSaveInfo *rsi)</code></p>
<ol>
<li>snprintf(tmpfile,256,”temp-%d.rdb”, (int) getpid()); fp &#x3D; fopen(tmpfile,”w”);</li>
<li>rioInitWithFile(&amp;rdb,fp);</li>
<li>rdbSaveRio(&amp;rdb,&amp;error,RDB_SAVE_NONE,rsi)</li>
<li>fflush(fp) &#x3D;&#x3D; EOF fsync(fileno(fp)  fclose(fp) &#x3D;&#x3D; EOF</li>
<li>rename(tmpfile,filename)</li>
</ol>
<p>fflush是flush文件流到page cache，fsync是刷page cache到文件落盘</p>
<p>其中的rdbSaveRio 函数，rdbSaveRio(&amp;rdb,&amp;error,RDB_SAVE_NONE,rsi)</p>
<ol>
<li>写入”REDIS%04d”,RDB_VERSION</li>
<li>rdbSaveInfoAuxFields(rdb,flags,rsi)</li>
<li>遍历server.dbnum<ol>
<li>对每个db，redisDb。每个db内部其实是db-&gt;dict，</li>
<li>写入一些元数据，包括rdbSaveType(rdb,RDB_OPCODE_SELECTDB)</li>
<li>rdbSaveLen(rdb,j)</li>
<li>rdbSaveType(rdb,RDB_OPCODE_RESIZEDB) </li>
<li>rdbSaveLen(rdb,db_size)</li>
<li>rdbSaveLen(rdb,expires_size)</li>
<li>遍历db-&gt;dict，拿到sds keystr &#x3D; dictGetKey(de);，robj key, <code>*o = dictGetVal(de);</code>，执行rdbSaveKeyValuePair(rdb,&amp;key,o,expire,now)</li>
</ol>
</li>
</ol>
<h4 id="rdbsave-的调用"><a href="#rdbsave-的调用" class="headerlink" title="rdbsave 的调用"></a>rdbsave 的调用</h4><p>rdbSaveBackground执行调用childpid &#x3D; fork() 启动进程，在子进程里执行rdbSave(filename,rsi);</p>
<p>fork()的子进程初始利用写时复制共享父进程内存。写时复制情况下，父子进程修改共享内存页时，均会复制共享页到新的物理内存页。</p>
<p>写时复制保证子进程的内存始终和父进程调用fork()时的状态一致，就是说，<strong>子进程rdbSave 的dict 内容和父进程fork()时的一致，且不会因后续父进程对dict的写入而改变。。</strong>以上由操作系统保证。太6了</p>
<p>如果父进程大量修改数据（触发大量 COW），可能导致内存和 CPU 压力增大，但这属于资源问题，影响可控</p>
<p>rdbsave的定时和手动调度</p>
<p>后台执行时会设置执行的child_pid，从而判断是否后台正在执行备份<br>server.rdb_child_pid !&#x3D; -1 || server.aof_child_pid !&#x3D; -1</p>
<p>replicationCron -&gt; startBgsaveForReplication<br>replicationCron 一秒钟执行一次</p>
<p>syncCommand-&gt; startBgsaveForReplication</p>
<h4 id="rdbLoadRio"><a href="#rdbLoadRio" class="headerlink" title="rdbLoadRio"></a>rdbLoadRio</h4><p><code>int rdbLoadRio(rio *rdb, rdbSaveInfo *rsi)</code></p>
<p>从文件里读数据</p>
<ol>
<li>首先读到”REDIS\0”</li>
<li>然后是一字节版本，rdbver &#x3D; atoi(buf+5);。算法<br>从第一个非空白字符开始，取一个可选的初始加号或者减号，后跟尽可能多的十进制数字，并将它们转换为一个<code>int</code>类型的数值。</li>
<li>循环执行<ol>
<li>type &#x3D; rdbLoadType(rdb)</li>
<li>根据type 类型执行以下操作，type的类型可以是RDB_OPCODE_EOF表示结束</li>
<li>解析出key &#x3D; rdbLoadStringObject(rdb) 和val &#x3D; rdbLoadObject(type,rdb)</li>
<li>将kv写入到hash table dbAdd(db,key,val);</li>
</ol>
</li>
</ol>
<p>显然rdb会将某时刻hashtable的所有kv写入到rdb文件中。</p>
<h3 id="aof持久化"><a href="#aof持久化" class="headerlink" title="aof持久化"></a>aof持久化</h3><p>aof, append only file</p>
<p>rdb关心的是复制db的dict 的key, value，通过写kv数据恢复数据库状态。aof关心的是复制db的增删改操作，通过replay操作恢复数据库状态。</p>
<h4 id="aof-rewrite"><a href="#aof-rewrite" class="headerlink" title="aof rewrite"></a>aof rewrite</h4><p>aof 可以实现全量复制和增量复制。</p>
<p>aof 的rewrite 是将当前状态的dict的key value，全部保存为<code>set key value</code>操作，从而实现全量复制。</p>
<p>aof 增量复制通过父进程将写操作发给子进程实现。进程通信的方式是使用管道。创建管道会返回两个fd，分别给父子进程。进程利用fd和fileevent事件可以监听管道，子进程监听可写事件，父进程监听可读事件。</p>
<p>当执行aof时，父进程接收到写请求，在处理请求之外，会把写操作写入到管道。当执行rdb或aof时，redis会把执行的子进程id记录，通过判断子进程id存在可以得到是否正在执行rdb&#x2F;aof。</p>
<p>Redis 4.0 引入了 混合持久化（通过配置 aof-use-rdb-preamble yes 启用）：重写后的 AOF 文件会以 RDB 格式开头，后续追加增量 AOF 命令。<br>此时，AOF 重写过程会先生成 RDB 数据，再追加新写入的 AOF 命令。</p>
<p>子进程执行逻辑</p>
<ol>
<li>如果设置了server.aof_use_rdb_preamble，处理rdb；否则，执行rewriteAppendOnlyFileRio，遍历dict，将当前dict存放的key, value转换成SET key value 写入到aof文件</li>
<li>循环执行aofReadDiffFromParent(); 读rewrite期间父进程的写入，到server.aof_child_diff</li>
<li>执行rioWrite(&amp;aof,server.aof_child_diff,sdslen(server.aof_child_diff)，写入到rio</li>
</ol>
<p>aofReadDiffFromParent 从管道读数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function is called by the child rewriting the AOF file to read</span></span><br><span class="line"><span class="comment"> * the difference accumulated from the parent into a buffer, that is</span></span><br><span class="line"><span class="comment"> * concatenated at the end of the rewrite. */</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">aofReadDiffFromParent</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">65536</span>]; <span class="comment">/* Default pipe buffer size on most Linux systems. */</span></span><br><span class="line">    <span class="type">ssize_t</span> nread, total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((nread =</span><br><span class="line">            <span class="built_in">read</span>(server.aof_pipe_read_data_from_parent,buf,<span class="built_in">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        server.aof_child_diff = <span class="built_in">sdscatlen</span>(server.aof_child_diff,buf,nread);</span><br><span class="line">        total += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rio对应一个文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rioInitWithFile</span><span class="params">(rio *r, FILE *fp)</span> </span>&#123;</span><br><span class="line">    *r = rioFileIO;</span><br><span class="line">    r-&gt;io.file.fp = fp;</span><br><span class="line">    r-&gt;io.file.buffered = <span class="number">0</span>;</span><br><span class="line">    r-&gt;io.file.autosync = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> rio rioFileIO = &#123;</span><br><span class="line">    rioFileRead,</span><br><span class="line">    rioFileWrite,</span><br><span class="line">    rioFileTell,</span><br><span class="line">    rioFileFlush,</span><br><span class="line">    <span class="literal">NULL</span>,           <span class="comment">/* update_checksum */</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/* current checksum */</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/* bytes read or written */</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/* read/write chunk size */</span></span><br><span class="line">    &#123; &#123; <span class="literal">NULL</span>, <span class="number">0</span> &#125; &#125; <span class="comment">/* union for io-specific vars */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>主进程执行逻辑</p>
<ol>
<li>格式化数据到Buf，<code>server.expireCommand,argv[1], exarg</code></li>
<li>如果开启了aof，执行server.aof_buf &#x3D; sdscatlen(server.aof_buf,buf,sdslen(buf));</li>
<li>如果server.aof_child_pid !&#x3D; -1，表示有rewrite进程，执行aofRewriteBufferAppend((unsigned char*)buf,sdslen(buf));</li>
</ol>
<h3 id="pub-sub"><a href="#pub-sub" class="headerlink" title="pub-sub"></a>pub-sub</h3><p>pub-sub 是常用的网络服务</p>
<p>订阅-发布和关注某个up主，收到他们更新的消息，是类似的</p>
<h4 id="SubscribeChannel"><a href="#SubscribeChannel" class="headerlink" title="SubscribeChannel"></a>SubscribeChannel</h4><p>Subscribe a client to a channel. Returns 1 if the operation succeeded</p>
<p>c-&gt;pubsub_channels 是一个dict。注册的结果，key是channel，value是一个client list</p>
<h4 id="pubsubPublishMessage"><a href="#pubsubPublishMessage" class="headerlink" title="pubsubPublishMessage"></a>pubsubPublishMessage</h4><ol>
<li>利用dictFind(server.pubsub_channels,channel) 找到channel(key)，返回client list（value）</li>
<li>遍历list，对每个client，执行<code>addReply(c,shared.mbulkhdr[3]);</code>，<code>addReply(c,shared.messagebulk);</code> addReplyBulk(c,channel); addReplyBulk(c,message);</li>
</ol>
<p>addReply</p>
<ol>
<li>传入<code>robj *obj</code></li>
<li>addReplyToBuffer(c,obj-&gt;ptr,sdslen(obj-&gt;ptr)</li>
</ol>
<p>subscribeCommand</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">subscribeCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">        <span class="built_in">pubsubSubscribeChannel</span>(c,c-&gt;argv[j]);</span><br><span class="line">    c-&gt;flags |= CLIENT_PUBSUB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>publish command</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">publishCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> receivers = <span class="built_in">pubsubPublishMessage</span>(c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled)</span><br><span class="line">        <span class="built_in">clusterPropagatePublish</span>(c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        forceCommandPropagation(c,PROPAGATE_REPL);</span><br><span class="line">    <span class="built_in">addReplyLongLong</span>(c,receivers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>redis(2)——网络处理和rdb,aof持久化</p><p><span>文章作者：</span>Infinity</p><p><span>发布时间：</span>2025-02-12</p><p><span>最后更新：</span>2025-02-11</p><p><span>原始链接：</span><a href="/2025/02/12/redis(2)—网络处理和rdb,aof持久化/">https://larrystd.github.io/2025/02/12/redis(2)%E2%80%94%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86%E5%92%8Crdb,aof%E6%8C%81%E4%B9%85%E5%8C%96/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://larrystd.github.io/2025/02/12/redis(2)%E2%80%94%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86%E5%92%8Crdb,aof%E6%8C%81%E4%B9%85%E5%8C%96/"></i></span></p><p><span>版权声明：</span>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p></div><br><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/single-machine/" rel="tag">single-machine</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/storage/" rel="tag">storage</a></li></ul></div><div class="post-nav"><a class="next" href="/2025/02/10/redis(1)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">redis(1)——数据结构</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="https://unpkg.com/blueimp-md5/js/md5.js"></script><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: 'Ov23lifIyMlBwTu1yQhW',
  clientSecret: '8a6951b810e0f8c75acc7af48be63e53e7d6b5ad',
  repo: 'blogtalk',
  owner: 'larrystd',
  admin: ['larrystd'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>To be a better man.</p><a class="info-icon" href="venray.kong@outlook.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/larrystd" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/application/">application</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/base/">base</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hello/">hello</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/multi-machine/">multi-machine</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/single-machine/">single-machine</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/hello/" style="font-size: 15px;">hello</a> <a href="/tags/single-machine/" style="font-size: 15px;">single-machine</a> <a href="/tags/storage/" style="font-size: 15px;">storage</a> <a href="/tags/application/" style="font-size: 15px;">application</a> <a href="/tags/base/" style="font-size: 15px;">base</a> <a href="/tags/os/" style="font-size: 15px;">os</a> <a href="/tags/language/" style="font-size: 15px;">language</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/02/12/redis(2)%E2%80%94%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86%E5%92%8Crdb,aof%E6%8C%81%E4%B9%85%E5%8C%96/">redis(2)——网络处理和rdb,aof持久化</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/10/redis(1)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">redis(1)——数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/31/leveldb%E6%A6%82%E8%A7%88/">leveldb分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/07/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%BA%95%E5%BA%A7/">分布式存储底座</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(7)%E2%80%94%E7%BC%96%E8%AF%91%E3%80%81%E8%BF%90%E8%A1%8C%E5%92%8C%E8%B0%83%E8%AF%95/">编程语言(7)—编译、运行和调试</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/12/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(6)%E2%80%94%E6%96%87%E4%BB%B6IO%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%93/">编程语言(6)—文件IO和网络库</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/12/22/%E7%BC%93%E5%AD%98/">缓存</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/12/22/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0/">静态变量和函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/12/20/%E5%B9%B6%E5%8F%91%E6%80%BB%E8%A7%88/">并发</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/12/14/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(5)%E2%80%94%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/">编程语言(5)—并发编程和函数</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="todo" target="_blank">todo</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Infinity Code.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>