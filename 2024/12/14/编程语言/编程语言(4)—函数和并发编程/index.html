<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>编程语言(4)—函数和并发编程 | Infinity Code</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">编程语言(4)—函数和并发编程</h1><a id="logo" href="/.">Infinity Code</a><p class="description">Simplicity is the soul of efficiency.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">编程语言(4)—函数和并发编程</h1><div class="post-meta">2024-12-14<span> | </span><span class="category"><a href="/categories/language/">language</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">C语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread"><span class="toc-number">1.1.</span> <span class="toc-text">pthread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.</span> <span class="toc-text">原子操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C"><span class="toc-number">2.</span> <span class="toc-text">C++</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-11%E7%9A%84%E5%B9%B6%E5%8F%91%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">C++11的并发类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">2.2.</span> <span class="toc-text">智能指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">2.3.</span> <span class="toc-text">C++线程局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-11-%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">2.4.</span> <span class="toc-text">C++11 的原子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%BA%8F%E5%92%8C%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">2.5.</span> <span class="toc-text">内存序和可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.6.</span> <span class="toc-text">C++的lambda表达式和函数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">2.7.</span> <span class="toc-text">异常处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA"><span class="toc-number">3.</span> <span class="toc-text">JAVA</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JAVA-%E5%B9%B6%E5%8F%91%E7%B1%BB"><span class="toc-number">3.1.</span> <span class="toc-text">JAVA 并发类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">线程安全数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">3.3.</span> <span class="toc-text">JAVA多线程和虚拟机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">3.4.</span> <span class="toc-text">原子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-1"><span class="toc-number">3.5.</span> <span class="toc-text">异常处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Golang"><span class="toc-number">4.</span> <span class="toc-text">Golang</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.</span> <span class="toc-text">并发实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-1"><span class="toc-number">4.2.</span> <span class="toc-text">原子操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Context-%E5%8D%8F%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">Context 协程生命周期管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-2"><span class="toc-number">4.4.</span> <span class="toc-text">异常处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python"><span class="toc-number">5.</span> <span class="toc-text">Python</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.1.</span> <span class="toc-text">多线程和多进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E5%8D%8F%E7%A8%8B"><span class="toc-number">5.2.</span> <span class="toc-text">生成器和协程</span></a></li></ol></li></ol></div></div><div class="post-content"><p>并发编程是提高程序处理能力的重要手段，也是编程语言必备的能力。并发的对象是函数，函数作为任务被多个并发计算对象执行。</p>
<p>并发的单位可以是进程、线程和协程（用户态线程），并发需要保证的三个特点：原子性、顺序性和可见性。</p>
<ol>
<li>原子性表示操作要么全部成功，要么全部失败，执行中不能被中断。原子性通常使用锁（包括悲观锁、乐观锁）保证。</li>
<li>顺序性表示任务执行的顺序与任务提交时的顺序一致。顺序性通常使用队列（先进先出）保证，常见的是是生产者-消费队列保证顺序性，例如golang的channel。好的顺序设计，可以保证每个阶段只有少量线程执行，减少锁的使用。减少共享内存的使用，多用顺序性的信号通知，减少锁争抢。在分布式系统中，面对ABA问题，还会对操作和共享内存增加版本号来保证顺序性。</li>
<li>可见性表示对共享内存的修改对其他线程可见。常见的是使用内存屏障（memory barrier）保证可见性，内存屏障是CPU提供的一种同步机制，保证CPU执行到内存屏障之前的指令都执行完成，再执行内存屏障之后的指令。C++原子类的内存序就是在保证可见性。</li>
</ol>
<span id="more"></span>

<h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><h4 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h4><p>C语言中的多线程编程一般使用pthread库, pthread（POSIX线程）库是用于在类Unix系统中实现多线程编程的API实现了posix标准的线程接口。</p>
<p>pthread支持的接口</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 线程创建，线程创建后立即执行，函数用void函数指针类型void *(*start_routine) (void *) 传参</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span></span>; <span class="comment">// 使当前线程退出，并返回一个状态。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span></span>;  <span class="comment">// 主线程等待子线程执行完毕。</span></span><br><span class="line"><span class="function"><span class="type">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="type">void</span>)</span></span>;  <span class="comment">// 返回当前线程的Id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化互斥锁, attr通常为NULL</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>; <span class="comment">// 申请互斥锁. 返回错误码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>; <span class="comment">// 释放互斥锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;  <span class="comment">// 销毁互斥锁, 互斥锁释放内存前需手动销毁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化条件变量, attr通常为NULL</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">// 阻塞当前线程，等待条件变量通知。线程唤醒后立即尝试申请锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;  <span class="comment">// 唤醒一个等待条件变量的线程。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;  <span class="comment">// 唤醒所有等待条件变量的线程。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;  <span class="comment">// 销毁条件变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化线程属性对象</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">// 设置线程PTHREAD_CREATE_DETACHED（分离线程）或 PTHREAD_CREATE_JOINABLE（可等待的线程）。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span></span>;  <span class="comment">// 销毁线程等待对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置cpu亲和力, 将线程绑定到指定的 CPU 核心上。</span></span><br><span class="line"><span class="comment">// cpu_set_t 是一个位图类型，每一位表示一个 CPU 核心。可以用CPU_SET(cpu, cpuset)将指定的 CPU 核心（cpu）添加到 cpuset 中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setaffinity_np</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">size_t</span> cpusetsize, <span class="type">const</span> <span class="type">cpu_set_t</span> *cpuset)</span></span>;</span><br><span class="line"><span class="comment">// 获取cpu亲和性</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_getaffinity_np</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">size_t</span> cpusetsize, <span class="type">cpu_set_t</span> *cpuset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程的调度策略和优先级</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setschedparam</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">int</span> policy, <span class="type">const</span> <span class="keyword">struct</span> sched_param *param)</span></span>;</span><br><span class="line"><span class="comment">// 获取线程的调度策略和优先级。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_getschedparam</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">int</span> *policy, <span class="keyword">struct</span> sched_param *param)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);</code> 需要传入锁, 表示条件变量等待函数需要先获取锁, 发现条件不满足, 才释放锁进入等待状态。这说明条件变量的设计目的是减少申请锁的冲突, 将不符合条件的线程进入等待，而不是让所有线程都竞争锁。（事实上锁竞争的线程也是忙等待，一般线程没有抢到锁会先执行一段时间的自旋等待，如果还没有抢到锁则进入锁等待队列, 释放锁的线程会唤醒处于锁等待状态的线程）</p>
<p>如果要单纯的等待-通知, 不用使用锁，可以使用信号</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/signalfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sigset_t</span> mask;</span><br><span class="line"><span class="built_in">sigaddset</span>(&amp;mask, SIGUSR1);</span><br><span class="line"><span class="type">int</span> sfd = <span class="built_in">signalfd</span>(<span class="number">-1</span>, &amp;mask, SFD_NONBLOCK);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程等待信号</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">signalfd_siginfo</span> info;</span><br><span class="line"><span class="built_in">read</span>(sfd, &amp;info, <span class="built_in">sizeof</span>(info)); <span class="comment">// 阻塞直到收到信号</span></span><br></pre></td></tr></table></figure>

<p>pthread利用锁、条件变量和数组模拟的环形缓冲区实现生产者消费者模型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 10  <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义缓冲区和相关变量</span></span><br><span class="line"><span class="type">int</span> buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">int</span> in = <span class="number">0</span>;  <span class="comment">// 指向缓冲区的生产者插入位置</span></span><br><span class="line"><span class="type">int</span> out = <span class="number">0</span>; <span class="comment">// 指向缓冲区的消费者取出位置</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;  <span class="comment">// 互斥锁</span></span><br><span class="line"><span class="type">pthread_cond_t</span> empty;   <span class="comment">// 条件变量，表示缓冲区非空</span></span><br><span class="line"><span class="type">pthread_cond_t</span> full;    <span class="comment">// 条件变量，表示缓冲区非满</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">producer</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        item = <span class="built_in">rand</span>() % <span class="number">100</span>;  <span class="comment">// 生成一个随机项</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);  <span class="comment">// 加锁，访问共享缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果缓冲区满了，等待消费者消费</span></span><br><span class="line">        <span class="keyword">while</span> ((in + <span class="number">1</span>) % BUFFER_SIZE == out) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;empty, &amp;mutex);  <span class="comment">// 等待缓冲区有空位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将项放入缓冲区</span></span><br><span class="line">        buffer[in] = item;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Producer produced: %d\n&quot;</span>, item);</span><br><span class="line">        in = (in + <span class="number">1</span>) % BUFFER_SIZE;  <span class="comment">// 更新生产者插入位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒消费者线程</span></span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;full);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);  <span class="comment">// 解锁</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);  <span class="comment">// 模拟生产的时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">consumer</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);  <span class="comment">// 加锁，访问共享缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果缓冲区为空，等待生产者生产</span></span><br><span class="line">        <span class="keyword">while</span> (in == out) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;full, &amp;mutex);  <span class="comment">// 等待缓冲区有数据</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从缓冲区取出项</span></span><br><span class="line">        item = buffer[out];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Consumer consumed: %d\n&quot;</span>, item);</span><br><span class="line">        out = (out + <span class="number">1</span>) % BUFFER_SIZE;  <span class="comment">// 更新消费者取出位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒生产者线程</span></span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;empty);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);  <span class="comment">// 解锁</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);  <span class="comment">// 模拟消费的时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> producer_thread, consumer_thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁和条件变量</span></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;empty, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;full, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建生产者和消费者线程</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;producer_thread, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;consumer_thread, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(producer_thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(consumer_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁和条件变量</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;empty);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;full);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Producer produced: <span class="number">83</span></span><br><span class="line">Consumer consumed: <span class="number">83</span></span><br><span class="line">Producer produced: <span class="number">86</span></span><br><span class="line">Consumer consumed: <span class="number">86</span></span><br><span class="line">Producer produced: <span class="number">77</span></span><br><span class="line">Producer produced: <span class="number">15</span></span><br><span class="line">Consumer consumed: <span class="number">77</span></span><br><span class="line">Producer produced: <span class="number">93</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>线程cpu绑核，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_function</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> mask;</span><br><span class="line">    <span class="type">pthread_t</span> thread = <span class="built_in">pthread_self</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程的 CPU 亲和性</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">pthread_getaffinity_np</span>(thread, <span class="built_in">sizeof</span>(<span class="type">cpu_set_t</span>), &amp;mask);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pthread_getaffinity_np&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出当前线程可以运行的 CPU 核心</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CPU_SETSIZE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CPU_ISSET</span>(i, &amp;mask)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Thread can run on CPU core: %d\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpuset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;thread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程绑定到 CPU 核心 0 和 1</span></span><br><span class="line">    <span class="built_in">CPU_ZERO</span>(&amp;cpuset);</span><br><span class="line">    <span class="built_in">CPU_SET</span>(<span class="number">0</span>, &amp;cpuset);  <span class="comment">// 允许线程在 CPU 核心 0 上运行</span></span><br><span class="line">    <span class="built_in">CPU_SET</span>(<span class="number">1</span>, &amp;cpuset);  <span class="comment">// 允许线程在 CPU 核心 1 上运行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程的 CPU 亲和性</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">pthread_setaffinity_np</span>(thread, <span class="built_in">sizeof</span>(<span class="type">cpu_set_t</span>), &amp;cpuset);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pthread_setaffinity_np&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Thread can run on CPU core: <span class="number">0</span></span><br><span class="line">Thread can run on CPU core: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>线程调度策略, </p>
<ol>
<li>SCHED_FIFO：先来先服务(First-In-First-Out)实时调度, </li>
<li>SCHED_RR：轮转调度（Round-Robin）实时调度，</li>
<li>SCHED_OTHER默认的操作系统决定调度线程<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_function</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread running\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sched_param</span> param;</span><br><span class="line">    <span class="type">int</span> policy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;thread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置调度策略为 SCHED_FIFO，并设置优先级为 10</span></span><br><span class="line">    param.sched_priority = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">pthread_setschedparam</span>(thread, SCHED_FIFO, &amp;param);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并输出当前线程的调度策略和优先级</span></span><br><span class="line">    <span class="built_in">pthread_getschedparam</span>(thread, &amp;policy, &amp;param);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread policy: %d, Priority: %d\n&quot;</span>, policy, param.sched_priority);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(thread, <span class="literal">NULL</span>);  <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Thread policy: <span class="number">1</span>, Priority: <span class="number">10</span></span><br><span class="line">Thread running</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p>编程语言的赋值一般是原子的，但算术操作不是原子的（需要访存、操作、写回三个操作）。c语言可以直接使用gcc提供的内建原子操作函数, 原子函数在操作函数会加内存屏障，保证常见操作的原子性、可见性。</p>
<ol>
<li>__sync_fetch_and_add, 原子地将一个值加到目标变量，返回旧值。</li>
<li>__sync_fetch_and_sub：原子地目标变量减去一个值，返回旧值。</li>
<li>__sync_lock_test_and_set：原子地设置一个值，返回旧值。</li>
</ol>
<p>原子函数的实现原理</p>
<ol>
<li>默认包含一个 ​​完整的顺序一致性屏障（Full Memory Barrier）​​，确保操作前的所有内存访问（读&#x2F;写）在原子操作前完成:操作后的所有内存访问（读&#x2F;写）在原子操作后开始。也就是是原子操作时可以读到最新的旧值, 原子操作后设置的新值其他线程可见</li>
<li>硬件支持，在 x86&#x2F;x64 架构中，原子操作通常有对应的硬件指令，例如 xchg（Exchange）指令（带 lock 前缀），确保操作的原子性。</li>
</ol>
<p>虽然赋值操作是原子的，但C和C++没有java volatile 关键字保证可见性, 因此赋值操作还是要用原子操作__sync_lock_test_and_set。java的volatile关键字可以保证赋值操作的可见性，无须加锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;  <span class="comment">// 用于计数的共享变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">increment</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        __sync_fetch_and_add(&amp;counter, <span class="number">1</span>);  <span class="comment">// 原子地增加 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 10 个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>, increment, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Counter value: %d\n&quot;</span>, counter);  <span class="comment">// 输出最终值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出10000</span></span><br></pre></td></tr></table></figure>

<p>GCC 4.7+ 引入了更灵活的 __atomic 系列函数，允许显式控制内存顺序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __atomic 版本（可指定内存顺序）</span></span><br><span class="line">type __atomic_exchange_n(type *ptr, type value, <span class="type">int</span> memorder);</span><br></pre></td></tr></table></figure>

<p>__thread, 是gcc提供的线程局部存储，每个线程操作自己的变量副本，互不影响。</p>
<ol>
<li>只能用于全局和静态变量</li>
<li>​静态初始化​​：变量必须在编译时初始化，且只能为 ​​简单数据类型​​（如 int、float、指针），不支持动态初始化或复杂类型（如结构体、动态数组）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __thread <span class="type">int</span> thread_local_var;  <span class="comment">// 必须为 static 或全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread <span class="type">unsigned</span> <span class="type">long</span> task_count;  <span class="comment">// 线程私有计数器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    task_count++;  <span class="comment">// 无锁操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><h4 id="C-11的并发类"><a href="#C-11的并发类" class="headerlink" title="C++11的并发类"></a>C++11的并发类</h4><p>C++11 提供的并发类主要包括</p>
<ol>
<li>std::thread线程, 创建立即执行, 提供join(), detach(), get_id()等方。头文件<code>#include &lt;thread&gt;</code></li>
<li>std::mutex互斥锁, 提供lock(), unlock(), try_lock(), <code>std::lock_guard&lt;std::mutex&gt;</code>, <code>std::unique_lock&lt;std::mutex&gt;</code>。头文件<code>#include &lt;mutex&gt;</code></li>
<li>std::condition_variable 条件变量，提供wait(), notify_one(), notify_all()等方法, 头文件<code>#include &lt;condition_variable&gt;</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::thread(Func&amp;&amp; f, Args&amp;&amp;... args)：创建一个线程并开始执行传入的函数 构造函数</span></span><br><span class="line"><span class="comment">// std::thread::join()：等待线程执行完毕。</span></span><br><span class="line"><span class="comment">// std::thread::detach()：将线程与主线程分离。</span></span><br><span class="line"><span class="comment">// std::thread::get_id()， 返回线程id</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_thread_id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::thread::id this_id = std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; this_id &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(print_thread_id)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Main thread ID: <span class="number">140509241898816</span></span><br><span class="line">Thread ID: <span class="number">140509241894656</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>线程同步</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::mutex::lock()</span></span><br><span class="line"><span class="comment">// std::mutex::unlock()</span></span><br><span class="line"><span class="comment">// std::mutex::try_lock()：尝试锁定互斥量</span></span><br><span class="line"><span class="comment">// std::lock_guard&lt;std::mutex&gt; guard(mtx); 自动加锁和释放锁</span></span><br><span class="line"><span class="comment">// std::unique_lock&lt;std::mutex&gt; lck(mtx); 可手动释放锁，若未手动释放则自动释放锁</span></span><br><span class="line"><span class="comment">// std::condition_variable::wait() 阻塞当前线程</span></span><br><span class="line"><span class="comment">// std::condition_variable::notify_one()：通知一个等待的线程。</span></span><br><span class="line"><span class="comment">// std::condition_variable::notify_all()：通知所有等待的线程。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;              <span class="comment">// 共享缓冲区</span></span><br><span class="line">std::mutex mtx;                      <span class="comment">// 互斥锁，保护缓冲区</span></span><br><span class="line">std::condition_variable cv;          <span class="comment">// 条件变量，通知生产者或消费者</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_BUFFER_SIZE = <span class="number">5</span>;       <span class="comment">// 缓冲区最大大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));  <span class="comment">// 模拟生产耗时</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果缓冲区已满，生产者等待</span></span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>() &lt; MAX_BUFFER_SIZE; &#125;);</span><br><span class="line">        buffer.<span class="built_in">push</span>(i);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">150</span>));  <span class="comment">// 模拟消费耗时</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果缓冲区为空，消费者等待</span></span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> !buffer.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">        <span class="type">int</span> item = buffer.<span class="built_in">front</span>();</span><br><span class="line">        buffer.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建生产者和消费者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">producer_thread</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer_thread</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程执行完毕</span></span><br><span class="line">    producer_thread.<span class="built_in">join</span>();</span><br><span class="line">    consumer_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Produced: <span class="number">0</span></span><br><span class="line">Consumed: <span class="number">0</span></span><br><span class="line">Produced: <span class="number">1</span></span><br><span class="line">Consumed: <span class="number">1</span></span><br><span class="line">Produced: <span class="number">2</span></span><br><span class="line">Produced: <span class="number">3</span></span><br><span class="line">Consumed: <span class="number">2</span></span><br><span class="line">Produced: <span class="number">4</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>异步任务</p>
<ol>
<li>std::promise和std::future。允诺（Promise）对象，用于在线程中存储一个值或异常，供其他线程通过 future 获取。未来（Future）对象，用于从 promise 中异步获取结果。提供阻塞或非阻塞方式访问数据。头文件<code>#include &lt;future&gt;</code></li>
<li>std::future和std::async, std::aync 直接传入函数, 返回一个future。该future可以通过get()获取函数返回值。std::async会自动创建异步执行任务</li>
</ol>
<p>std::future和std::promise联用，用于线程间传递数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    p.<span class="built_in">set_value</span>(<span class="number">42</span>);  <span class="comment">// 设置 promise 的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 promise 和 future 对象</span></span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; p;   <span class="comment">// 可以存储一个变量</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f = p.<span class="built_in">get_future</span>();  <span class="comment">// 可以从promise中获取存储的变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(set_value, std::ref(p))</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Doing some work in the main thread...\n&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 promise 设置的结果，调用 get() 会阻塞直到线程设置值</span></span><br><span class="line">    <span class="type">int</span> result = f.<span class="built_in">get</span>();  <span class="comment">// 阻塞，直到获取结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The result from promise is: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Doing some work in the main thread...</span><br><span class="line">The result from promise is: <span class="number">42</span></span><br></pre></td></tr></table></figure>

<p>std::future和std::async联用，获取异步任务执行完成后的返回值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate_square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::async 启动异步任务，返回一个 std::future 对象</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(std::launch::async, calculate_square, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Doing other work in main thread...\n&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取异步任务的结果，调用 get() 会阻塞，直到结果计算完成</span></span><br><span class="line">    <span class="type">int</span> square = result.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The square of 5 is: &quot;</span> &lt;&lt; square &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在并发处理上，C++20 提供了协程和std::jthread。​jthread​​兼容 std::thread 接口​​和方法，提供了​自动 Join​​：在析构时自动调用 join()，避免未回收线程导致程序终止（传统 std::thread 析构时若未 join() 或 detach() 会触发 std::terminate）。</p>
<p>C++20 还引入了std::latch, 用于等待线程完成(这种特性加入的也太晚了)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;latch&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::latch <span class="title">completion_latch</span><span class="params">(<span class="number">3</span>)</span></span>;  <span class="comment">// 初始计数器为3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> worker = [&amp;](<span class="type">int</span> id) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; started\n&quot;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        completion_latch.<span class="built_in">count_down</span>();  <span class="comment">// 完成任务，计数器减1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::jthread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(worker, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    completion_latch.<span class="built_in">wait</span>();  <span class="comment">// 主线程等待所有子线程完成</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;All workers completed!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++17 中引入的 std::scoped_lock, 可以一次性锁住多个互斥量，避免死锁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 锁定 mtx</span></span><br><span class="line">    <span class="comment">// 操作共享资源...</span></span><br><span class="line">&#125; <span class="comment">// 自动解锁 mtx</span></span><br><span class="line"></span><br><span class="line">std::mutex mtx1, mtx2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx1, mtx2)</span></span>; <span class="comment">// 同时锁定 mtx1 和 mtx2</span></span><br><span class="line">    <span class="comment">// 操作共享资源...</span></span><br><span class="line">&#125; <span class="comment">// 自动解锁 mtx2 和 mtx1（逆序）</span></span><br></pre></td></tr></table></figure>

<h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><p><code>std::unique_ptr&lt;T&gt;</code>，创建对象时使用，具有对象的所有权。</p>
<p><code>std::shared_ptr&lt;T&gt;</code>，共享所有权, 使用引用计数维护对象生命周期, 在所有权不明确或对象析构时刻不明确时使用, 尽量使用unique_ptr</p>
<p><code>std::weak_ptr&lt;T&gt;</code>，弱指针，不维护对象生命周期。当对象处于观察者状态时使用，可通过尝试lock()函数判断对象是否存在，如果存在则访问。当对象A 持有对象B的shared_ptr，同时B又想持有对象A的shared_ptr时，为了避免循环引用，B应当持有A的weak_ptr 。</p>
<h4 id="C-线程局部变量"><a href="#C-线程局部变量" class="headerlink" title="C++线程局部变量"></a>C++线程局部变量</h4><p>thread_local 是 C++11 引入的关键字, 相比__thread, 前者只能修饰​​简单数据类型​​（如 int、float、指针），thread_local可用于局部变量、全局变量、类成员变量等。性能上两者均接近普通全局变量，无显著差异。</p>
<p>线程局部变量没有数据竞争，其他线程对变量的修改也不会影响当前线程的变量值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> thread_local_var = <span class="number">0</span>;  <span class="comment">// 声明线程局部变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_function</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    thread_local_var++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld: thread_local_var = %d\n&quot;</span>, (<span class="type">long</span>)arg, thread_local_var);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建多个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>, thread_function, (<span class="type">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Thread <span class="number">0</span>: thread_local_var = <span class="number">1</span></span><br><span class="line">Thread <span class="number">1</span>: thread_local_var = <span class="number">1</span></span><br><span class="line">Thread <span class="number">2</span>: thread_local_var = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> MyClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; <span class="comment">/* 构造函数 */</span> &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; <span class="comment">/* 析构函数 */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">thread_local</span> MyClass obj;  <span class="comment">// 合法，每个线程独立构造/析构</span></span><br></pre></td></tr></table></figure>

<h4 id="C-11-的原子类"><a href="#C-11-的原子类" class="headerlink" title="C++11 的原子类"></a>C++11 的原子类</h4><p>std::atomic提供了线程安全的原子操作。std::atomic 是一个模板类，支持不同的数据类型（如整数、指针）。常用的方法</p>
<ol>
<li>load() 读取原子变量的值。</li>
<li>store(x) 写入值到原子变量</li>
<li>fetch_add(x) 和 fetch_sub(x) 原子加减法操作，返回旧值</li>
<li>exchange(x) 将原子对象的值替换为给定值，并返回旧值</li>
<li>compare_exchange_weak(expected, desired) 和 compare_exchange_strong(expected, desired) 执行原子比较并交换（CAS，Compare and Swap）操作。expected是当前期望的值，desired是期望修改后的值。返回true表示更新成功，false表示未更新</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> expected = counter.<span class="built_in">load</span>();</span><br><span class="line">        <span class="keyword">while</span> (!counter.<span class="built_in">compare_exchange_strong</span>(expected, expected + <span class="number">1</span>)) &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">yield</span>();  <span class="comment">// 如果失败，线程主动让出 CPU</span></span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; incremented counter to &quot;</span> &lt;&lt; counter.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter value: &quot;</span> &lt;&lt; counter.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Thread <span class="number">1</span> incremented counter to <span class="number">2</span></span><br><span class="line">Thread <span class="number">1</span> incremented counter to <span class="number">3</span></span><br><span class="line">Thread <span class="number">1</span> incremented counter to <span class="number">4</span></span><br><span class="line">Thread <span class="number">1</span> incremented counter to <span class="number">5</span></span><br><span class="line">Thread <span class="number">1</span> incremented counter to <span class="number">6</span></span><br><span class="line">Thread <span class="number">1</span> incremented counter to <span class="number">7</span></span><br></pre></td></tr></table></figure>

<h4 id="内存序和可见性"><a href="#内存序和可见性" class="headerlink" title="内存序和可见性"></a>内存序和可见性</h4><p>内存序是为了保证多线程在<strong>多核CPU的可见性</strong>，是一种内存屏障。作用和JAVA的volatile类似。</p>
<ol>
<li>memory_order_seq_cst 是默认的内存顺序，相当于JAVA的volatile，对原子类的修改操作会立刻刷到内存。</li>
<li>memory_order_acquire和load连用，memory_order_release和store连用。这个保证，如果某线程执行了store+memory_order_release的操作，在其他线程执行load+memory_order_acquire时，前面的store操作是可见的</li>
</ol>
<p>由于C++没有类似java 的volatile关键字（C++的volatile 只是避免编译层的优化的重排序, 只有底层比较hack的代码告知编译期不要优化我hack的代码时才会用到, C++ 编程很少遇到），因此一旦涉及多线程共享变量，要么加锁，要么上原子类（一般不会手动使用内存屏障）。</p>
<ol>
<li><p>memory_order_relaxed：不保证任何顺序，只提供原子性，一般不会使用</p>
</li>
<li><p>memory_order_consume：保证在该原子操作之后的所有依赖操作的顺序, 这个类似memory_order_acquire, 比 memory_order_acquire 更轻量，但适用范围更窄, 只保证依赖原子类的顺序。<br>以下常用</p>
</li>
<li><p>memory_order_acquire：保证acquire之后的操作实际也在该操作后执行,不会重排序到操作之前，常修饰load操作</p>
</li>
<li><p>memory_order_release：保证release之前的所有操作在该操作前执行,不会重排序到操作之后，常修饰store操作<br>store+memory_order_release 和load+memory_order_acquire 保证写之后读之前是有序的。写-读是一个pair。release-acquire之间不是原子类的操作, 也会保证有序性。</p>
</li>
<li><p>memory_order_acq_rel：同时具备获取和释放语义,用来修饰load+store操作,如fetch_add</p>
</li>
<li><p>memory_order_seq_cst：保证严格的顺序一致性，即原子类变量多线程并发执行和单线程循环执行顺序完全一致, 原子类默认内存序</p>
</li>
</ol>
<p>内存序本身不提供“线程必须等待其他线程写了数据，才可以读”这样的同步语义，需要使用一个load循环，直到load数据。它能保证的是，只要某个线程store了数据，其他线程立刻可以load到。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data.<span class="built_in">store</span>(<span class="number">42</span>, std::memory_order_relaxed);  <span class="comment">// 写入数据</span></span><br><span class="line">    ready.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);  <span class="comment">// 通知消费者</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!ready.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;  <span class="comment">// 等待生产者通知</span></span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>();  <span class="comment">// cpu从当前线程切走, 但线程不会进入等待队列，后面还可能被cpu调度</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Consumer read data: &quot;</span> &lt;&lt; data.<span class="built_in">load</span>(std::memory_order_relaxed) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-的lambda表达式和函数类型"><a href="#C-的lambda表达式和函数类型" class="headerlink" title="C++的lambda表达式和函数类型"></a>C++的lambda表达式和函数类型</h4><p>Lambda 是一种匿名闭包对象，​​每个 Lambda 表达式的类型都是唯一的闭包类型​​，无法显式声明，但可以通过 auto 或 decltype 推导。</p>
<p><code>std::function&lt;ReturnType(Args...)&gt;</code>可用来存储可调用对象，如函数对象，lambda表达式等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加不同类型的可调用对象</span></span><br><span class="line">    tasks.<span class="built_in">push_back</span>([]&#123; std::cout &lt;&lt; <span class="string">&quot;Task 1&quot;</span>; &#125;);   <span class="comment">// Lambda</span></span><br><span class="line">    tasks.<span class="built_in">push_back</span>(&amp;some_function);                 <span class="comment">// 函数指针</span></span><br><span class="line">    tasks.<span class="built_in">push_back</span>(Functor&#123;&#125;);                      <span class="comment">// 仿函数, 实现operator()的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; task : tasks) &#123;</span><br><span class="line">        <span class="built_in">task</span>();  <span class="comment">// 统一调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>C++异常处理基于三个关键字：try、catch、throw。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">double</span> result = <span class="built_in">divide</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::runtime_error&amp; e) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="built_in">catch</span> (...) &#123; <span class="comment">// 捕获所有异常</span></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Unknown error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常处理的缺陷</p>
<ol>
<li><p>栈展开Stack Unwinding，抛出异常时，<strong>编译器需生成回溯调用栈，逐个退出函数作用域的逻辑</strong>，调用局部对象的析构函数，直到找到匹配的 catch 块。</p>
</li>
<li><p>编译器需为每个 try 块生成额外的元数据（如异常表），增加二进制文件体积。</p>
</li>
<li><p>异常改变了代码的显式执行路径，错误处理逻辑分散在 catch 块中，而非就近处理。</p>
</li>
<li><p>C++推荐使用错误码来进行错误处理，无额外性能开销；错误处理需要保证资源释放</p>
</li>
<li><p>如果调用的函数可能抛出异常，那么调用者需要捕获，防止程序崩溃。</p>
</li>
</ol>
<p>C++ noexcept关键字指定函数不抛异常，编译器可能为 noexcept 函数生成更精简的代码（无需准备栈展开逻辑）。析构函数和移动构造&#x2F;赋值函数默认是noexcept函数。若 noexcept 函数意外抛异常，程序直接终止。</p>
<h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><h4 id="JAVA-并发类"><a href="#JAVA-并发类" class="headerlink" title="JAVA 并发类"></a>JAVA 并发类</h4><p>Thread类，继承 Thread 类并重写其 run() 方法，实现多线程。JAVA原生支持, 不需要import 库</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread is running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 Runnable 接口并重写 run() 方法, 实现多线程。不需要import 库</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Runnable thread is running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Callable和FutureTask接口，与 Runnable 类似，但可以返回结果和抛出异常。需要import java.util.concurrent.Callable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;  <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Result: &quot;</span> + futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池类, Executor 和 ExecutorService。C++标准库里没有线程池类, 需要引用第三方库。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        executor.execute(() -&gt; System.out.println(<span class="string">&quot;Task 1&quot;</span>));</span><br><span class="line">        executor.execute(() -&gt; System.out.println(<span class="string">&quot;Task 2&quot;</span>));</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Task <span class="number">1</span></span><br><span class="line">Task <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>CountDownLatch, latch计数器，用于等待其他线程完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; finished task&quot;</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line"></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;All tasks finished&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal，线程内部变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            threadLocal.set(threadLocal.get() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; value: &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized 锁, Java 内置的关键字，可用于方法或代码块, 用于线程同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步方法,整个方法需要互斥执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is executing&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同步对象，整个this对象需要互斥执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is executing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) counter.increment();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) counter.increment();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + counter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>java提供volatile关键字保证变量的可见性, volatile关键字实现<strong>如果某线程只对变量进行赋值或读取操作，操作时不需要加锁</strong>。对于volatile使用场景, C++一般要使用原子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopTask</span><span class="params">()</span> &#123;</span><br><span class="line">        running = <span class="literal">false</span>; <span class="comment">// 设置为线程终止标志, 其他线程修改后立即可见, 不需要加锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="comment">// 执行任务...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;                    <span class="comment">// 第一次检查无锁, 使用volatile保证第一次检查时的可见性</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;            <span class="comment">// 第二次检查</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();    <span class="comment">// volatile禁止重排序</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="线程安全数据结构"><a href="#线程安全数据结构" class="headerlink" title="线程安全数据结构"></a>线程安全数据结构</h4><p>JAVA提供了一些并发安全的数据结构，位于java.util.concurrent包中。C++标准库不提供线程安全结构, 需要第三方库。</p>
<ol>
<li>ConcurrentHashMap<br>线程安全的哈希表实现，支持高效的并发读写。它将内部数据分割为多个段，每个段一个锁，可以减少锁竞争。</li>
<li>CopyOnWriteArrayList<br>线程安全的 List 实现</li>
<li>BlockingQueue<br>线程安全的队列接口，通常用于生产者-消费者模型。</li>
</ol>
<p>java.util中的HashMap，ArrayList，LinkedList等都是非并发安全的</p>
<h4 id="JAVA多线程和虚拟机"><a href="#JAVA多线程和虚拟机" class="headerlink" title="JAVA多线程和虚拟机"></a>JAVA多线程和虚拟机</h4><p>相比C&#x2F;C++ 多线程通过pthread直接在linux操作系统中起进程，JAVA的多线程需要经过JAVA虚拟机这一层。</p>
<p>java虚拟机维护了JavaThread结构，JVM是C++实现的。所以JavaThread是C++定义的类。JavaThread维护了线程的状态，一个指针指向java.lang.Thread创建的对象(oop)，另一个指针指向对应的操作系统创建的OSThread</p>
<p>java线程模型的实现取决于jvm虚拟机，只要jvm愿意，可以选择类似go使用协程来实现线程。但以市场占有率最大的HotSpot虚拟机举例，一个java线程都是直接映射到操作系统的原生线程来实现的，所有的线程调度都是由操作系统完成的。</p>
<h4 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h4><p>volatile 关键字可以实现变量的可见性，但不提供原子性。 JAVA常见的原子类有 AtomicInteger、AtomicLong、AtomicBoolean、AtomicReference</p>
<p>.set()设置值, .get()获取值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">        atomicInt.set(<span class="number">10</span>);          <span class="comment">// 设置值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Value: &quot;</span> + atomicInt.get());        <span class="comment">// 获取值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Incremented: &quot;</span> + atomicInt.incrementAndGet());    <span class="comment">// 增加并获取</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> atomicInt.compareAndSet(<span class="number">15</span>, <span class="number">100</span>);          <span class="comment">// 比较并设置</span></span><br><span class="line">        System.out.println(<span class="string">&quot;CAS Success: &quot;</span> + success + <span class="string">&quot;, New Value: &quot;</span> + atomicInt.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Value: <span class="number">10</span></span><br><span class="line">Incremented: <span class="number">11</span></span><br><span class="line">CAS Success: <span class="literal">false</span>, New Value: <span class="number">11</span></span><br></pre></td></tr></table></figure>

<h4 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h4><p>java 的推荐使用异常处理，因此函数调用者需要通过try-catch-finally结构来捕获异常，防止程序崩溃。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;文件未找到: &quot;</span> + e.getMessage());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论是否发生异常，都会执行的代码（如资源释放）</span></span><br><span class="line">    <span class="keyword">if</span> (file != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java 函数可以加throws关键字，声明该方法可能抛出的 ​​受检异常（Checked Exceptions）​​，函数调用者必须处理异常，否则编译器报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException, IOException &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line">    <span class="comment">// 其他操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><h4 id="并发实现"><a href="#并发实现" class="headerlink" title="并发实现"></a>并发实现</h4><p>Golang 在语言层面使用协程实现并发，Go内置协程调度器，能自动在协程阻塞时将协程挂起。Golang的线程是无阻塞的，这意味Golang线程不能使用线程阻塞的系统调用。</p>
<p>GMP调度器, Go调度器基于 ​​G（Goroutine）、M（Machine）、P（Processor）​​ 三者的协作：</p>
<ol>
<li>​G（Goroutine）​​：轻量级协程，初始栈仅2KB（可动态扩缩），创建和切换成本极低。</li>
<li>​​M（Machine）​​：对应操作系统的线程（OS Thread），负责实际执行代码。</li>
<li>P（Processor）​​：逻辑处理器（调度器），管理一组本地队列（存储待运行的Goroutines）。P的数量默认等于CPU核心数（可通过GOMAXPROCS调整）。</li>
</ol>
<p>Goroutine 的创建与执行​</p>
<ol>
<li>每个协程（G）由Go运行时创建，并被分配到某个P的本地队列。</li>
<li>M需要绑定一个P才能执行Goroutines。</li>
<li>当P的本地队列为空时，会从全局队列或其他P的队列中​​窃取Goroutines​​（Work Stealing）。</li>
</ol>
<p>Golang的线程不会执行任何阻塞的系统调用, 当协程阻塞时，协程主动让出执行权，M会释放绑定的P，P转去服务其他M。系统调用完成后，G尝试获取新的P继续执行（若无可用P，则G进入全局队列）。</p>
<p>Go运行时有专门的​​网络轮询器（NetPoller）​​，将阻塞的G挂起，待IO就绪后唤醒，避免占用M。</p>
<p>一个Go程序可轻松创建数十万个Goroutines，而同等规模的OS线程会耗尽资源。M的数量由调度器动态管理（通常远少于Goroutines的数量），避免频繁创建&#x2F;销毁OS线程。</p>
<p>golang提供sync.WaitGroup等待协程运行完, 相当于latch。golang的无缓冲channel 可以用来实现阻塞-等待，有缓冲channel可以用来当任务队列。golang利用channel可以实现顺序性。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>, wg sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		item := rand.Intn(<span class="number">100</span>)</span><br><span class="line">		fmt.Println(<span class="string">&quot;Produced:&quot;</span>, item)</span><br><span class="line">		ch &lt;- item              <span class="comment">// 发送数据到channel</span></span><br><span class="line">		time.Sleep(time.Second) <span class="comment">// 模拟生产过程的延迟</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">int</span>, wg sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> item := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Consumed:&quot;</span>, item)</span><br><span class="line">		time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">// 模拟消费过程的延迟</span></span><br><span class="line">	&#125;</span><br><span class="line">	wg.Done()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="comment">// 创建一个缓冲区大小为 5 的channel</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动多个消费者</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> consumer(ch, wg)</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动一个生产者</span></span><br><span class="line">	<span class="keyword">go</span> producer(ch, wg)</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 主程序运行一段时间后退出</span></span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Produced: <span class="number">63</span></span><br><span class="line">Consumed: <span class="number">63</span></span><br><span class="line">Produced: <span class="number">47</span></span><br><span class="line">Consumed: <span class="number">47</span></span><br><span class="line">Produced: <span class="number">47</span></span><br><span class="line">Consumed: <span class="number">47</span></span><br><span class="line">Produced: <span class="number">99</span></span><br><span class="line">Consumed: <span class="number">99</span></span><br><span class="line">Produced: <span class="number">51</span></span><br><span class="line">Consumed: <span class="number">51</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>for range语句可以用来遍历channel的数组，直到channel被close。select 语句可以等待接收多个channel的数据，只要有一个channel写入了数据，select就会执行处理函数并退出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ch &lt;- <span class="number">42</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> msg := &lt;-ch:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Received:&quot;</span>, msg)</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second): <span class="comment">// 1秒后超时, select执行fmt.Println(&quot;Timeout!&quot;)</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;Timeout!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Received: <span class="number">42</span></span><br></pre></td></tr></table></figure>

<p>sync.Mutex，互斥锁。sync.RWMutex 读写锁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	counter <span class="type">int</span></span><br><span class="line">	mu      sync.Mutex <span class="comment">// 创建一个互斥锁</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加计数器的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">	counter++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动多个 goroutine 来增加计数器</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			increment()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待所有 goroutine 执行完毕</span></span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Final counter:&quot;</span>, counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	data   <span class="type">int</span></span><br><span class="line">	rwMutex sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	rwMutex.RLock()</span><br><span class="line">	<span class="keyword">defer</span> rwMutex.RUnlock()</span><br><span class="line">	<span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(value <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	rwMutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rwMutex.Unlock()</span><br><span class="line">	data = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动多个读 goroutine</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Reader %d: data = %d\n&quot;</span>, i, read())</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动一个写 goroutine</span></span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		write(<span class="number">42</span>)</span><br><span class="line">		fmt.Println(<span class="string">&quot;Writer: data updated&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	wg.Wait() <span class="comment">// 等待所有 goroutine 完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sync.Once 确保函数只执行一次，无论是多次调用还是多线程多次执行。可用来实现单例模式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 单例对象的字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    instance *Singleton</span><br><span class="line">    once     sync.Once</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        instance = &amp;Singleton&#123;</span><br><span class="line">            <span class="comment">// 初始化字段</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sync.Cond 条件变量，执行条件变量wait前需要持有锁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func</span> (b *Buffer) <span class="built_in">Produce</span>(item <span class="type">int</span>) &#123;</span><br><span class="line">	b.lock.<span class="built_in">Lock</span>()</span><br><span class="line">	defer b.lock.<span class="built_in">Unlock</span>()</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">for</span> <span class="title">len</span><span class="params">(b.data)</span> </span>== bufferSize &#123;</span><br><span class="line">		b.cond.<span class="built_in">Wait</span>()</span><br><span class="line">	&#125;</span><br><span class="line">	b.data = <span class="built_in">append</span>(b.data, item)</span><br><span class="line">	fmt.<span class="built_in">Println</span>(<span class="string">&quot;Produced:&quot;</span>, item)</span><br><span class="line"></span><br><span class="line">	b.cond.<span class="built_in">Signal</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="原子操作-1"><a href="#原子操作-1" class="headerlink" title="原子操作"></a>原子操作</h4><p>sync&#x2F;atomic 包提供了多种原子操作函数，</p>
<ol>
<li>AddInt32, <code>func AddInt32(addr *int32, delta int32) (new int32)</code>原子地将一个 int32 值加上一个指定的值。返回操作后的 ​​新值​​</li>
<li>CompareAndSwapInt32, <code>func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</code> 原子地比较并交换 int32 值。如果当前值等于预期值，则将其更改为新值。返回是否更改</li>
<li>LoadInt32, <code>func LoadInt32(addr *int32) (val int32)</code> 原子地读取一个 int32 值。</li>
<li>StoreInt32, <code>func StoreInt32(addr *int32, val int32)</code> 原子地写入一个 int32 值。</li>
</ol>
<p>例子, 无锁计数器</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter <span class="type">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">    atomic.AddInt64(&amp;counter, <span class="number">1</span>) <span class="comment">// 无需关心返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> atomic.LoadInt64(&amp;counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自旋锁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lock <span class="type">int32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acquireLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> !atomic.CompareAndSwapInt32(&amp;lock, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 自旋等待</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">releaseLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    atomic.StoreInt32(&amp;lock, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Context-协程生命周期管理"><a href="#Context-协程生命周期管理" class="headerlink" title="Context 协程生命周期管理"></a>Context 协程生命周期管理</h4><p>channel用来协程间通信，而Context主要用来管理协程的生命周期。</p>
<h4 id="异常处理-2"><a href="#异常处理-2" class="headerlink" title="异常处理"></a>异常处理</h4><p>panic用来抛出异常，recover用来捕获异常。<br>panic，</p>
<ol>
<li>运行时错误自动触发​​：例如数组越界、空指针解引用等。</li>
<li>​主动调用 <code>panic(v)</code>​​：开发者可手动抛出任意类型的值（通常是 <code>error</code> 或 <code>string</code>）。</li>
</ol>
<p>行为</p>
<ol>
<li>立即​​终止当前函数​​的执行。</li>
<li>​逐层向上回溯调用栈​​，执行每个函数的 <code>defer</code> 语句。</li>
<li>若未被 <code>recover</code> 捕获，最终​<strong>​程序崩溃​</strong>​并打印堆栈信息。</li>
</ol>
<p>recover：捕获异常​​</p>
<ol>
<li>​必须在 defer 函数中调用​​：recover 仅在 defer 上下文中生效。</li>
<li>​仅在发生 panic 后生效​​：若无 panic，recover 返回 nil。</li>
</ol>
<p>Go 的设计者觉得 <code>try/catch</code> 机制的使用太泛滥了，而且<strong>从底层向更高的层级抛异常太耗费资源</strong>。他们给 Go 设计的机制也可以“捕捉”异常，但是更轻量，并且只应该作为（处理错误的）最后的手段。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">riskyOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;something went wrong!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">safeOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">defer <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != nil &#123;</span><br><span class="line">			fmt.<span class="built_in">Println</span>(<span class="string">&quot;Recovered from panic:&quot;</span>, r)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">riskyOperation</span>() <span class="comment">// 触发 panic</span></span><br><span class="line">	fmt.<span class="built_in">Println</span>(<span class="string">&quot;This line will NOT be executed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="built_in">main</span>() &#123;</span><br><span class="line">	<span class="built_in">safeOperation</span>()</span><br><span class="line">	fmt.<span class="built_in">Println</span>(<span class="string">&quot;Program continues normally&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Recovered from panic: something went wrong!</span><br><span class="line">Program continues normally</span><br></pre></td></tr></table></figure>

<p>golang推荐使用error错误码来处理错误，产生错误的函数会返回两个变量，一个值和一个错误码；如果后者是 <code>nil</code> 就是成功，非 <code>nil</code> 就是发生了错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> value, err := pack1.Func1(param1); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Error %s in pack1.Func1 with parameter %v&quot;</span>, err.Error(), param1)</span><br><span class="line">	<span class="keyword">return</span>    <span class="comment">// or: return err</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// Process(value)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义错误码</span></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code    <span class="type">int</span></span><br><span class="line">    Message <span class="type">string</span></span><br><span class="line">    Details <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;code=%d, msg=%s&quot;</span>, e.Code, e.Message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProcessRequest</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyError&#123;</span><br><span class="line">        Code:    <span class="number">400</span>,</span><br><span class="line">        Message: <span class="string">&quot;invalid request&quot;</span>,</span><br><span class="line">        Details: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;field&quot;</span>: <span class="string">&quot;username&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><h4 id="多线程和多进程"><a href="#多线程和多进程" class="headerlink" title="多线程和多进程"></a>多线程和多进程</h4><p>Python 的 Cpython有一个全局解释器锁（GIL）。这意味着在任何时刻，只有一个线程可以执行 Python 字节码。这简化了python的多线程管理，GIL​​单条字节码指令是原子操作​​。向x &#x3D; 42, shared_list.append(item) 是线程安全的。但这让Python的多线程只能利用到单核。</p>
<p>虽然Python可以使用多进程，但多进程之间是独立的地址空间，难以访问共享变量，使用比较难受。因此threading 多线程模块是python常用的并发模块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_numbers</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程</span></span><br><span class="line">thread1 = threading.Thread(target=print_numbers)</span><br><span class="line">thread2 = threading.Thread(target=print_numbers)</span><br><span class="line"><span class="comment"># 创建进程</span></span><br><span class="line">process1 = multiprocessing.Process(target=print_numbers)</span><br><span class="line">process2 = multiprocessing.Process(target=print_numbers)</span><br><span class="line"></span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line">process1.start()</span><br><span class="line">process2.start()</span><br><span class="line"></span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line">process1.join()</span><br><span class="line">process2.join()</span><br></pre></td></tr></table></figure>

<p>线程锁和条件变量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.value = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">increment</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="variable language_">self</span>.lock:  <span class="comment"># 自动加锁/解锁</span></span><br><span class="line">            <span class="variable language_">self</span>.value += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cond = threading.Condition()</span><br><span class="line">shared_data = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>():</span><br><span class="line">    <span class="keyword">with</span> cond:  <span class="comment"># 自动加锁</span></span><br><span class="line">        shared_data.append(<span class="number">42</span>)</span><br><span class="line">        cond.notify()  <span class="comment"># 通知消费者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>():</span><br><span class="line">    <span class="keyword">with</span> cond:  <span class="comment"># 自动加锁</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> shared_data:</span><br><span class="line">            cond.wait()  <span class="comment"># 自动释放锁并等待，唤醒后重新加锁</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Received:&quot;</span>, shared_data.pop())</span><br></pre></td></tr></table></figure>


<p>线程池，concurrent.futures.ThreadPoolExecutor</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_square</span>(<span class="params">number</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Square of <span class="subst">&#123;number&#125;</span> is <span class="subst">&#123;number * number&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个线程池，最多允许 5 个线程同时执行</span></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="comment"># 提交任务给线程池</span></span><br><span class="line">    executor.submit(print_square, <span class="number">2</span>)</span><br><span class="line">    executor.submit(print_square, <span class="number">3</span>)</span><br><span class="line">    executor.submit(print_square, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h4 id="生成器和协程"><a href="#生成器和协程" class="headerlink" title="生成器和协程"></a>生成器和协程</h4><p>生成器。python生成器是一种无栈协程，可以实现手动切换执行流。普通函数可以 yield 语句返回生成器，普通函数执行到yield后会转向执行接收yield返回值的函数，当再执行next()，线程回到原先的函数继续执行。</p>
<p>使用next() 和 send() 方法可以控制生成器的执行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">simple_gen</span>():</span><br><span class="line">    value = <span class="keyword">yield</span> <span class="string">&quot;Ready&quot;</span>  <span class="comment"># 初始返回值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Received:&quot;</span>, value)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;End&quot;</span></span><br><span class="line"></span><br><span class="line">gen = simple_gen()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 第一次执行生成器，收到&quot;Ready&quot;</span></span><br><span class="line"><span class="built_in">print</span>(gen.send(<span class="number">42</span>))  <span class="comment"># 执行流再次切换到simple_gen，simple_gen执行到&quot;End</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Ready</span><br><span class="line">(<span class="string">&#x27;Received:&#x27;</span>, <span class="number">42</span>)</span><br><span class="line">End</span><br></pre></td></tr></table></figure>

<p>asyncio 是python3提供的无栈协程模块，内部实现了事件循环。</p>
<ol>
<li>async 用于定义协程函数，await 用于暂停协程并等待另一个协程完成。async定义的协程函数中不能调用可能导致线程阻塞或者等待的函数，包括阻塞读写、线程锁、sleep等。</li>
<li>await 后面跟的是io耗时的操作，表示把线程从当前协程切换走；同时await会注册事件通知，当耗时的操作执行完时，调度器会回来再执行当前协程</li>
</ol>
<p>await 同时维护了执行的先后顺序，对于async函数A await aysnc函数B，则必须等待B执行完函数A才会继续执行。这个执行逻辑避免了回调地狱，即<strong>对于回调函数链路A-&gt;B-&gt;C，可以直接在A里面写await B, B里面写 await C</strong>，代码更加简洁易懂</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task_1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Task 1 starts&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Task 1 ends&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task_2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Task 2 starts&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> task_1()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Task 2 ends&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并发执行两个任务</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(task_1(), task_2())  <span class="comment"># 需等待所有task执行完</span></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Task <span class="number">1</span> starts</span><br><span class="line">Task <span class="number">2</span> starts</span><br><span class="line">Task <span class="number">1</span> starts</span><br><span class="line">Task <span class="number">1</span> ends</span><br><span class="line">Task <span class="number">1</span> ends</span><br><span class="line">Task <span class="number">2</span> ends</span><br></pre></td></tr></table></figure></div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/language/" rel="tag">language</a></li></ul></div><div class="post-nav"><a class="pre" href="/2024/12/20/%E7%B3%BB%E7%BB%9F%E2%80%94%E5%B9%B6%E5%8F%91%E7%AE%80%E8%B0%88/">系统——并发简谈</a><a class="next" href="/2024/12/10/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(3)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">编程语言(3)—数据结构和算法</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://larrystd.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>To be a better man.</p><a class="info-icon" href="https://twitter.com/username" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:admin@domain.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/application/">application</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/compute/">compute</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hello/">hello</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/language/">language</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/storage/">storage</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/hello/" style="font-size: 15px;">hello</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/brpc/" style="font-size: 15px;">brpc</a> <a href="/tags/storage/" style="font-size: 15px;">storage</a> <a href="/tags/leveldb/" style="font-size: 15px;">leveldb</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/application/" style="font-size: 15px;">application</a> <a href="/tags/base/" style="font-size: 15px;">base</a> <a href="/tags/language/" style="font-size: 15px;">language</a> <a href="/tags/cpp/" style="font-size: 15px;">cpp</a> <a href="/tags/coroutine/" style="font-size: 15px;">coroutine</a> <a href="/tags/compute/" style="font-size: 15px;">compute</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/07/06/brpc(1)%E2%80%94bthread%E5%92%8Cbrpc/">brpc(1)—bthread和brpc</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/03/%E8%AE%A1%E7%AE%97(2)%E2%80%94GPU%E8%AE%A1%E7%AE%97%E5%92%8C%E5%A4%A7%E6%A8%A1%E5%9E%8B/">计算(2)——GPU计算和大模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/27/%E8%AE%A1%E7%AE%97(1)%E2%80%94CPU%E8%AE%A1%E7%AE%97%E5%92%8C%E5%A4%A7%E6%95%B0%E6%8D%AE/">计算(1)——CPU计算和大数据</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94C++%E5%8F%B3%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/">编程语言——C++右值和右值引用</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/20/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94C++%E5%8D%8F%E7%A8%8B%E5%92%8C%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/">编程语言——C++协程和高性能编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/07/%E5%AD%98%E5%82%A8%E2%80%94%E8%B0%88%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">存储——谈存储文件系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/15/leveldb(2)%E2%80%94%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/">leveldb(2)—线程模型和并发控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/12/redis(2)%E2%80%94%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/">redis(2)——网络处理和持久化</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/10/redis(1)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">redis(1)——数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/31/leveldb(1)%E2%80%94%E6%A6%82%E8%A7%88/">leveldb(1)—概览</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2026 <a href="/." rel="nofollow">Infinity Code.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>