<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>linux系统(3)——系统监控和问题排查 | Infinity Code</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">linux系统(3)——系统监控和问题排查</h1><a id="logo" href="/.">Infinity Code</a><p class="description">Simplicity is the soul of efficiency.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">linux系统(3)——系统监控和问题排查</h1><div class="post-meta">2024-12-05<span> | </span><span class="category"><a href="/categories/linux/">linux</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9FCPU%E3%80%81%E5%86%85%E5%AD%98%E3%80%81IO%E3%80%81%E7%BD%91%E7%BB%9C%E7%9B%91%E6%8E%A7"><span class="toc-number">1.</span> <span class="toc-text">系统CPU、内存、IO、网络监控</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU%E5%92%8C%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7%E2%80%94%E2%80%94top%E5%B7%A5%E5%85%B7"><span class="toc-number">1.1.</span> <span class="toc-text">CPU和内存监控——top工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E7%9B%91%E6%8E%A7%E2%80%94%E2%80%94iostat"><span class="toc-number">1.2.</span> <span class="toc-text">IO监控——iostat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%9B%91%E6%8E%A7%E2%80%94%E2%80%94ifconfig-netstat-ittop"><span class="toc-number">1.3.</span> <span class="toc-text">网络监控——ifconfig, netstat, ittop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sar%E5%92%8Ctsar-%E7%BB%9F%E8%AE%A1%E5%8E%86%E5%8F%B2%E4%BF%A1%E6%81%AF"><span class="toc-number">1.4.</span> <span class="toc-text">sar和tsar 统计历史信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9B%91%E6%8E%A7"><span class="toc-number">2.</span> <span class="toc-text">进程监控</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96"><span class="toc-number">2.1.</span> <span class="toc-text">进程基本信息获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8BCPU%E5%86%85%E5%AD%98IO%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">2.2.</span> <span class="toc-text">进程CPU内存IO使用情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="toc-number">3.</span> <span class="toc-text">进程性能问题排查</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.</span> <span class="toc-text">CPU问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.</span> <span class="toc-text">内存问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E5%92%8C%E7%A8%8B%E5%BA%8F%E8%87%AA%E8%BA%AB%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.</span> <span class="toc-text">IO和程序自身的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pstack%E5%92%8Cstrace"><span class="toc-number">3.4.</span> <span class="toc-text">pstack和strace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97"><span class="toc-number">4.</span> <span class="toc-text">linux系统日志</span></a></li></ol></div></div><div class="post-content"><p>本文介绍linux系统的监控工具和问题排查的一般步骤，文章大体内容</p>
<ol>
<li>用户程序一定要丰富trace和日志，并对trace做监控。正常情况下如果程序处理出现问题，会在监控告警中显示，介入排查可以通过trace和日志，判断出问题的文件、执行的线程等信息，绝大多数排查可以在这里停止，根本不用抓栈抓core。trace和日志必须包含的, 1. 时间戳 2. 函数名和位置 3. 线程ID和线程名, 这三个信息是排查必须</li>
<li>如果日志无法给出运行错误的原因，则需要进入机器查看。首先看有无core产生，产生core的原因一般是非法内存访问、double free、内存踩坏等或oom，因此首先去&#x2F;var&#x2F;log&#x2F;messages 看是否oom导致，oom会记录到&#x2F;var&#x2F;log&#x2F;messages日志。</li>
<li>如果没有core产生，但进程处理慢。可以先perf top -K -t $tid 查看耗时长的函数，原因大概是1. 被流控 2. 底层数据库&#x2F;IO服务处理慢，反压上层 4. CPU&#x2F;IO&#x2F;网络被打满，资源不足 5. 线程数量不足，任务队列堆积 等原因，这些原因本都应该展示在监控和日志里</li>
<li>如果有oom，需要内存占用高的线程抓core，分析内存占用高和是否有内存泄漏；如果有core, 则需要分析产生core产生的原因。先在debug 环境下尝试复现core，同时调用valgrind等工具分析。分析core比较困难，可以直接找最有经验的人来协助。</li>
</ol>
<span id="more"></span>

<h3 id="系统CPU、内存、IO、网络监控"><a href="#系统CPU、内存、IO、网络监控" class="headerlink" title="系统CPU、内存、IO、网络监控"></a>系统CPU、内存、IO、网络监控</h3><h4 id="CPU和内存监控——top工具"><a href="#CPU和内存监控——top工具" class="headerlink" title="CPU和内存监控——top工具"></a>CPU和内存监控——top工具</h4><p>top 能整体查看系统运行情况工具。利用top，能够观察到cpu,内存的运行情况，过滤出cpu 内存占用高的进程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">top - 16:16:56 up 16:55,  0 users,  load average: 2.01, 1.83, 1.48</span><br><span class="line">Tasks: 340 total,   1 running, 338 sleeping,   1 stopped,   0 zombie</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s):  1.3 us,  0.3 sy,  0.0 ni, 98.3 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line">MiB Mem :   7902.0 total,   2180.4 free,   2668.4 used,   3053.2 buff/cache</span><br><span class="line">MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   4924.6 avail Mem </span><br><span class="line">  scroll coordinates: y = 1/340 (tasks), x = 1/12 (fields)</span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                               </span><br><span class="line"> 172367 root      20   0   31.3g 171008  54448 S   1.0   2.1   0:56.97 node                                                                  </span><br><span class="line">   1832 root      20   0   11.4g  76164  43988 S   0.7   0.9   7:02.08 node                                                                  </span><br><span class="line"> 171284 root      20   0   13884   8968   7412 S   0.7   0.1   0:06.62 sshd                                                                  </span><br><span class="line">     14 root      20   0       0      0      0 I   0.3   0.0   5:13.07 rcu_sched                                                             </span><br><span class="line">   1774 root      20   0   11.3g 128480  46240 S   0.3   1.6   9:43.66 node</span><br><span class="line"></span><br><span class="line">us(用户态进程占用)，</span><br><span class="line">sy(内核进程占用), </span><br><span class="line">ni(nice低优先级进程占用), </span><br><span class="line">id(idle, cpu空闲时间占比), </span><br><span class="line">wa(wait, IO等待时间占比, 如果时间段在执行io且cpu空闲，则这段空闲cpu时间认为是wait), </span><br><span class="line">hi(hard interrupt) 硬中断执行时间,</span><br><span class="line">si(soft interrupt) 操作系统软中断执行时间,</span><br><span class="line">st(Steal Time) 分配给虚拟机的时间片</span><br></pre></td></tr></table></figure>

<p>top -p $pid，输出指定进程的cpu使用情况; top -H -p $pid，输出指定进程的线程cpu使用情况</p>
<p>top 命令点击大写P、M实现按照cpu&#x2F;mem 排序的进程，点击数字键1 可以看到每个cpu的占用。</p>
<h4 id="IO监控——iostat"><a href="#IO监控——iostat" class="headerlink" title="IO监控——iostat"></a>IO监控——iostat</h4><p>iostat是监控磁盘性能的工具。如果top发现cpu慢在wa，可以使用iostat看具体盘有无问题。命令<code>iostat -x 1 2</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           1.69    0.01    1.05    0.02    0.00   97.23</span><br><span class="line"></span><br><span class="line">Device            r/s     rkB/s   rrqm/s  %rrqm r_await rareq-sz     w/s     wkB/s   wrqm/s  %wrqm w_await wareq-sz     d/s     dkB/s   drqm/s  %drqm d_await dareq-sz  aqu-sz  %util</span><br><span class="line">loop0            0.00      0.00     0.00   0.00    0.29     1.21    0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00   0.00</span><br><span class="line"></span><br><span class="line">r/s w/s 每秒读和写的请求数量(qos)</span><br><span class="line">rrqm/s wrqm/s 每秒合并的读写请求数量</span><br><span class="line">rkB/s wkB/s 每秒读写的字节数(吞吐)</span><br><span class="line">r_await w_await 读写操作io平均等待时间</span><br><span class="line">avgrq-sz：每个IO的平均扇区数，一个扇区512字节</span><br><span class="line">await：平均每个IO所需要的时间, </span><br><span class="line">%util 磁盘的利用率</span><br></pre></td></tr></table></figure>

<p>磁盘利用率表示io时间占cpu总时间的比例， 表示cpu处理空闲阶段且存在io操作，这段cpu时间片就认为是iowait消耗的</p>
<h4 id="网络监控——ifconfig-netstat-ittop"><a href="#网络监控——ifconfig-netstat-ittop" class="headerlink" title="网络监控——ifconfig, netstat, ittop"></a>网络监控——ifconfig, netstat, ittop</h4><p>ifconfig，查看网卡、ip地址、网络传输量、丢包情况等基本信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.92.128  netmask 255.255.255.0  broadcast 192.168.92.255</span><br><span class="line">        inet6 fe80::20c:29ff:fe51:9544  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:51:95:44  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 695151  bytes 132025574 (132.0 MB)</span><br><span class="line">        RX errors 183  dropped 206  overruns 0  frame 0</span><br><span class="line">        TX packets 863078  bytes 357598696 (357.5 MB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">        device interrupt 19  base 0x2000</span><br></pre></td></tr></table></figure>

<p>netstat -nultp 查看pid和监听的端口信息, 可以用来查看链接数量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 127.0.0.1:39997         0.0.0.0:*               LISTEN      171361/code-fabdb6a </span><br><span class="line">tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      130592/systemd-reso </span><br><span class="line">tcp        0      0 127.0.0.1:44791         0.0.0.0:*               LISTEN      172327/code-fabdb6a </span><br><span class="line">tcp        0      0 127.0.0.1:32819         0.0.0.0:*               LISTEN      169497/code-fabdb6a </span><br><span class="line">tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      2793/cupsd</span><br></pre></td></tr></table></figure>
<p>netstat -an | grep “:80” | wc -l, 查看端口的链接数量<br>netstat -r 显示路由表</p>
<p>netstat -s查看网络统计信息，统计时间是从系统启动到执行命令。如果想查最近1分钟的数据, 需要1分钟后再执行，二者数值作差</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Ip:</span><br><span class="line">    Forwarding: 2</span><br><span class="line">    2963380 total packets received</span><br><span class="line">    15 with invalid addresses</span><br><span class="line">    0 forwarded</span><br><span class="line">    0 incoming packets discarded</span><br><span class="line">    2963365 incoming packets delivered</span><br><span class="line">    1762116 requests sent out</span><br><span class="line">    20 outgoing packets dropped</span><br><span class="line">    14 dropped because of missing route</span><br><span class="line">Icmp:</span><br><span class="line">    44 ICMP messages received</span><br><span class="line">    0 input ICMP message failed</span><br><span class="line">    ICMP input histogram:</span><br><span class="line">        destination unreachable: 43</span><br><span class="line">        echo requests: 1</span><br><span class="line">    44 ICMP messages sent</span><br><span class="line">    0 ICMP messages failed</span><br><span class="line">    ICMP output histogram:</span><br><span class="line">        destination unreachable: 43</span><br><span class="line">        echo replies: 1</span><br><span class="line">Tcp:</span><br><span class="line">    7492 active connection openings</span><br><span class="line">    2514 passive connection openings</span><br><span class="line">    2028 failed connection attempts</span><br><span class="line">    23 connection resets received</span><br><span class="line">    17 connections established</span><br><span class="line">    2945531 segments received</span><br><span class="line">    3981690 segments sent out</span><br><span class="line">    414 segments retransmitted</span><br><span class="line">    2 bad segments received</span><br><span class="line">    351 resets sent</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ping和curl 查看网络和端口的连通性</span><br><span class="line"></span><br><span class="line">使用iftop 统计网卡实时流量, iftop -i 指定网卡</span><br><span class="line">```shell</span><br><span class="line">TX:             cum:   12.4KB   peak:   11.9Kb                                                                                                          rates:   9.09Kb  9.89Kb  9.89Kb</span><br><span class="line">RX:                    8.64KB           8.17Kb                                                                                                                   8.17Kb  6.91Kb  6.91Kb</span><br><span class="line">TOTAL:                 21.0KB           18.3Kb                                                                                                                   17.3Kb  16.8Kb  16.8Kb</span><br></pre></td></tr></table></figure>

<h4 id="sar和tsar-统计历史信息"><a href="#sar和tsar-统计历史信息" class="headerlink" title="sar和tsar 统计历史信息"></a>sar和tsar 统计历史信息</h4><p>以上top, netsta, iostat等工具只能统计当前时刻的信息，有时候我们需要历史统计信息，就需要sar和tsar</p>
<p>sar (System Activity Report) 是 Linux 系统中的一个性能监控工具，<strong>可以用来统计历史的cpu</strong>, 内存, io**, 网络等监控数据; tsar 是淘宝开源的性能监控工具, 同样可以用来统计历史监控数据。sar 需要安装sysstat</p>
<p>sar -u 1 5 统计cpu 信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">02:17:10 PM     CPU     %user     %nice   %system   %iowait    %steal     %idle</span><br><span class="line">02:17:11 PM     all      0.06      0.00      0.13      0.00      0.00     99.81</span><br><span class="line">02:17:12 PM     all      0.13      0.00      0.44      0.00      0.00     99.44</span><br><span class="line">02:17:13 PM     all      0.06      0.00      0.38      0.00      0.00     99.56</span><br><span class="line"></span><br><span class="line">Average:        all      0.08      0.00      0.31      0.00      0.00     99.60</span><br></pre></td></tr></table></figure>

<p>sar -hr 1 5 显示内存信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">02:18:34 PM kbmemfree   kbavail kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">02:18:35 PM      2.8G      4.8G      2.5G     32.8%    116.8M      2.0G      2.7G     35.2%    793.5M      3.6G      8.0k</span><br><span class="line">02:18:36 PM      2.8G      4.8G      2.5G     32.8%    116.8M      2.0G      2.7G     35.2%    793.5M      3.6G      8.0k</span><br><span class="line">Average:         2.8G      4.8G      2.5G     32.8%    116.8M      2.0G      2.7G     35.2%    793.5M      3.6G      8.0k</span><br></pre></td></tr></table></figure>

<p>sar -d 1 5 查看磁盘统计, 统计每个磁盘的iops, 读写吞吐, wait, 使用率</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Average:          DEV       tps     rkB/s     wkB/s     dkB/s   areq-sz    aqu-sz     await     %util</span><br><span class="line">Average:       dev7-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:       dev7-1      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:       dev7-2      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tps Transactions Per Second, 每秒io数量</span></span><br></pre></td></tr></table></figure>

<p>sar -n DEV 1 5 统计网络流量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">02:35:32 PM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil</span><br><span class="line">02:35:33 PM        lo     32.67     32.67      3.74      3.74      0.00      0.00      0.00      0.00</span><br><span class="line">02:35:33 PM     ens33     16.83     15.84      2.34      2.45      0.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line">rxkB/s, 每秒接收的数据量（KB）。</span><br><span class="line">txkB/s, 每秒发送的数据量（KB）。</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">ifutil, 网络接口利用率</span></span><br></pre></td></tr></table></figure>

<p>sar -q 1 5 查看系统负载（进程数量）信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">02:35:51 PM   runq-sz  plist-sz   ldavg-1   ldavg-5  ldavg-15   blocked</span><br><span class="line">02:35:52 PM         2       616      0.53      0.40      0.38         0</span><br><span class="line">02:35:53 PM         0       618      0.53      0.40      0.38         0</span><br><span class="line">Average:            1       617      0.53      0.40      0.38         0</span><br><span class="line"></span><br><span class="line">runq-sz：运行队列的长度。</span><br><span class="line">plist-sz：当前进程的数量。</span><br><span class="line">ldavg-1、ldavg-5、ldavg-15：系统在 1、5 和 15 分钟的平均负载。</span><br></pre></td></tr></table></figure>

<h3 id="进程监控"><a href="#进程监控" class="headerlink" title="进程监控"></a>进程监控</h3><h4 id="进程基本信息获取"><a href="#进程基本信息获取" class="headerlink" title="进程基本信息获取"></a>进程基本信息获取</h4><p>ps -ef, ps aux 获得进程的pid, 状态等信息。一般拿到进程pid后就直接top -p</p>
<p>&#x2F;proc&#x2F;{pid} 目录可以看到进程相关资源信息。例如<br>&#x2F;proc&#x2F;{pid}&#x2F;fd 查看打开的文件信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dr-x------ 2 root       root        0 1月   3 23:22 ./</span><br><span class="line">dr-xr-xr-x 9 messagebus messagebus  0 1月   3 23:22 ../</span><br><span class="line">lrwx------ 1 root       root       64 1月   3 23:22 0 -&gt; /dev/null</span><br><span class="line">lrwx------ 1 root       root       64 1月   3 23:22 1 -&gt; &#x27;socket:[39683]&#x27;</span><br><span class="line">lrwx------ 1 root       root       64 1月   3 23:22 10 -&gt; &#x27;socket:[269352]&#x27;</span><br><span class="line">lrwx------ 1 root       root       64 1月   3 23:22 11 -&gt; &#x27;socket:[36858]&#x27;</span><br></pre></td></tr></table></figure>

<p>&#x2F;proc&#x2F;{pid}&#x2F;cgroup，查看进程cgroup配置信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">13:hugetlb:/</span><br><span class="line">12:perf_event:/</span><br><span class="line">11:blkio:/system.slice/dbus.service</span><br><span class="line">10:memory:/system.slice/dbus.service</span><br><span class="line">9:rdma:/</span><br><span class="line">8:pids:/system.slice/dbus.service</span><br><span class="line">7:freezer:/</span><br><span class="line">6:cpu,cpuacct:/system.slice/dbus.service</span><br><span class="line">5:cpuset:/</span><br><span class="line">4:misc:/</span><br><span class="line">3:devices:/system.slice/dbus.service</span><br><span class="line">2:net_cls,net_prio:/</span><br><span class="line">1:name=systemd:/system.slice/dbus.service</span><br><span class="line">0::/system.slice/dbus.service</span><br></pre></td></tr></table></figure>

<p>具体的cgroup内容在&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;下查看</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2204:/home/tech-blog# ls /sys/fs/cgroup/</span><br><span class="line">cgroup.controllers      cgroup.subtree_control  cpu.stat             io.cost.qos       memory.pressure                sys-kernel-config.mount</span><br><span class="line">cgroup.max.depth        cgroup.threads          dev-hugepages.mount  io.pressure       memory.stat                    sys-kernel-debug.mount</span><br><span class="line">cgroup.max.descendants  cpu.pressure            dev-mqueue.mount     io.prio.class     misc.capacity                  sys-kernel-tracing.mount</span><br><span class="line">cgroup.procs            cpuset.cpus.effective   init.scope           io.stat           proc-sys-fs-binfmt_misc.mount  system.slice</span><br></pre></td></tr></table></figure>

<h4 id="进程CPU内存IO使用情况"><a href="#进程CPU内存IO使用情况" class="headerlink" title="进程CPU内存IO使用情况"></a>进程CPU内存IO使用情况</h4><p>使用top -p $pid 可以查看进程的cpu&#x2F;内存使用情况</p>
<p>pidstat 命令可以查看进程级的统计信息<br>基础信息统计</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2204:/home/tech-blog# pidstat 1 5</span><br><span class="line">Linux 5.15.0-138-generic (ubuntu2204)   04/30/2025      _x86_64_        (16 CPU)</span><br><span class="line"></span><br><span class="line">02:25:21 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</span><br><span class="line">02:25:22 PM   116      1087    0.00    0.95    0.00    0.00    0.95     6  beam.smp</span><br><span class="line">02:25:22 PM   114      1242    0.95    0.95    0.00    0.00    1.90     9  mysqld</span><br><span class="line">02:25:22 PM     0      1931    0.00    0.95    0.00    0.00    0.95     1  node</span><br><span class="line">02:25:22 PM     0      1987    0.95    0.95    0.00    0.00    1.90    12  node</span><br><span class="line">02:25:22 PM     0      2424    0.95    0.95    0.00    0.00    1.90     2  Lingma</span><br><span class="line">02:25:22 PM     0      5203    0.00    0.95    0.00    0.95    0.95     7  node</span><br><span class="line">02:25:22 PM     0      9837    0.00    0.95    0.00    0.00    0.95     4  kworker/4:4-pm</span><br><span class="line">02:25:22 PM     0     10030    0.00    0.95    0.00    0.00    0.95     4  sshd</span><br><span class="line">02:25:22 PM     0     11977    1.90    0.95    0.00    0.00    2.86     2  pidstat</span><br></pre></td></tr></table></figure>

<h3 id="进程性能问题排查"><a href="#进程性能问题排查" class="headerlink" title="进程性能问题排查"></a>进程性能问题排查</h3><p>进程出现性能问题，原因可能如下</p>
<ol>
<li>CPU 资源不足，原因可能是进程cgroup限制cpu核数导致资源不足，CPU各核心负载分配不均，进程下线程数量过多，导致有的线程抢占不到CPUhang住等。CPU资源不足导致的结果一般是进程处理能力无法上升</li>
<li>内存资源不足，可能是发生内存踩坏、double free 或内存泄漏；前者导致进程崩溃产生core，后者导致进程内存使用不断上涨，直到oom被系统kill。</li>
<li>IO资源不足，也就是读写数据库&#x2F;文件变慢，这个最好排查</li>
<li>程序自身的问题，例如线程分配数量过少、存在函数耗时过长、死锁等导致性能问题</li>
</ol>
<p>一般来说问题排查可以1-2-3-4逐次进行</p>
<h4 id="CPU问题"><a href="#CPU问题" class="headerlink" title="CPU问题"></a>CPU问题</h4><p>CPU问题主要有两个1. CPU资源不足 2. CPU负载不均，某线程占用的大量CPU导致其他线程hang住</p>
<p>首先通过top看进程当前的cpu占用，看是否接近cgroup 的cpu核数限制</p>
<ol>
<li>如果接近cgroup限制，适当调高cgroup</li>
<li>利用top查看所有的cpu核心是否打满，如果没有打满，后续应优化核心的资源均衡</li>
<li>利用top -p $pid -H查看cpu占用最高的线程</li>
<li>对cpu占用最高的线程执行, <code>perf top -K -t &lt;tid&gt;</code> 可以查看线程主要开销的调用栈，其中-K表示过滤调内核模块</li>
</ol>
<p>perf top -K -t $tid的示例，注意线上千万不要对进程执行perf！！！否则有进程重启的风险<br><img src="/../images/perf_top.png" alt="perf_top"></p>
<p>进一步的, 对线程抓热度图。命令如下</p>
<ol>
<li><code>sudo perf record -e cpu-clock -t $tid --call-graph dwarf</code>，如果要对进程执行，将-t $tid改为-p $pid, 执行完后会生成perf.data文件</li>
<li>用perf script工具对perf.data文件解析, <code>perf script -i perf.data &amp;&gt; perf.unfold</code></li>
<li>将perf.unfold中的符号折叠, 执行<code>./stackcollapse-perf.pl perf.unfold &amp;&gt; perf.folded</code></li>
<li>最后生成svg火焰图 <code>./flamegraph.pl perf.folded &gt; perf.svg</code></li>
</ol>
<p>其中.&#x2F;stackcollapse-perf.pl和.&#x2F;flamegraph.pl 工具均来自 <a target="_blank" rel="noopener" href="https://github.com/brendangregg/FlameGraph">https://github.com/brendangregg/FlameGraph</a></p>
<p>利用火焰图可以直观的观察调用栈和每个栈的执行时间，调用栈越宽的表示CPU执行时间长，可能需要优化。例如<br><img src="/../images/flamegraph.png" alt="frame_graph"></p>
<p>获取调用栈需要设置–call-graph dwarf, 参考 <a target="_blank" rel="noopener" href="https://gaomf.cn/2019/10/30/perf_stack_traceback/">https://gaomf.cn/2019/10/30/perf_stack_traceback/</a></p>
<p>一般来说如果不是cgroup的问题，只能将进程的一些次要任务迁移走或调低，优先保证主要任务的CPU占用。</p>
<h4 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h4><p>内存问题也主要有两个1. 内存踩坏或double free（常发生在C&#x2F;C++）2. 内存泄漏导致oom（也常发送在C&#x2F;C++）。对于有GC的语言如JAVA、GO，如果内存用量持续增高，只要观察并调整相应jvm参数加快GC，就可缓解内存上涨；而对于C&#x2F;C++，由于内存创建和释放完全由程序员负责，内存泄漏问题很常见，且难以排查。</p>
<p>C++ 的debug编译一定开启asan（​​Address Sanitizer）, 即<code>g++ -fsanitize=address -g xxx</code>, 在UT覆盖的情况下执行UT 时Asan可以帮助检查内存泄漏。其核心原理是通过 ​​内存插桩（Instrumentation）​​ 和 ​​影子内存（Shadow Memory）​​ 机制，实时监控程序的内存操作。Valgrind 也用于内存泄漏的工具，相比asan是编译期插桩，Valgrind是运行期插桩，运行慢但检查更全面。一般选择asan快速定位内存问题，再用Valgrind深入分析。<br>Asan和Valgrind都会带来性能损失，一般只用于debug 环境。</p>
<p>如果生成环境遇到内存踩坏或内存泄漏，前者一般导致进程产生core，后者在监控上能看到机器内存使用一直缓慢增长。这时我们一般首先拿到core文件，内存踩坏一般直接会产生core，内存泄漏我们使用gcore来抓core， gcore抓core可能要持续几十秒（请耐心等待）。gcore命令的好处是不需要进程重启。（执行kill -s 11会让进程直接segment fault产生core，但会导致进程重启）。如果是内存泄漏问题，可以先尝试对内存占用高的线程进行抓core</p>
<p>一个优化的抓core方法是让进程提供抓core的运维命令，进程收到命令后，fork出一个子进程继续处理任务，将父进程abort()掉，自动生成core。</p>
<p>抓到core后可以获取两种信息</p>
<ol>
<li>进程core掉时的每个线程的调用栈信息</li>
<li>进程core掉时的内存信息</li>
</ol>
<p>获取线程调用栈信息的步骤, 执行如下命令将所有调用栈打印到gdb.txt文件中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb binary corefile</span><br><span class="line"></span><br><span class="line">set height 100000</span><br><span class="line">set logging on</span><br><span class="line">thread apply all bt</span><br></pre></td></tr></table></figure>

<p>获取进程core掉的内存信息，</p>
<ol>
<li>gdb里执行<code>info proc mappings</code>命令显示core文件中的虚拟内存映射表，同时会输出每个内存映射的start_addr, end_addr, size, offset, objfile</li>
<li>执行<code>dump binary memory result.bin $start_addr $end_addr</code> 将内存大隐刀本地result.bin文件中</li>
<li>在vim里查看result.bin文件，通过<code>:%!xxd</code>方式以16进制模式来查看，左侧是16进制地址，右侧是ASCII字符</li>
</ol>
<p>主要是看右侧的ASCII字符，看有没有相关的提示。</p>
<p>C++ 的release binary和core 会丢失代码里的类型信息、函数信息，core能看到的大多数只是一串内存地址和内存里的数据，但我们难以知道这段内存对应代码的哪个地方。一方面我们要猜测哪个地址发生了内存泄漏，另一方面也要猜测发生内存泄漏的地址位于哪部分代码。</p>
<p>我们可以通过强化tcmalloc和gdb工具辅助排查内存泄漏，tcmalloc主要是插桩，在tcmalloc分配和释放内存时做记录，gdb主要是辅助解析，例如统计申请内存大小为xxx的调用信息。利用这些记录和统计信息可以帮助内存泄漏的排查。如果C++程序里有虚函数，也可以通过虚函数记录的类型信息帮助分析（JAVA的函数默认都是虚函数，这让JAVA排查core比C++简单很多）。</p>
<h4 id="IO和程序自身的问题"><a href="#IO和程序自身的问题" class="headerlink" title="IO和程序自身的问题"></a>IO和程序自身的问题</h4><p>如果是程序自身的问题，1. 导致CPU占用高 2. 导致内存踩坏或内存泄漏，前面已经分析过</p>
<p><strong>用户程序必须要打印trace日志</strong>，尤其是读写文件、读写数据库等IO操作，通过trace日志可以直接判断IO问题。</p>
<p><strong>用户程序应该要让线程定期执行报备的操作</strong>，如果某个线程长期没有报备，则说明该线程要么Hang住，要么死锁，要么是其他原因阻塞住。</p>
<h4 id="pstack和strace"><a href="#pstack和strace" class="headerlink" title="pstack和strace"></a>pstack和strace</h4><p>sudo pstack $pid 用来抓进程&#x2F;线程调用栈</p>
<p>strace -p $pid, 用来抓进程&#x2F;线程的系统调用信息</p>
<p>这两个命令都十分有用，可以在发现CPU、内存、IO的异常线程时，对线程执行sudo pstack 和sudo strace， 但切记不要对进程执行这俩命令。</p>
<p>如果是线程死锁导致进程处理慢，pstack几次线程就可以判断死锁了。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>debug环境下要做到</p>
<ol>
<li>编译开启asan检查内存泄漏，有必要的话clang-format, clang-tidy, Valgrind 也要打开</li>
<li>UT覆盖率至少90%，UT可以保证单线程场景下接口的运行正确，无内存泄漏</li>
<li>上线前一定要进行多并发压测和长稳测试，主要是观察多线程情况下程序运行是否正常</li>
<li>上线前的功能测试，目的是确认程序功能正常，也就是程序逻辑是对的。如果程序逻辑不正确，上线后难以检测到（无法通过CPU，内存，QPS等指标判断异常）。**因此功能覆盖率一定要100%**。</li>
</ol>
<p>用户程序一定要丰富trace和日志，并对trace做监控。正常情况下如果程序处理出现问题，会在监控告警中显示，介入排查可以通过trace和日志，判断出问题的文件、执行的线程等信息，绝大多数排查可以在这里停止，根本不用抓栈抓core。trace和日志必须包含的, 1. 时间戳 2. 函数名和位置 3. 线程ID和线程名, 这三个信息是排查必须</p>
<p>如果日志无法给出运行错误的原因，则需要进入机器查看</p>
<ol>
<li>首先看有无core产生，产生core的原因一般是非法内存访问、double free、内存踩坏等或oom，因此首先去&#x2F;var&#x2F;log&#x2F;messages 看是否oom导致，oom会记录到&#x2F;var&#x2F;log&#x2F;messages日志。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel: Out of memory: Kill process 12345 (java) score 678 or sacrifice child</span><br><span class="line">kernel: Killed process 12345 (java) total-vm:123456kB, anon-rss:65432kB, file-rss:0kB, shmem-rss:0kB</span><br></pre></td></tr></table></figure></li>
</ol>
<p>如果没有core产生，但进程处理慢。可以先perf top -K -t $tid 查看耗时长的函数，原因大概是1. 被流控 2. 底层数据库&#x2F;IO服务处理慢，反压上层 4. CPU&#x2F;IO&#x2F;网络被打满，资源不足 5. 线程数量不足，任务队列堆积 等原因，这些原因本都应该展示在监控和日志里</p>
<p>如果有oom，需要内存占用高的线程抓core，分析内存占用高和是否有内存泄漏</p>
<p>如果有core, 则需要分析产生core产生的原因。先在debug 环境下尝试复现core，同时调用valgrind等工具分析。分析core比较困难，可以直接找最有经验的人来协助。</p>
<p>可以借助大量的问题排查分享来积累经验，例如 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xingmuxin/p/11287935.html">https://www.cnblogs.com/xingmuxin/p/11287935.html</a></p>
<h3 id="linux系统日志"><a href="#linux系统日志" class="headerlink" title="linux系统日志"></a>linux系统日志</h3><p>linux 系统日志，默认存储在&#x2F;var&#x2F;log目录下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/var/log/</span><br><span class="line">├── syslog          # 通用系统日志（Debian/Ubuntu）</span><br><span class="line">├── messages        # 通用系统日志（RHEL/CentOS）</span><br><span class="line">├── auth.log        # 认证日志（登录、sudo）</span><br><span class="line">├── kern.log        # 内核日志（硬件、驱动事件）</span><br><span class="line">├── boot.log        # 系统启动日志</span><br><span class="line">├── dmesg           # 内核环形缓冲区日志（启动阶段信息）</span><br><span class="line">├── cron            # 定时任务日志</span><br><span class="line">├── apache2/        # Apache 服务日志（访问日志、错误日志）</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure>

<p>nginx, mysql 等系统服务可能把日志写到&#x2F;var&#x2F;log下<br>&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log	Nginx 访问日志（客户端请求）	tail -f &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log<br>&#x2F;var&#x2F;log&#x2F;mysql&#x2F;error.log	MySQL 错误日志	sudo less &#x2F;var&#x2F;log&#x2F;mysql&#x2F;error.log</p>
<p>journalctl​​：查看 systemd 日志（支持服务筛选、时间范围）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">journalctl -u nginx.service -f    <span class="comment"># 实时追踪 Nginx 日志</span></span><br><span class="line">journalctl --since <span class="string">&quot;2024-01-01&quot;</span> --<span class="keyword">until</span> <span class="string">&quot;2024-01-02&quot;</span></span><br></pre></td></tr></table></figure>

<p>dmesg​​：查看内核环形缓冲区日志。内核环形缓冲区（Kernel Ring Buffer）是Linux内核用于临时存储运行时消息（如硬件事件、驱动状态、系统错误）的内存区域。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep <span class="string">&quot;USB&quot;</span>           <span class="comment"># 检查 USB 设备事件</span></span><br><span class="line">dmesg -T                     <span class="comment"># 显示人类可读的时间戳</span></span><br></pre></td></tr></table></figure>

<p>配置日志轮转<br>&#x2F;etc&#x2F;logrotate.conf 和 &#x2F;etc&#x2F;logrotate.d&#x2F;*</p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul></div><div class="post-nav"><a class="pre" href="/2024/12/06/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94%E6%98%A0%E5%B0%84%E7%BB%93%E6%9E%84/">编程语言——映射结构</a><a class="next" href="/2024/11/30/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(2)%E2%80%94%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/">编程语言(2)—类型和运算符</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://larrystd.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>To be a better man.</p><a class="info-icon" href="https://twitter.com/username" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:admin@domain.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/application/">application</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/compute/">compute</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hello/">hello</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/language/">language</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/storage/">storage</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/hello/" style="font-size: 15px;">hello</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/brpc/" style="font-size: 15px;">brpc</a> <a href="/tags/storage/" style="font-size: 15px;">storage</a> <a href="/tags/leveldb/" style="font-size: 15px;">leveldb</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/application/" style="font-size: 15px;">application</a> <a href="/tags/base/" style="font-size: 15px;">base</a> <a href="/tags/language/" style="font-size: 15px;">language</a> <a href="/tags/cpp/" style="font-size: 15px;">cpp</a> <a href="/tags/coroutine/" style="font-size: 15px;">coroutine</a> <a href="/tags/compute/" style="font-size: 15px;">compute</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/07/06/brpc(1)%E2%80%94bthread%E5%92%8Cbrpc/">brpc(1)—bthread和brpc</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/03/%E8%AE%A1%E7%AE%97(2)%E2%80%94GPU%E8%AE%A1%E7%AE%97%E5%92%8C%E5%A4%A7%E6%A8%A1%E5%9E%8B/">计算(2)——GPU计算和大模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/27/%E8%AE%A1%E7%AE%97(1)%E2%80%94CPU%E8%AE%A1%E7%AE%97%E5%92%8C%E5%A4%A7%E6%95%B0%E6%8D%AE/">计算(1)——CPU计算和大数据</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94C++%E5%8F%B3%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/">编程语言——C++右值和右值引用</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/20/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94C++%E5%8D%8F%E7%A8%8B%E5%92%8C%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/">编程语言——C++协程和高性能编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/07/%E5%AD%98%E5%82%A8%E2%80%94%E8%B0%88%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">存储——谈存储文件系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/15/leveldb(2)%E2%80%94%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/">leveldb(2)—线程模型和并发控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/12/redis(2)%E2%80%94%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/">redis(2)——网络处理和持久化</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/10/redis(1)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">redis(1)——数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/31/leveldb(1)%E2%80%94%E6%A6%82%E8%A7%88/">leveldb(1)—概览</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2026 <a href="/." rel="nofollow">Infinity Code.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>