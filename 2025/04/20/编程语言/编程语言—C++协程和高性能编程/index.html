<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>编程语言——C++协程和高性能编程 | Infinity Code</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">编程语言——C++协程和高性能编程</h1><a id="logo" href="/.">Infinity Code</a><p class="description">Simplicity is the soul of efficiency.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">编程语言——C++协程和高性能编程</h1><div class="post-meta">2025-04-20<span> | </span><span class="category"><a href="/categories/language/">language</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-20%E5%8D%8F%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">C++20协程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">协程链式调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-number">1.2.</span> <span class="toc-text">协程和异步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E6%A0%88%E5%8D%8F%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">有栈协程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">异步编程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SQE-CQE-%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">SQE&#x2F;CQE 模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">事件通知模型</span></a></li></ol></li></ol></div></div><div class="post-content"><p>C++可以写出性能高效的程序，一个原因来自语言本身的因素，例如</p>
<ol>
<li>C++程序编译器可以进行优化，编译直接得到机器码，这让编译后需要执行的指令更少（解释器性能比编译期差的主要原因就是是解释器单行编译执行，而编译器是文件编译执行，获得的信息更多，优化空间更大。明确的类型信息也让编译期获得内存信息，可以在无须创建对象情况下进行优化）</li>
<li>没有虚函数的C++程序编译后的执行码和C语言一样，没有golang interface{}, java 虚函数等额外的内存开销。C++的class, template等功能抽象不会带来额外的性能开销</li>
<li>C++可以直接管理内存，轻松写出内存零拷贝的程序，无需GC额外的性能开销。</li>
</ol>
<p>除了语言本身的因素，生态因素对于高性能同样重要。用户程序不可能每次都造轮子，如果没有高性能的库，C++不会成为性能高效程序的首选。例如Python语言的性能虽然差，但python有tensorflow, pytorch等高性能神经网络框架，这让python写出的神经网络性能同样高效。</p>
<p>dpdk和spdk工具链让C++开发高性能网络服务器和高性能存储服务变得容易，GPU等新硬件和cuda等生态让C++成为高性能计算的基础。C++20提供了协程支持，deepseek 开源的3FS 就是C++20高性能编程的典型例子。</p>
<span id="more"></span>

<h3 id="C-20协程"><a href="#C-20协程" class="headerlink" title="C++20协程"></a>C++20协程</h3><p>C++20 提供了协程支持，协程可以看做任务，任务执行期间可以在某个位置暂停-继续。</p>
<p>C++ 提供std::coroutine_handle&lt;&gt;作为协程句柄, 协程句柄需要传入自定义的Promise类型，用来指定协程的返回值，初始化和退出行为等。<br>promise_type 必须实现以下成员函数</p>
<ol>
<li><code>std::coroutine_handle&lt;promise&gt;</code> get_return_object() 返回coroutine_handle对象</li>
<li>initial_suspend()	控制协程启动时是否立即挂起，返回 suspend_always 表示协程创建后挂起, 需要调用一次resume才会执行, 返回 suspend_never表示协程创建后立即执行</li>
<li>final_suspend()	控制协程结束时是否挂起, 同样可以返回 suspend_always 或者 suspend_never</li>
<li>yield_value(value)	接受co_yield 表达式返回值, 可以处理</li>
<li>return_value(value)  接受co_return value返回值，可以处理</li>
<li>return_void() 执行co_return后执行该函数</li>
<li>unhandled_exception()	处理协程中未捕获的异常。</li>
</ol>
<p>通过以上函数，可以实现协程创建后，销毁前，co_return&#x2F;co_yield之后的行为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    T current_value;</span><br><span class="line">    <span class="comment">// 协程挂起时的返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">yield_value</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        current_value = value;</span><br><span class="line">        <span class="keyword">return</span> std::suspend_always&#123;&#125;; <span class="comment">// 每次生成后暂停</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 协程初始化设置</span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">    <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123; std::<span class="built_in">terminate</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::coroutine_handle&lt;promise_type&gt;;</span><br></pre></td></tr></table></figure>

<p>协程一重要的关键字是co_await，表示挂起当前协程，执行流切换到其他任务。co_await 后面需要加Awaiter对象.<br>awaiter必须要实现的三个函数</p>
<ol>
<li>bool await_ready() const noexcept; 表示调用co_await后是否立即执行，如果返回true，则直接执行，不会挂起当前协程。</li>
<li>void await_suspend(std::coroutine_handle&lt;&gt; handle) noexcept; 参数为当前协程句柄, 可以将执行流切给指定的coroutine_handle</li>
<li>T await_resume() noexcept; 当协程处于co_await状态，调用resume时执行该函数。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">custom_awaiter</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否直接继续执行（true=不挂起）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起时执行（参数为当前协程句柄）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; h)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复时执行的逻辑与返回值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>协程执行例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义协程返回类型 Task</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        <span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;创建协程对象\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> Task&#123;std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="comment">// 返回suspend_always 对象, 协程初始化后挂起</span></span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;初始化挂起\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="comment">// 协程结束后挂起</span></span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;最终挂起\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;协程返回\n&quot;</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            std::<span class="built_in">terminate</span>(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; handle;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Task</span><span class="params">(std::coroutine_handle&lt;promise_type&gt; h)</span> : handle(h) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Task</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (handle) handle.<span class="built_in">destroy</span>();</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;销毁协程\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 恢复当前协程执行</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!handle.<span class="built_in">done</span>()) &#123;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;恢复协程执行\n&quot;</span>);</span><br><span class="line">            handle.<span class="built_in">resume</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义可等待对象（Awaiter）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AsyncOperation</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;检查是否就绪\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 总是挂起</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; h)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;开始异步操作...\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 新建额外线程, suspend不阻塞</span></span><br><span class="line">        std::<span class="built_in">thread</span>([h] &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;异步操作完成\n&quot;</span>);</span><br><span class="line">            h.<span class="built_in">resume</span>(); <span class="comment">// 完成后恢复协程</span></span><br><span class="line">        &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;处理操作结果\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 协程函数定义</span></span><br><span class="line"><span class="function">Task <span class="title">my_coroutine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;协程开始执行\n&quot;</span>);</span><br><span class="line">    <span class="keyword">co_await</span> AsyncOperation&#123;&#125;; <span class="comment">// 等待异步操作</span></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;继续执行协程体\n&quot;</span>);</span><br><span class="line">    <span class="keyword">co_await</span> std::suspend_always&#123;&#125;; <span class="comment">// 主动挂起</span></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;协程最终阶段\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Task task = <span class="built_in">my_coroutine</span>(); <span class="comment">// 创建并初始化协程, 协程挂起</span></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;首次恢复协程:\n&quot;</span>);</span><br><span class="line">    task.<span class="built_in">resume</span>();             <span class="comment">// 第一次, 启动协程</span></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;执行流切回主线程:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;二次恢复协程:\n&quot;</span>);</span><br><span class="line">    task.<span class="built_in">resume</span>();             <span class="comment">// 第二次恢复</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;\n程序结束\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">创建协程对象</span><br><span class="line">初始化挂起</span><br><span class="line">首次恢复协程:</span><br><span class="line">恢复协程执行</span><br><span class="line">协程开始执行</span><br><span class="line">检查是否就绪</span><br><span class="line">开始异步操作...</span><br><span class="line">执行流切回主线程:</span><br><span class="line">异步操作完成</span><br><span class="line">处理操作结果</span><br><span class="line">继续执行协程体</span><br><span class="line">二次恢复协程:</span><br><span class="line">恢复协程执行</span><br><span class="line">协程最终阶段</span><br><span class="line">协程返回</span><br><span class="line">最终挂起</span><br><span class="line"></span><br><span class="line">程序结束</span><br><span class="line">销毁协程</span><br></pre></td></tr></table></figure>
<p>执行流分析</p>
<ol>
<li>Task task &#x3D; my_coroutine() 时，创建协程和初始化对象, 分别执行Task get_return_object() 和std::suspend_always initial_suspend()两个函数</li>
<li>task.resume(); 执行会启动协程，协程执行到co_await，挂起。协程挂起后，执行流交给main函数, 也就是调用resume()的函数</li>
<li>await_suspend 创建了新线程用来执行异步任务，异步任务执行完成后在新线程中调用h.resume()，协程继续在新线程执行，主线程这时候在sleep()</li>
<li>新线程继续执行协程，直到co_await std::suspend_always{}; 直接挂起（显然std::suspend_always{}; 也是一种awaiter表示无条件挂起）。这时候新线程执行完毕退出，但协程对象挂在co_await</li>
<li>最后主线程sleep()完执行task.resume(); 协程又继续执行, 直到协程执行完毕, 调用final_suspend由于final_suspend返回std::suspend_always{};，协程被挂起而不是销毁</li>
<li>主线程执行完毕, 最后调用handle.destroy();销毁协程</li>
</ol>
<p>执行co_await 时将当前协程交给线程池异步执行, 当前协程切回协程resume的位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadPoolAwaiter</span> &#123;</span><br><span class="line">    ThreadPool&amp; pool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; h)</span> </span>&#123;</span><br><span class="line">        pool.<span class="built_in">enqueue</span>([h] &#123; h.<span class="built_in">resume</span>(); &#125;); <span class="comment">// 提交到线程池</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">co_await</span> ThreadPoolAwaiter&#123;my_thread_pool&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="协程链式调用"><a href="#协程链式调用" class="headerlink" title="协程链式调用"></a>协程链式调用</h4><p>我们想要像函数调用那样实现协程调用, 也是co_awaiter一个协程, 当子协程执行完毕后, 返回给父协程继续执行。</p>
<ol>
<li>这样的子协程是一个类, 需要实现promise_type管理协程生命周期, 也需要实现Awaiter 接受co_await调用</li>
<li>await_suspend函数会传父协程handle，需要把它记住。当子协程执行完毕, 需要在final_suspend()中把父协程恢复。</li>
</ol>
<p>举例, </p>
<ol>
<li>每个协程函数都返回Task类型。执行co_await Task, 会调用Task的await_suspend(), 将父协程设置成子协程的nextjob, 返回当前协程(Task同时是Awaiter和协程), 表示执行当前协程</li>
<li>对于PromiseBase, final_suspend() 返回一个FinalAwaiter.协程销毁后会调用FinalAwaiter的await_suspend(), 执行协程的nextjob，也就是恢复父协程<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">struct</span> <span class="title class_">FinalAwaiter</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> -&gt; <span class="type">bool</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;Promise&gt; handle)</span> <span class="keyword">noexcept</span> -&gt; <span class="type">void</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="built_in">assert</span>(handle.<span class="built_in">done</span>() &amp;&amp; <span class="string">&quot;handle should done here&quot;</span>);</span><br><span class="line">      <span class="keyword">auto</span>&amp; promise = handle.<span class="built_in">promise</span>();</span><br><span class="line">      <span class="comment">// 这一步同时更新了promise.mNextJob==nullptr, 也就是标识task执行完了</span></span><br><span class="line">      <span class="keyword">auto</span> next = promise.mNextJob.<span class="built_in">exchange</span>(<span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">if</span> (next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (promise.<span class="built_in">getState</span>() != <span class="literal">nullptr</span>) [[unlikely]] &#123;</span><br><span class="line">          promise.<span class="built_in">getState</span>()-&gt;<span class="built_in">store</span>(JobState::Final, std::memory_order_release);</span><br><span class="line">          promise.<span class="built_in">getState</span>()-&gt;<span class="built_in">notify_one</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next == &amp;detail::kDetachJob) &#123;</span><br><span class="line">        <span class="keyword">if</span> (promise.<span class="built_in">getState</span>() != <span class="literal">nullptr</span>) [[unlikely]] &#123;</span><br><span class="line">          promise.<span class="built_in">getState</span>()-&gt;<span class="built_in">store</span>(JobState::Final, std::memory_order_release);</span><br><span class="line">          promise.<span class="built_in">getState</span>()-&gt;<span class="built_in">notify_one</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        promise.mThisHandle.<span class="built_in">destroy</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next != &amp;detail::kEmptyJob) &#123;</span><br><span class="line">        <span class="comment">// 把nextjob加入到loop, 由主线程执行(ExeOpt::prefInOne)</span></span><br><span class="line">        Proactor::<span class="built_in">get</span>().<span class="built_in">execute</span>(next, ExeOpt::<span class="built_in">prefInOne</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> -&gt; <span class="type">void</span> </span>&#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PromiseBase</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">initial_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> -&gt; std::suspend_always </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> -&gt; FinalAwaiter </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">unhandled_exception</span><span class="params">()</span> <span class="keyword">noexcept</span> -&gt; <span class="type">void</span> </span>&#123; mExceptionPtr = std::<span class="built_in">current_exception</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">setNextJob</span><span class="params">(WorkerJob* next)</span> <span class="keyword">noexcept</span> -&gt; <span class="type">void</span> </span>&#123; mNextJob = next; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">getNextJob</span><span class="params">()</span> <span class="keyword">noexcept</span> -&gt; std::atomic&lt;WorkerJob*&gt;&amp; </span>&#123; <span class="keyword">return</span> mNextJob; &#125;</span><br><span class="line"></span><br><span class="line">  CoroJob mThisJob&#123;<span class="keyword">this</span>, &amp;CoroJob::run&#125;;</span><br><span class="line">  std::coroutine_handle&lt;&gt; mThisHandle;</span><br><span class="line">  std::atomic&lt;WorkerJob*&gt; mNextJob&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">  std::exception_ptr mExceptionPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> promise_type = Promise&lt;T&gt;;</span><br><span class="line">  <span class="keyword">using</span> coroutine_handle_type = std::coroutine_handle&lt;promise_type&gt;;</span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Task</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Task</span><span class="params">(coroutine_handle_type handle)</span> <span class="keyword">noexcept</span> : mHandle(handle)</span></span><br><span class="line"><span class="function">  &#123;</span></span><br><span class="line">    <span class="built_in">assert</span>(mHandle != <span class="literal">nullptr</span>);</span><br><span class="line">    mHandle.<span class="built_in">promise</span>().<span class="built_in">setCoHandle</span>(mHandle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">AwaiterBase</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> -&gt; <span class="type">bool</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;Promise&gt; handle)</span> <span class="keyword">noexcept</span> -&gt; <span class="type">void</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">// 设置为handle.promise.nextjob</span></span><br><span class="line">      mHandle.<span class="built_in">promise</span>().<span class="built_in">setNextJob</span>(handle.<span class="built_in">promise</span>().<span class="built_in">getThisJob</span>());</span><br><span class="line">      mHandle.<span class="built_in">promise</span>().<span class="built_in">setState</span>(handle.<span class="built_in">promise</span>().<span class="built_in">getState</span>());</span><br><span class="line">        <span class="comment">// 执行当前协程</span></span><br><span class="line">      Proactor::<span class="built_in">get</span>().<span class="built_in">execute</span>(mHandle.<span class="built_in">promise</span>().<span class="built_in">getThisJob</span>(), ExeOpt::<span class="built_in">prefInOne</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    coroutine_handle_type mHandle;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>folly库实现的协程链式调用</p>
<ol>
<li>保存父协程promise.continuation_ &#x3D; continuation;</li>
<li>返回当前task的coro_handle, coro_, 执行当前task</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line"><span class="function">FOLLY_NOINLINE <span class="keyword">auto</span> <span class="title">await_suspend</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    coroutine_handle&lt;Promise&gt; continuation)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(coro_);</span><br><span class="line">  <span class="keyword">auto</span>&amp; promise = coro_.<span class="built_in">promise</span>();</span><br><span class="line"></span><br><span class="line">  promise.continuation_ = continuation;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span>&amp; calleeFrame = promise.<span class="built_in">getAsyncFrame</span>();</span><br><span class="line">  calleeFrame.<span class="built_in">setReturnAddress</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(detail::promiseHasAsyncFrame_v&lt;Promise&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; callerFrame = continuation.<span class="built_in">promise</span>().<span class="built_in">getAsyncFrame</span>();</span><br><span class="line">    folly::<span class="built_in">pushAsyncStackFrameCallerCallee</span>(callerFrame, calleeFrame);</span><br><span class="line">    <span class="keyword">return</span> coro_;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    folly::<span class="built_in">resumeCoroutineWithNewAsyncStackRoot</span>(coro_);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(coro_);</span><br><span class="line">  SCOPE_EXIT &#123;</span><br><span class="line">    std::<span class="built_in">exchange</span>(coro_, &#123;&#125;).<span class="built_in">destroy</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">move</span>(coro_.<span class="built_in">promise</span>().<span class="built_in">result</span>()).<span class="built_in">value</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="协程和异步"><a href="#协程和异步" class="headerlink" title="协程和异步"></a>协程和异步</h4><p>我们可以思考链式协程模式的特点</p>
<ol>
<li>每个协程Task既是一个挂起-恢复的协程任务，也是一个Awaiter。协程的await_suspend会记录父协程, final_suspend恢复父协程。</li>
<li>协程的阻塞任务, 包括申请锁, sleep, IO等都可以封装成一个Awaiter, 这个awaiter可以在suspend的时候挂起，如果需要调用read等阻塞调用，需要创建新线程执行</li>
<li>执行协程的线程会执行一个循环(eventloop)，这个线程用于不会阻塞。这个线程做的事情就是1. 循环遍历，如果有协程挂起并创建新线程执行异步任务，就查看异步任务是否执行完，若执行完恢复该协程的调用。 2. 如果协程全部执行完了, 线程根据链式调用, 恢复该协程父协程的执行。3. 尝试接受新的协程任务</li>
</ol>
<p><strong>协程锁可以通过标志和等待队列实现,</strong></p>
<ol>
<li>尝试申请锁时, 如果锁未被申请, 则持有锁, 协程继续执行</li>
<li>如果锁已被申请, 则将当前协程加入等待队列, 并挂起当前协程</li>
<li>释放锁时，唤醒处于等待队列的一个协程恢复它执行<br>执行协程的线程会执行一个循环，如果无协程可执行（协程全部在挂起），线程则进入下一个循环</li>
</ol>
<p>协程也可以实现类似golang的channel。channel 由一个ringbuffer和reader, writer两个队列组成。</p>
<ol>
<li>reader 进入时, 如果ringbuffer为空，则挂起reader; ringbuffer不为空，则读取ringbuffer中的数, 同时唤醒等待队列的writer</li>
<li>writer写入时，如果ringbuffer满了，则挂起；否则写入并唤醒所有reader; reader被唤醒时，读取writer写入的数据。<br>显然协程的一个核心是《唤醒》的实现，只需要coroutine.resume()即可, 这比线程的唤醒要简单很多。</li>
</ol>
<p>协程可以在await_suspend中调用liburing等异步io函数，然后挂起。同时主线程循环检查liburing的cqe(complete queue entry)，对于完成的IO，唤醒对应的协程继续处理。</p>
<h4 id="有栈协程"><a href="#有栈协程" class="headerlink" title="有栈协程"></a>有栈协程</h4><p>C++20的协程是无栈协程，无栈协程就是一个Task对象，这个task对象可以通过co_await挂起, 并记录当前的状态。等到resume时，可以从当前的状态继续执行。coroutine对象会记录当前协程函数内的局部变量（包括参数）、挂起点等状态。</p>
<p>相比无栈协程，有栈协程更容易理解，在有栈协程中，每个协程函数都相当于给指定线程的任务队列加入一个任务</p>
<ol>
<li>一般来说，每个线程会执行一个loop循环, 该循环从任务队列取出一个协程任务，执行，然后下一个</li>
<li>当协程需要挂起时，会保存当前的上下文，将自己放到等待队列，将挂起的任务提交到异步执行</li>
<li>当异步任务完成后，从等待队列唤醒对应的任务加到执行队列，继续执行。</li>
</ol>
<p>执行有栈协程的线程 相当于操作系统的线程CPU调度，典型的就是golang的协程。golang的GMP 调度模型 就类似操作系统的进程-CPU-调度器。有栈协程不需要固定的对象保存状态，需要挂起协程时就创建栈保存状态，协程继续执行时就清理栈恢复状态。而无栈协程通过coroutine对象来保存状态和管理协程生命周期。无栈协程的状态保存和恢复相比有栈协程性能更高，同时执行流更清晰，有利于编译器的优化。</p>
<p>代码越静态，结果越容易预测，越有利于编译期的优化。</p>
<h3 id="异步编程模型"><a href="#异步编程模型" class="headerlink" title="异步编程模型"></a>异步编程模型</h3><h4 id="SQE-CQE-模型"><a href="#SQE-CQE-模型" class="headerlink" title="SQE&#x2F;CQE 模型"></a>SQE&#x2F;CQE 模型</h4><p>​​SQE（Submission Queue Entry，提交队列项）和 CQE（Completion Queue Entry，完成队列项）​​ 是高性能异步 I&#x2F;O 框架（如 Linux io_uring、SPDK、DPDK）中的核心机制，用于实现高效的 ​​生产者-消费者模型​​。</p>
<p>SQE和CQE 一般是两个环形队列，对于SQE，用户程序是生产者，内核&#x2F;硬件是消费者。对于CQE，内核&#x2F;硬件是生产者，应用程序是消费者。</p>
<ol>
<li>​SQE（任务提交）​​, 应用程序将 I&#x2F;O 请求（如读、写）封装为 SQE，提交到​​提交队列（Submission Queue, SQ）​​，通知硬件或内核处理。</li>
<li>​CQE（完成通知）​​：硬件或内核处理完请求后，生成 CQE 并放入​​完成队列（Completion Queue, CQ）​​，应用程序轮询或异步接收结果。</li>
</ol>
<p>C++ 协程可以很容易的和SQE&#x2F;CQE 模型结合，await_suspend函数将任务加到SQE队列等待执行, 而主线程定期轮询CQE队列，对于CQE中完成的异步任务，主线程会唤醒协程继续执行。</p>
<p>io_uring 的SQE和CQE模型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io_uring.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交队列项（SQE）结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">io_uring_sqe</span> &#123;</span><br><span class="line">    __u8    opcode;     <span class="comment">// 操作类型（如 IORING_OP_READV）</span></span><br><span class="line">    __u64   addr;       <span class="comment">// 数据地址（如缓冲区指针）</span></span><br><span class="line">    __u32   len;        <span class="comment">// 数据长度</span></span><br><span class="line">    __u64   user_data;  <span class="comment">// 用户自定义数据（用于关联请求上下文）</span></span><br><span class="line">    <span class="comment">// ... 其他字段（文件描述符、标志位等）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成队列项（CQE）结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">io_uring_cqe</span> &#123;</span><br><span class="line">    __u64   user_data;  <span class="comment">// 对应 SQE 的 user_data</span></span><br><span class="line">    __s32   res;        <span class="comment">// 操作结果（成功时为字节数，失败时为负的错误码）</span></span><br><span class="line">    __u32   flags;      <span class="comment">// 附加标志</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交请求到 SQ</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io_uring_prep_read</span><span class="params">(<span class="keyword">struct</span> io_uring_sqe *sqe, <span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">unsigned</span> nbytes, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="built_in">io_uring_submit</span>(&amp;ring); <span class="comment">// 提交 SQEs 到内核</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 CQ 获取结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">io_uring_cqe</span> *cqe;</span><br><span class="line"><span class="built_in">io_uring_peek_cqe</span>(&amp;ring, &amp;cqe); <span class="comment">// 非阻塞获取 CQE</span></span><br><span class="line"><span class="built_in">io_uring_cq_advance</span>(&amp;ring, <span class="number">1</span>);  <span class="comment">// 标记 CQE 已处理</span></span><br></pre></td></tr></table></figure>

<p>SPDK 通过SQE&#x2F;CQE模型向nvme ssd驱动提交IO请求</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">spdk_nvme_ns</span> *ns = ...;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">spdk_nvme_qpair</span> *qpair = ...;</span><br><span class="line"><span class="type">char</span> *buffer = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交读请求（SQE）</span></span><br><span class="line"><span class="built_in">spdk_nvme_ns_cmd_read</span>(ns, qpair, buffer, lba, lba_count, </span><br><span class="line">                      completion_cb, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 CQE（回调函数）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">completion_cb</span><span class="params">(<span class="type">void</span> *ctx, <span class="type">const</span> <span class="keyword">struct</span> spdk_nvme_cpl *cpl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">spdk_nvme_cpl_is_error</span>(cpl)) &#123;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DPDK 通过SQE&#x2F;CQE模型向提交网络包</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rte_mbuf</span> *tx_pkts[<span class="number">32</span>];</span><br><span class="line"><span class="comment">// 填充发送包（SQE）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">    tx_pkts[i] = ...; <span class="comment">// 构造数据包</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提交发送请求</span></span><br><span class="line"><span class="type">uint16_t</span> sent = <span class="built_in">rte_eth_tx_burst</span>(port_id, queue_id, tx_pkts, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收完成的数据包（CQE）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rte_mbuf</span> *rx_pkts[<span class="number">32</span>];</span><br><span class="line"><span class="type">uint16_t</span> received = <span class="built_in">rte_eth_rx_burst</span>(port_id, queue_id, rx_pkts, <span class="number">32</span>);</span><br></pre></td></tr></table></figure>

<h4 id="事件通知模型"><a href="#事件通知模型" class="headerlink" title="事件通知模型"></a>事件通知模型</h4><p>事件通知模型不像sqe&#x2F;cqe模型有明确的任务提交队列和任务完成队列，而是通过接收事件来确定是否可读可写。典型的就是linux的epoll。对于读操作，sqe&#x2F;cqe模型只需要提交一个读任务，然后等待完成队列中的读任务完成即可。但对epoll，需要等待读事件触发，才能执行读操作。sqe&#x2F;cqe是一个主动请求等待返回的模型, 而epoll是一个被动等待触发的模型。</p>
<p>mtcp 实现了一个用户态的epoll，</p>
<ol>
<li>通过 DPDK 的轮询模式驱动（Poll Mode Driver, PMD）直接从网卡收取数据包，解析为 TCP 报文。</li>
<li>当收到TCP报文时，会将对应的连接设置成数据可读（EPOLLIN）、可写（EPOLLOUT）或新连接到达（EPOLLACCEPT）事件，并将该事件加入到就绪队列中</li>
<li>应用层通过 mtcp_epoll_wait() 等接口从就绪队列中获取事件，执行回调或进一步处理。</li>
</ol>
<p>协程和事件通知模型结合时，await_suspend可以将操作加入等待队列，而epoll_wait 返回触发的事件时，可以将数据写到指定的buffer，然后通知等待队列里对应的协程继续执行。</p>
<p>可见相比epoll的事件通知模型，协程liburing等sqe&#x2F;cqe 模型更自然的结合, 通过轮询cqe的方式对IO完成的协程继续执行。</p>
<p>DPDK（Data Plane Development Kit）和SPDK（Storage Performance Development Kit）是两款由英特尔发起的开源项目，分别专注于提升网络数据平面和存储I&#x2F;O的性能。DPDK目的是成为用户态网络包处理的标准框架，SPDK则是成为用户态绕过内核操作nvme 协议的块设备IO处理的标准框架。</p>
<p>DPDK​, 包括mTCP, 是一个用户态TCP协议栈。数据包直接从网卡读取，发给用户态组成TCP包。</p>
<ol>
<li>​用户态网络驱动​​。绕过内核协议栈，直接在用户态处理网络包，减少数据拷贝和上下文切换。</li>
<li>​​零拷贝技术​​。通过大页内存（HugePage）和内存池（Memory Pool）减少内存访问开销。</li>
<li>轮询模式​​。使用无锁队列（Ring）和CPU轮询（Poll-mode Driver）避免中断延迟。</li>
<li>​多核扩展​​ 基于线程绑定（CPU affinity）和流水线模型实现高性能多核处理。</li>
</ol>
<p>​​SPDK​，是用户态的NVME设备IO框架。IO数据直接从nvme设备到用户态</p>
<ol>
<li>​用户态NVMe驱动​​ 完全用户态实现NVMe协议，避免内核存储栈的开销。</li>
<li>​异步无锁设计​​ 使用异步I&#x2F;O和事件驱动模型，减少锁竞争。</li>
<li>​​零拷贝访问​​ 通过内存映射（Memory-mapped I&#x2F;O）和直接访问SSD的PRP（Physical Region Page）列表提升效率。</li>
<li>​高并发优化​​ 支持多队列（Multi-queue）和并行I&#x2F;O请求，充分利用NVMe SSD的多核能力。</li>
</ol>
<p>iouring 是linux 内核提供的异步IO接口，相比spdk, 存储层还是会经过内核，走vfs接口, 利用内核的pagecache缓存和块设备抽象。</p>
<p>rdma是远程内存访问，通过支持RDMA的网卡（RNIC）直接读写远程内存，需要专门的RDMA网卡。RDMA可以和dpdk&#x2F;spdk&#x2F;iouring结合，rdma 是针对rdma专用网卡的网络协议、数据收发，而后者侧重描述的是从用户传输层到网卡的通用架构。rdma 侧重于高性能计算存储，dpdk侧重于更通用的tcp服务。</p>
<p>dpdk, spdk, rdma, iouring 采用的模型都是cqe&#x2F;sqe 生产消费模型。C++ 通过以上生态，实现了网络和存储IO的高性能。再加上流行的gpu cuda高性能计算框架，使C++在高性能计算&#x2F;存储&#x2F;网络领域不可替代。</p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/coroutine/" rel="tag">coroutine</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/" rel="tag">cpp</a></li></ul></div><div class="post-nav"><a class="pre" href="/2025/04/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94C++%E5%8F%B3%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/">编程语言——C++右值和右值引用</a><a class="next" href="/2025/04/07/%E5%AD%98%E5%82%A8/%E5%AD%98%E5%82%A8%E2%80%94%E8%B0%88%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">存储——谈存储文件系统</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://larrystd.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>To be a better man.</p><a class="info-icon" href="https://twitter.com/username" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:admin@domain.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/application/">application</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/compute/">compute</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hello/">hello</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/language/">language</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/storage/">storage</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/hello/" style="font-size: 15px;">hello</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/brpc/" style="font-size: 15px;">brpc</a> <a href="/tags/storage/" style="font-size: 15px;">storage</a> <a href="/tags/leveldb/" style="font-size: 15px;">leveldb</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/application/" style="font-size: 15px;">application</a> <a href="/tags/base/" style="font-size: 15px;">base</a> <a href="/tags/language/" style="font-size: 15px;">language</a> <a href="/tags/cpp/" style="font-size: 15px;">cpp</a> <a href="/tags/coroutine/" style="font-size: 15px;">coroutine</a> <a href="/tags/compute/" style="font-size: 15px;">compute</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/07/06/%E5%AD%98%E5%82%A8/brpc(1)%E2%80%94bthread%E5%92%8Cbrpc/">brpc(1)—bthread和brpc</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/03/%E8%AE%A1%E7%AE%97/%E8%AE%A1%E7%AE%97(2)%E2%80%94GPU%E8%AE%A1%E7%AE%97%E5%92%8C%E5%A4%A7%E6%A8%A1%E5%9E%8B/">计算(2)——GPU计算和大模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/27/%E8%AE%A1%E7%AE%97/%E8%AE%A1%E7%AE%97(1)%E2%80%94CPU%E8%AE%A1%E7%AE%97%E5%92%8C%E5%A4%A7%E6%95%B0%E6%8D%AE/">计算(1)——CPU计算和大数据</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94C++%E5%8F%B3%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/">编程语言——C++右值和右值引用</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/20/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94C++%E5%8D%8F%E7%A8%8B%E5%92%8C%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/">编程语言——C++协程和高性能编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/07/%E5%AD%98%E5%82%A8/%E5%AD%98%E5%82%A8%E2%80%94%E8%B0%88%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">存储——谈存储文件系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/15/%E5%AD%98%E5%82%A8/leveldb(2)%E2%80%94%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/">leveldb(2)—线程模型和并发控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/12/%E5%AD%98%E5%82%A8/redis(2)%E2%80%94%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/">redis(2)——网络处理和持久化</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/10/%E5%AD%98%E5%82%A8/redis(1)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">redis(1)——数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/31/%E5%AD%98%E5%82%A8/leveldb(1)%E2%80%94%E6%A6%82%E8%A7%88/">leveldb(1)—概览</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2026 <a href="/." rel="nofollow">Infinity Code.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>