<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Infinity Code | Simplicity is the soul of efficiency.</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Infinity Code</h1><a id="logo" href="/.">Infinity Code</a><p class="description">Simplicity is the soul of efficiency.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"><a href="/2025/01/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(5)%E2%80%94%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/">编程语言(5)—并发编程和函数</a></h1><div class="post-meta">2025-01-03</div><p class="readmore"><a href="/2025/01/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(5)%E2%80%94%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2025/01/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(3)%E2%80%94%E5%8F%98%E9%87%8F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/">编程语言(3)—变量和作用域</a></h1><div class="post-meta">2025-01-01</div><div class="post-content"><p>对于静态语言，类型是编译期确定的。变量在运行期，有创建、初始化、使用、销毁四个生命周期状态。</p></div><p class="readmore"><a href="/2025/01/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(3)%E2%80%94%E5%8F%98%E9%87%8F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2025/01/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(6)%E2%80%94IO%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%93/">编程语言(5)—IO和网络库</a></h1><div class="post-meta">2025-01-01</div><p class="readmore"><a href="/2025/01/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(6)%E2%80%94IO%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%93/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2025/01/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(4)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">编程语言(4)—数据结构和算法</a></h1><div class="post-meta">2025-01-01</div><div class="post-content">数据结构和算法库是程序编写最基础的库之一。字符串是人类语言的记录，是计算机处理的主要对象，因此字符串数据和算法是重中之重。
C和C++由于C语言不提供数据结构和算法库，这里专指C++的STL stand template library。
数据结构vector 是一个动态数组，随机访问时间O(1)，可以快速地在末尾插入或删除元素。
123456789101112131415#include &lt;vector&gt;#include &lt;iostream&gt;int main() &#123;    std::vector&lt;int&gt; vec = &#123;1, 2, 3, 4, 5&#125;;    vec.push_back(6);    for (int val : vec) &#123;        std::cout &lt;&lt; val &lt;&lt; &quot; &quot;;  // 输出：1 2 3 4 5 6    &#125;    std::cout &lt;&lt; std::endl;    std::cout &lt;&lt; vec[2] &lt;&lt; std::endl;  // 访问元素 3    return 0;&#125;

list 是双向链表，能高效插入或删除元素，但不提供随机访问接口
12345678910111213#include &lt;list&gt;#include &lt;iostream&gt;int main() &#123;    std::list&lt;int&gt; lst = &#123;1, 2, 3, 4, 5&#125;;    lst.push_back(6);  // 在末尾插入元素    lst.push_front(0); // 在头部插入元素    for (int val : lst) &#123;        std::cout &lt;&lt; val &lt;&lt; &quot; &quot;;  // 输出：0 1 2 3 4 5 6    &#125;    return 0;&#125;

deque 是双端队列，头部和尾部可以进行高效的插入和删除操作。deque也提供随机访问接口
12345678910111213#include &lt;deque&gt;#include &lt;iostream&gt;int main() &#123;    std::deque&lt;int&gt; deq = &#123;1, 2, 3, 4, 5&#125;;    deq.push_back(6);   // 在尾部添加元素    deq.push_front(0);  // 在头部添加元素    for (int val : deq) &#123;        std::cout &lt;&lt; val &lt;&lt; &quot; &quot;;  // 输出：0 1 2 3 4 5 6    &#125;    return 0;&#125;

set 是一个集合，自动排序且不允许重复元素。unordered_set 是一个不排序的集合，元素根据哈希值存储，允许快速查找和插入。
map 是一个映射，存储键值对（key-value），并根据键进行排序。unordered_map 是一个无序映射，存储键值对，使用哈希表进行存储。
1234567891011#include &lt;unordered_map&gt;#include &lt;iostream&gt;int main() &#123;    std::unordered_map&lt;int, std::string&gt; um = &#123;&#123;1, &quot;one&quot;&#125;, &#123;2, &quot;two&quot;&#125;, &#123;3, &quot;three&quot;&#125;&#125;;    for (const auto&amp; pair : um) &#123;        std::cout &lt;&lt; pair.first &lt;&lt; &quot;: &quot; &lt;&lt; pair.second &lt;&lt; std::endl;    &#125;    return 0;&#125;

迭代器，C++ STL使用迭代器来标识容器中的元素，以及实现容器中元素的访问。迭代器支持*和-&gt;运算符来解引用或访问元素成员变量

随机访问迭代器 (Random Access Iterator)，类似指针，通过加减算数提供随机访问。对应容器std::vector、std::deque、std::array。支持随机访问迭代器作为参数的算法函数，一般也支持指针作为参数。
双向迭代器(Bidirectional Iterator)，允许在容器中向前和向后移动。对应容器std::list、std::set、std::map。

迭代器是使用继承结构组织的，随机访问迭代器也是一种双向迭代器
算法std::sort：对容器中的元素进行排序，默认升序。需要传入随机访问迭代器作为参数
std::sort是不稳定的，std::stable_sort提供稳定排序，即保证相同元素的相对顺序
12345std::vector&lt;int&gt; vec = &#123;4, 2, 9, 1&#125;;std::sort(vec.begin(), vec.end());  // 升序排序std::sort(vec.begin(), vec.end(), [](int a, int b) &#123;  // 降序        return a &gt; b;    &#125;);

std::find：查找容器中的某个元素，返回第一个匹配元素的迭代器。传入双向迭代器即可
1234auto it = std::find(vec.begin(), vec.end(), 2);if (it != vec.end()) &#123;    // 找到了元素&#125;

std::lower_bound，传入排序好的数组，返回第一个大于或等于指定元素的迭代器。std::upper_bound：返回指向已排序数组中第一个大于指定元素的迭代器。
需要传入随机访问迭代器
12auto it = std::lower_bound(vec.begin(), vec.end(), 3);auto it = std::upper_bound(vec.begin(), vec.end(), 3);

std::reverse：反转容器中的元素顺序。
1std::reverse(vec.begin(), vec.end());

std::fill：将容器中的所有元素设置为指定值。
1std::fill(vec.begin(), vec.end(), 0);

std::transform：对容器中的每个元素应用指定的操作。
1std::transform(vec.begin(), vec.end(), vec.begin(), [](int x) &#123; return x * 2; &#125;);

std::copy：将容器中的元素复制到另一个容器。std::swap：交换两个容器的内容。std::move：移动容器的元素，避免复制。
123std::copy(vec, dest);std::swap(vec, dest);std::vector&lt;int&gt; new_vec = std::move(vec);

std::count：统计容器中某个元素出现的次数。std::count_if：统计符合特定条件的元素的数量。
12int count = std::count(vec.begin(), vec.end(), 2);int count = std::count_if(vec.begin(), vec.end(), [](int x) &#123; return x % 2 == 0; &#125;);

std::accumulate：对容器中的元素进行累加。
1int sum = std::accumulate(vec.begin(), vec.end(), 0);

std::min_element：返回容器中最小元素的迭代器。std::max_element：返回容器中最大元素的迭代器。
12auto min_it = std::min_element(vec.begin(), vec.end());auto max_it = std::max_element(vec.begin(), vec.end());

字符串处理函数由于C++兼容C语言，因此支持C风格和C++风格的字符串处理算法。C风格字符串函数参数是指针，C++风格是随机访问迭代器。
C风格的字符串处理函数, 在C++中，执行#include &lt;cstring&gt;，C语言的字符串处理函数作为std namespace的全局函数。
12345678910111213141516171819202122232425262728293031// strcpy(dest, src), strncpy(dest, src, n), 字符串拷贝char src[] = &quot;Hello, World!&quot;;char dest[20];std::strcpy(dest, src);std::strncpy(dest, src, 5);// strcat(str1, str2) 将str2拼接到str1std::strcat(str1, str2); std::strncat(str1, str2, 5);// strlen(str)，返回 C 风格字符串的长度（不包括 \0 终止符）// strcmp(str1, str2), strncmp(str1, str2, n) 如果str1 &gt; str2, 返回大于0std::strcmp(str1, str2)// strchr(str, c)，查找字符c在字符串str中第一次出现的位置。如果找到了，返回指向该字符的指针；如果没找到，返回 nullptr。char* ptr = std::strchr(str, &#x27;o&#x27;);// strstr(str, sub), 查找子字符串sub在字符串str中的第一次出现。如果找到了，返回指向子字符串的指针；如果没找到，返回 nullptr。const char* str = &quot;Hello, World!&quot;;const char* sub = &quot;World&quot;;char* ptr = std::strstr(str, sub);// memset(str, c, n) 按字节为单位对内存初始化char str[20];std::memset(str, &#x27;*&#x27;, 5);  // 将前 5 个字符设置为 &#x27;*&#x27;memcpy(dest, src, n) 从src拷贝n个字节到destchar src[] = &quot;Hello&quot;;char dest[10];std::memcpy(dest, src, 6); 


C++ string是动态字符串，支持的函数
12345678910111213141516171819202122232425262728293031323334353637383940414243// size() 或 length() 获取字符串长度// append(string)，将内容追加std::string str = &quot;Hello&quot;;str.append(&quot;, World!&quot;); // push_back(c)，添加一个字符str.push_back(&#x27;!&#x27;);// insert(index, string), 指定位置插入字符串str.insert(5, &quot;, World&quot;);// erase(index, length), 删除指定位置区间的字符串str.erase(5, 7);  // 从位置 5 开始删除 7 个字符// replace(index, length, newstring), 替换字符串中的指定部分。str.replace(7, 5, &quot;C++&quot;);// resize(size) 改变字符串的大小，如果增加字符则填充，减少字符则截断。str.resize(5);// std::find(string) 查找子字符串首次出现的位置。如果找不到返回 std::string::npos。rfind, 从字符串末尾向前查找字符串size_t pos = str.find(&quot;World&quot;);// find_first_of(),find_last_of()size_t pos = str.find_first_of(&quot;o&quot;);// substr(index, length) 提取子字符串std::string sub = str.substr(7, 5); // compare 字符串比较std::string str1 = &quot;Hello&quot;;std::string str2 = &quot;World&quot;;int result = str1.compare(str2);// stoi(), stol(), stoll() 字符串转为整型int num = std::stoi(str);// to_string()，转为字符串std::string str = std::to_string(num);// c_str(), data() 返回 C 风格字符串（const char*）。const char* cstr = str.c_str();

JAVA数据结构ArrayList，等于C++的vector，动态数组。JAVA的List是一个接口，包括动态数组和链表。
1234567import java.util.ArrayList;ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.add(&quot;Banana&quot;);list.add(&quot;Cherry&quot;);System.out.println(list);  // 输出: [Apple, Banana, Cherry]

LinkedList，双向链表，相当于C++的list
123import java.util.LinkedList;LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();

HashSet, 基于哈希表实现，不保证元素的顺序。
LinkedHashSet, 基于哈希表和链表实现，能够保证元素的插入顺序。
TreeSet, 基于红黑树实现，元素按自然顺序或自定义顺序排列。
HashMap，基于哈希表实现，允许 null 键和值。
LinkedHashMap，基于哈希表和链表实现，保持插入顺序（或访问顺序）
TreeMap，基于红黑树实现，键按自然顺序或自定义顺序排序。
PriorityQueue，基于堆实现的队列，元素按优先级顺序排列
LinkedList 也可以实现 Queue 接口，支持双端队列操作。
123456789import java.util.LinkedList;import java.util.Queue;Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();queue.add(&quot;Apple&quot;);queue.add(&quot;Banana&quot;);queue.add(&quot;Cherry&quot;);System.out.println(queue.poll());  // 输出: Apple（出队）System.out.println(queue);  // 输出: [Banana, Cherry]

算法Arrays.sort() 用于对数组进行排序，数组是基本类型数组int[] arr ，或对象数组new Integer[10]
Collections.sort() 用于对集合（如 List）进行排序
123456789import java.util.*;public class SortExample &#123;    public static void main(String[] args) &#123;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(5, 2, 8, 1, 3));        Collections.sort(list);        System.out.println(list);  // 输出: [1, 2, 3, 5, 8]    &#125;&#125;

Arrays.binarySearch()，数组查找；Collections.binarySearch()在容器查找
123456789import java.util.*;public class BinarySearchExample &#123;    public static void main(String[] args) &#123;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 5, 8));        int index = Collections.binarySearch(list, 5);        System.out.println(index);  // 输出: 3    &#125;&#125;

Arrays.fill(), Collections.fill() 填充
12345public static void main(String[] args) &#123;    List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5));    Collections.fill(list, 10);    System.out.println(list);  // 输出: [10, 10, 10, 10, 10]&#125;

Collections.shuffle() 用于随机打乱 List 中元素的顺序
12345public static void main(String[] args) &#123;    List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5));    Collections.shuffle(list);    System.out.println(list);  // 输出: 随机打乱后的结果&#125;

字符串处理12345678910111213141516171819202122232425262728// 创建String str1 = &quot;Hello&quot;; // 字符串字面量String str2 = new String(&quot;Hello&quot;); // 使用构造函数// length() 获得长度int length = str.length();s.charAt(0)  // 访问字符String sub = s.substring(0, 5);  // 切片String result = s1 + &quot; &quot; + s2;  // 使用 + 拼接StringBuilder sb = new StringBuilder();  // 利用StringBuildersb.append(&quot;Hello&quot;);sb.append(&quot; &quot;);String trimmed = s.trim();  // 去除两端空白字符String s = &quot;Hello, World!&quot;;int index = s.indexOf(&quot;World&quot;);  // 查找子字符串的索引位置String upper = s.toUpperCase();  // 转为大写String formatted = String.format(&quot;My name is %s and I am %d years old.&quot;, name, age);  // 字符串格式化String s = &quot;apple,banana,cherry&quot;;String[] fruits = s.split(&quot;,&quot;);  // 按逗号分割字符串

JAVA的String是不可变的，String 字符串每次拼接都会创建新的对象。
StringBuilder 和 StringBuffer 是用于可变字符串的类。StringBuilder只能用于单线程环境，StringBuffer则是线程安全的。
修改字符串某位置的字符
1234567891011// String 字符串不可修改某位置字符，可以利用stringBuilderStringBuilder sb = new StringBuilder(&quot;Hello&quot;);sb.setCharAt(1, &#x27;a&#x27;);System.out.println(sb.toString());  // 输出: Hallo// 字符数组可以修改某位置字符String str = &quot;Hello&quot;;char[] charArray = str.toCharArray();charArray[1] = &#x27;a&#x27;;String modifiedStr = new String(charArray);System.out.println(modifiedStr);  // 输出: Hallo

Go数据结构golang 用语言关键字提供了容器，不必额外导入包
数组, 固定大小的同一类型的元素。Go 数组的大小在声明时确定并且内容不可更改。
1234var arr [5]int // 定义一个长度为 5 的整型数组arr[0] = 1arr[1] = 2fmt.Println(arr) // 输出: [1 2 0 0 0]

切片slice，动态数组。[]byte表示动态字符串。
12345// 创建切片slice := []int&#123;1, 2, 3, 4, 5&#125;// 添加元素slice = append(slice, 6)

map，哈希表实现的容器，允许通过键来快速查找和存储值，无序
123456myMap := map[string]int&#123;    &quot;apple&quot;:  5,    &quot;banana&quot;: 3,&#125;// 插入或更新元素myMap[&quot;orange&quot;] = 7

链表，使用container&#x2F;list
12345678910111213141516package mainimport (    &quot;container/list&quot;    &quot;fmt&quot;)func main() &#123;    l := list.New()    l.PushBack(1) // 在链表尾部插入    l.PushFront(0) // 在链表头部插入    for e := l.Front(); e != nil; e = e.Next() &#123;        fmt.Println(e.Value) // 输出: 0 1    &#125;&#125;

channel，channel可认为是一个线程安全的协程间消息&#x2F;任务队列
算法排序，import “sort”标准库
123456789101112131415161718192021222324252627282930313233package mainimport (	&quot;sort&quot;)func main() &#123;	numbers := []int&#123;5, 2, 9, 1, 5, 6&#125;	sort.Ints(numbers) // 排序，可以选择Ints, Strings, Stable等&#125;// 自定义类型排序type Person struct &#123;	Name string	Age  int&#125;type ByAge []Personfunc (a ByAge) Len() int           &#123; return len(a) &#125;func (a ByAge) Less(i, j int) bool &#123; return a[i].Age &lt; a[j].Age &#125;func (a ByAge) Swap(i, j int)      &#123; a[i], a[j] = a[j], a[i] &#125;func main() &#123;	people := []Person&#123;		&#123;&quot;Alice&quot;, 25&#125;,		&#123;&quot;Bob&quot;, 20&#125;,		&#123;&quot;Charlie&quot;, 30&#125;,	&#125;	sort.Sort(ByAge(people)) // 排序&#125;

字符串处理函数Go中，string是不可变的 UTF-8 编码字符串, 无法原地修改字符串（编译失败）。[]byte是字符序列切片，可原地修改字符串。
12345s := &quot;Hello, World!&quot;b := []byte(s) // 将 string 转换为 []byteb := []byte&#123;72, 101, 108, 108, 111&#125;s := string(b) // 将 []byte 转换为 string


字符串处理
1234567891011121314151617181920212223str := &quot;Hello&quot;len(str)  // 返回长度str[1]  // 根据索引查看字符str1 := &quot;Hello&quot;str2 := &quot;World&quot;result := str1 + &quot;, &quot; + str2  // + 拼接字符串strings.Index(str, &quot;World&quot;)  // 查找字符串strings.Contains(str, &quot;World&quot;)strings.Split(str, &quot;,&quot;)  // 字符串分割，返回字符串数组strings.TrimSpace(str)  // 去掉两侧空白strings.ToUpper(str)  // 字符串大小写strings.ToLower(str)strings.HasPrefix(str, &quot;go&quot;)  // 字符串前后缀strings.HasSuffix(str, &quot;.org&quot;)result := fmt.Sprintf(&quot;Name: %s, Age: %d&quot;, name, age) // 格式化生成字符串strconv.Atoi(numStr) // 字符串转整数


Python数据结构列表，动态数组。和go一样，python列表支持切片。
123my_list = [1, 2, 3, 4, 5]my_list[0] = 10my_list.append(6)

元组Tuple，不可变，只可被访问
12my_tuple = (1, 2, 3)a, b, c = my_tuple

字典dict, 无序（Python 3.7 及以上版本中插入有序）、键值对、键唯一
12my_dict = &#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25&#125;my_dict[&quot;age&quot;] = 30

集合set，无序、不重复。
12my_set = &#123;1, 2, 3, 4, 5&#125;my_set.add(6)

有序字典, 保留键值对插入顺序
12345from collections import OrderedDictordered_dict = OrderedDict()ordered_dict[&quot;a&quot;] = 1ordered_dict[&quot;b&quot;] = 2

算法排序
sorted(iterable, key&#x3D;None, reverse&#x3D;False), 返回一个新的排序列表，不改变原列表。
123456nums = [5, 2, 9, 1]print(sorted(nums))  # 升序: [1, 2, 5, 9]print(sorted(nums, reverse=True))  # 降序: [9, 5, 2, 1]words = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]print(sorted(words, key=len))  # 按字符串长度排序: [&#x27;apple&#x27;, &#x27;cherry&#x27;, &#x27;banana&#x27;]

list.sort(), 原地排序，直接修改列表
12nums = [5, 2, 9, 1]nums.sort()

字典排序
123my_dict = &#123;&quot;b&quot;: 2, &quot;a&quot;: 1, &quot;c&quot;: 3&#125;sorted_keys = sorted(my_dict)  # 按键排序sorted_items = sorted(my_dict.items(), key=lambda item: item[1])  # 按值排序

字符串处理12345678910111213s = &quot;Hello&quot;len(s)s[1]s[-1]s[1:3]s + &quot; &quot;  # 拼接print(f&quot;My name is &#123;name&#125; and I am &#123;age&#125; years old.&quot;)  # 格式化输出, python3支持s.upper()，s.lower()s.strip()  # 去除空格s.find(&quot;World&quot;)s.replace(&quot;World&quot;, &quot;Python&quot;)s.split(&quot;,&quot;)

对于python2, 还有个编码的问题。处理办法是，对于u开头的字符串或者unicode类型的字符串，都使用encode(“utf-8”) 编码为str类型后，再使用。
1234567# coding=utf-8unicode_str = u&quot;中文&quot;  # Unicode 字符串byte_str = &quot;byte&quot;  # 字节字符串print(type(unicode_str))  # &lt;type &#x27;unicode&#x27;&gt;print(type(byte_str))  # &lt;type &#x27;str&#x27;&gt;print(type(unicode_str.encode(&quot;utf-8&quot;)))  # &lt;type &#x27;str&#x27;&gt;

</div><p class="readmore"><a href="/2025/01/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(4)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2025/01/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(2)%E2%80%94%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/">编程语言(2)—类型和运算符</a></h1><div class="post-meta">2025-01-01</div><div class="post-content"><p>程序&#x3D;数据+计算。类型确定了数据的定义、数据支持的计算。是程序的基础。</p>
<p>概要介绍C、C++、JAVA、Go、Python的数据类型和运算符。</p></div><p class="readmore"><a href="/2025/01/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(2)%E2%80%94%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2025/01/01/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0/">静态变量和函数</a></h1><div class="post-meta">2025-01-01</div><div class="post-content"><p>简谈编程语言中的静态变量和函数</p></div><p class="readmore"><a href="/2025/01/01/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2025/01/01/%E7%BC%93%E5%AD%98/">缓存</a></h1><div class="post-meta">2025-01-01</div><div class="post-content"><p>缓存存放的是临时数据，相比主存，缓存往往速度更快，容量更小。</p>
<p>缓存往往是多级的，由内而外，cpu cache -&gt; 内存 -&gt; ssd -&gt; hdd（单机） -&gt; 服务器&#x2F;多节点&#x2F;oss&#x2F;nas等</p>
<p><strong>只要有缓存就会有一致性问题</strong></p></div><p class="readmore"><a href="/2025/01/01/%E7%BC%93%E5%AD%98/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2025/01/01/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E8%A7%88(2)%E2%80%94%E5%86%85%E5%AD%98%E5%92%8CIO%E7%BD%91%E7%BB%9C/">linux操作系统总览(2)——内存管理、文件系统、网络管理</a></h1><div class="post-meta">2025-01-01</div><div class="post-content"><p>linux操作系统大致可分为进程管理、进程协调、内存管理、文件系统、网络管理等五大部分。本文讲述内存管理、文件系统、IO&#x2F;网络管理。</p></div><p class="readmore"><a href="/2025/01/01/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E8%A7%88(2)%E2%80%94%E5%86%85%E5%AD%98%E5%92%8CIO%E7%BD%91%E7%BB%9C/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2025/01/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(1)%E2%80%94%E6%A6%82%E8%A7%88/">编程语言(1)—概览</a></h1><div class="post-meta">2025-01-01</div><div class="post-content"><p>简谈C、C++、JAVA、Go、Python、Rust编程语言</p></div><p class="readmore"><a href="/2025/01/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(1)%E2%80%94%E6%A6%82%E8%A7%88/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2024/12/31/%E5%9D%97%E5%AD%98%E5%82%A8%E3%80%81%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%92%8C%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/">块存储、对象存储和文件存储</a></h1><div class="post-meta">2024-12-31</div><div class="post-content"><p>块存储、对象存储、文件存储是云计算云存储的概念，我想基于云存储，但也不限于云存储，谈谈自己的想法。</p></div><p class="readmore"><a href="/2024/12/31/%E5%9D%97%E5%AD%98%E5%82%A8%E3%80%81%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%92%8C%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/">阅读全文</a></p></div><nav class="page-navigator"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a></nav><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML" async></script></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>To be a better man.</p><a class="info-icon" href="venray.kong@outlook.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/larrystd" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/application/">application</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/base/">base</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hello/">hello</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/multi-machine/">multi-machine</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/single-machine/">single-machine</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/hello/" style="font-size: 15px;">hello</a> <a href="/tags/single-machine/" style="font-size: 15px;">single-machine</a> <a href="/tags/storage/" style="font-size: 15px;">storage</a> <a href="/tags/application/" style="font-size: 15px;">application</a> <a href="/tags/base/" style="font-size: 15px;">base</a> <a href="/tags/os/" style="font-size: 15px;">os</a> <a href="/tags/language/" style="font-size: 15px;">language</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/01/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(5)%E2%80%94%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/">编程语言(5)—并发编程和函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(3)%E2%80%94%E5%8F%98%E9%87%8F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/">编程语言(3)—变量和作用域</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(6)%E2%80%94IO%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%93/">编程语言(5)—IO和网络库</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(4)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">编程语言(4)—数据结构和算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(2)%E2%80%94%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/">编程语言(2)—类型和运算符</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/01/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0/">静态变量和函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/01/%E7%BC%93%E5%AD%98/">缓存</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/01/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E8%A7%88(2)%E2%80%94%E5%86%85%E5%AD%98%E5%92%8CIO%E7%BD%91%E7%BB%9C/">linux操作系统总览(2)——内存管理、文件系统、网络管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(1)%E2%80%94%E6%A6%82%E8%A7%88/">编程语言(1)—概览</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/12/31/%E5%9D%97%E5%AD%98%E5%82%A8%E3%80%81%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%92%8C%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/">块存储、对象存储和文件存储</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="todo" target="_blank">todo</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Infinity Code.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>