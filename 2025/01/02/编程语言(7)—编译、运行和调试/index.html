<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>编程语言(7)—编译、运行和调试 | Infinity Code</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">编程语言(7)—编译、运行和调试</h1><a id="logo" href="/.">Infinity Code</a><p class="description">Simplicity is the soul of efficiency.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">编程语言(7)—编译、运行和调试</h1><div class="post-meta">创建: 2025-01-02<span> | 更新: 2025-01-11</span><span> | </span><category class="name"></category><span class="category"><a href="/categories/base/">base</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 本文共 4.5k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 阅读需要 18</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E5%92%8CC"><span class="toc-number">1.</span> <span class="toc-text">C语言和C++</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91"><span class="toc-number">1.1.</span> <span class="toc-text">编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cmake-%E6%9E%84%E5%BB%BA%E8%AF%AD%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">cmake 构建语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">1.3.</span> <span class="toc-text">单元测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%A3%80%E6%9F%A5%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">1.4.</span> <span class="toc-text">静态检查和格式化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8"><span class="toc-number">1.5.</span> <span class="toc-text">自动补全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.</span> <span class="toc-text">日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">1.7.</span> <span class="toc-text">调试工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">1.8.</span> <span class="toc-text">进程运行时调试工具</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA"><span class="toc-number">2.</span> <span class="toc-text">JAVA</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JAVA%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C"><span class="toc-number">2.1.</span> <span class="toc-text">JAVA编译和运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-number">2.2.</span> <span class="toc-text">调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">2.3.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go"><span class="toc-number">3.</span> <span class="toc-text">Go</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91-1"><span class="toc-number">3.1.</span> <span class="toc-text">编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95-1"><span class="toc-number">3.2.</span> <span class="toc-text">调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5"><span class="toc-number">3.3.</span> <span class="toc-text">静态代码检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-1"><span class="toc-number">3.4.</span> <span class="toc-text">单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python"><span class="toc-number">4.</span> <span class="toc-text">Python</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C"><span class="toc-number">4.1.</span> <span class="toc-text">编译和运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95-2"><span class="toc-number">4.2.</span> <span class="toc-text">调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%A3%80%E6%9F%A5"><span class="toc-number">4.3.</span> <span class="toc-text">静态检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-2"><span class="toc-number">4.4.</span> <span class="toc-text">单元测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97-1"><span class="toc-number">4.5.</span> <span class="toc-text">日志</span></a></li></ol></li></ol></div></div><div class="post-content"><p>写完了代码第一件事是编译，编译失败只能根据编译器通知修改代码；编译通过了第二件事是跑UT，UT不过需要进行调试。调试包括debug和release包的调试，线上进程的运行问题有时候也需要调试，调试的主要方式是调试工具和日志（包括print大法）。为了发现问题，有时候还需要添加报警日志。</p>
<p>提高代码的健壮性，编译器、静态检查和格式化工具、调试、单元测试、日志等是开发必不可少的</p>
<span id="more"></span> 

<h3 id="C语言和C"><a href="#C语言和C" class="headerlink" title="C语言和C++"></a>C语言和C++</h3><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>为什么需要编译？</p>
<ol>
<li>计算方面，汇编代码基本可以等同于机器码。汇编语言和机器码是一行一行指令执行，高级语言的会抽象出来if-else条件执行&#x2F;while循环执行和函数执行模块，编译需要把这些模块转化成一行一行的指令；不同cpu提供的指令和寄存器不同，因而编译器的目标指令也不同（其他硬件需要和cpu兼容，一般程序只需要操纵cpu就可以同时操纵内存、磁盘、网卡等硬件）；另外，由操作系统实现中断、上下文切换等计算单元（不需要用户程序实现），也需要编译器把它们打包到编译后的二进制文件中。</li>
<li>数据方面，汇编语言没有类型概念，需要手动指定寄存器和内存物理地址传输数据，数据交换一般是cpu字长对齐的（64位cpu8字节对齐）；高级语言使用类型来确定数据内存分配大小，使用变量维护某一块内存区域，需要编译器记录类型变量的地址，使用变量转化为从某寄存器或内存地址拿数据的指令，动态内存转化为执行从空闲内存拿内存的指令。</li>
</ol>
<p>编译把.cpp 转化为 .o文件。对于多.cpp文件或使用到动态&#x2F;静态库的文件（几乎所有.cpp都会使用到库文件，例如glibc），需要使用链接把多个.o文件链接成一个二进制文件。链接期间还会链接跨文件共享的外部变量&#x2F;全局变量。</p>
<p>C语言和C++一般公用编译器，常用的编译器有两个，gcc和clang&#x2F;llvm。常见的gcc编译指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># 编译指令</span><br><span class="line">g++ -c file.cpp  # 只编译</span><br><span class="line">g++ file.cpp -o program  # 编译链接</span><br><span class="line">g++ file1.cpp file2.cpp -o program  # 多文件编译</span><br><span class="line"></span><br><span class="line"># 编译优化选项</span><br><span class="line">-O0  # 不进行优化（默认）。</span><br><span class="line">-O1  # 基础优化，平衡编译速度和运行效率。</span><br><span class="line">-O2  # 更高的优化级别，提高性能。</span><br><span class="line">-O3  # 最高优化级别，可能增加编译时间和可执行文件体积。</span><br><span class="line">-Os  # 优化以减小可执行文件的大小。</span><br><span class="line"></span><br><span class="line"># 调试选项</span><br><span class="line">-g  # 生成调试信息，用于调试器（如 gdb）。</span><br><span class="line">-ggdb  # 为 GNU 调试器生成更详细的调试信息。</span><br><span class="line"></span><br><span class="line"># C++ 标准选项</span><br><span class="line">-std=c++98  # 使用 C++98 标准。</span><br><span class="line">-std=c++11  # 使用 C++11 标准。</span><br><span class="line">-std=c++14  # 使用 C++14 标准。</span><br><span class="line">-std=c++17  # 使用 C++17 标准。</span><br><span class="line">-std=c++20  # 使用 C++20 标准。</span><br><span class="line"></span><br><span class="line"># 警告选项</span><br><span class="line">-Wall  # 启用大多数常见的警告。</span><br><span class="line">-Wextra  # 启用额外的警告。</span><br><span class="line">-Werror  # 将警告视为错误。</span><br><span class="line">-pedantic  # 强制严格遵循标准。</span><br><span class="line"></span><br><span class="line"># 链接选项</span><br><span class="line">-l  # 指定链接库。</span><br><span class="line">-L  # 指定库文件搜索路径。</span><br><span class="line">-I  # 指定头文件搜索路径。</span><br><span class="line">g++ file.cpp -o program -lm -L/usr/lib -I/usr/include</span><br><span class="line"></span><br><span class="line"># 生成汇编代码</span><br><span class="line">g++ -S file.cpp -o file.s</span><br><span class="line"></span><br><span class="line"># 定义宏</span><br><span class="line">g++ -DDEBUG file.cpp -o program</span><br><span class="line"></span><br><span class="line"># 生成动态库 </span><br><span class="line">g++ -fPIC -c file1.cpp file2.cpp  # -fPIC 生成位置无关代码</span><br><span class="line">g++ -shared -o libmylib.so file1.o file2.o  # -shared 指定生成动态库。</span><br><span class="line">g++ main.cpp -L. -lmylib -o program</span><br></pre></td></tr></table></figure>

<p>C&#x2F;C++可以使用Makefile&#x2F;CMake来组织编译，例如makefile</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 变量定义</span><br><span class="line">CC = g++</span><br><span class="line">CFLAGS = -Wall -g</span><br><span class="line">OBJ = main.o utils.o</span><br><span class="line">TARGET = program</span><br><span class="line"></span><br><span class="line"># 规则</span><br><span class="line">$(TARGET): $(OBJ)</span><br><span class="line">	$(CC) $(CFLAGS) -o $@ $^</span><br><span class="line"></span><br><span class="line">main.o: main.cpp utils.h</span><br><span class="line">	$(CC) $(CFLAGS) -c $&lt;</span><br><span class="line"></span><br><span class="line">utils.o: utils.cpp utils.h</span><br><span class="line">	$(CC) $(CFLAGS) -c $&lt;</span><br><span class="line"></span><br><span class="line"># 伪目标</span><br><span class="line">clean:</span><br><span class="line">	rm -rf $(OBJ) $(TARGET)</span><br><span class="line"></span><br><span class="line"># $@ 当前目标的名字。</span><br><span class="line"># $&lt; 第一个依赖文件。</span><br><span class="line"># $^ 所有依赖文件。</span><br><span class="line"></span><br><span class="line">make  # 构建目标</span><br><span class="line">make clean # 清理构建文件</span><br></pre></td></tr></table></figure>

<p>CMake能自动生成 Makefile 或其他构建系统文件(如 Ninja 或 Visual Studio 项目文件)</p>
<p>makefile和cmake语法都比较复杂, google提供的ninjia和bazel 相对简单的构建工具.</p>
<h4 id="cmake-构建语法"><a href="#cmake-构建语法" class="headerlink" title="cmake 构建语法"></a>cmake 构建语法</h4><p>基本命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CMake 最低版本要求</span></span><br><span class="line">cmake_minimum_required(VERSION 3.10)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义项目名称和语言</span></span><br><span class="line">project(MyProject VERSION 1.0 LANGUAGES C CXX)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add_executable 添加可执行文件</span></span><br><span class="line">add_executable(myapp main.cpp)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add_library 添加库</span></span><br><span class="line">add_library(mylibrary STATIC lib.cpp)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">target_link_libraries 将库链接到目标</span></span><br><span class="line">target_link_libraries(myapp mylibrary)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">include_directories为编译器添加头文件搜索路径。</span></span><br><span class="line"><span class="meta prompt_">include_directories($</span><span class="language-bash">&#123;CMAKE_SOURCE_DIR&#125;/include)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add_dependencies 控制目标之间的构建顺序，构建顺序</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add_dependencies(&lt;target&gt; &lt;depend1&gt; &lt;depend2&gt; ...)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">set</span> 设置变量值</span></span><br><span class="line">set(MY_VAR &quot;Hello&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">message 打印信息，支持不同的输出级别</span></span><br><span class="line">message(STATUS &quot;This is a status message.&quot;)</span><br><span class="line">message(WARNING &quot;This is a warning message.&quot;)</span><br><span class="line">message(ERROR &quot;This is an error message.&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">if</span>()判断条件</span></span><br><span class="line">if(MY_VAR STREQUAL &quot;Hello&quot;)</span><br><span class="line">  message(STATUS &quot;Hello&quot;)</span><br><span class="line">elseif(MY_VAR STREQUAL &quot;World&quot;)</span><br><span class="line">  message(STATUS &quot;World&quot;)</span><br><span class="line">else()</span><br><span class="line">  message(STATUS &quot;Something else&quot;)</span><br><span class="line">endif()</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">find_package 查找外部库或软件包</span></span><br><span class="line">find_package(OpenGL REQUIRED)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">find_program 搜索指定的可执行程序，并将其路径存储到指定的变量中。HINTS优先查找的路径</span></span><br><span class="line">set(BUSTUB_CLANG_SEARCH_PATH &quot;/usr/local/bin&quot; &quot;/usr/bin&quot; &quot;/usr/local/opt/llvm/bin&quot;)</span><br><span class="line">find_program(CLANG_FORMAT_BIN</span><br><span class="line">        NAMES clang-format clang-format-14</span><br><span class="line">        HINTS $&#123;BUSTUB_CLANG_SEARCH_PATH&#125;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">option 定义布尔选项，通常用于启用或禁用功能</span></span><br><span class="line">option(MY_FEATURE &quot;Enable MyFeature&quot; ON)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install 指定安装规则</span></span><br><span class="line">install(TARGETS myapp DESTINATION bin)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CMake 在父目录中执行 add_subdirectory() 时，CMake 会进入子目录 &lt;source_dir&gt;，并寻找子目录中的 CMakeLists.txt 文件</span></span><br><span class="line">add_subdirectory()</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cmake常用变量</span></span><br><span class="line">CMAKE_SOURCE_DIR  # 项目源代码的根目录</span><br><span class="line">CMAKE_BINARY_DIR  # 构建目录</span><br><span class="line">CMAKE_CURRENT_SOURCE_DIR  # 当前 CMake 脚本所在目录。</span><br><span class="line">CMAKE_CURRENT_BINARY_DIR  # 当前 CMake 构建目录。</span><br><span class="line">CMAKE_CXX_COMPILER  # C++ 编译器。</span><br><span class="line">CMAKE_BUILD_TYPE  # 构建类型（如 Debug, Release）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>cmake -DCMAKE_BUILD_TYPE&#x3D;Debug ..</p>
<p>命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">STREQUAL </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">STREQUAL 用于比较两个字符串是否相等，区分大小写</span></span><br><span class="line"></span><br><span class="line">EXISTS </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">逻辑判断命令，用于检查某个文件或目录是否存在</span></span><br><span class="line"></span><br><span class="line">file</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file(&lt;operation&gt; &lt;arguments&gt;...)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file(READ <span class="string">&quot;&lt;file_path&gt;&quot;</span> &lt;variable_name&gt;) 读取文件内容，保存到变量</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file(TO_CMAKE_PATH) 将输入路径转换为 CMake 使用的标准路径格式</span></span><br><span class="line"></span><br><span class="line">enable_testing()</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用 CTest 功能，CMake 脚本中使用 add_test() 来定义测试用例，并通过 ctest 命令执行测试。</span></span><br><span class="line"></span><br><span class="line">string()</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">string(&lt;COMMAND&gt; &lt;ARGUMENTS&gt;) 字符串处理函数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">string(CONCAT &lt;VAR&gt; &lt;STRING1&gt; &lt;STRING2&gt; ...)  将多个字符串连接成一个字符串，并将结果存储到变量</span></span><br><span class="line"></span><br><span class="line">add_custom_target </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行命令，例如执行clang-tidy</span></span><br><span class="line">add_custom_target(format $&#123;BUSTUB_BUILD_SUPPORT_DIR&#125;/run_clang_format.py</span><br><span class="line">        $&#123;CLANG_FORMAT_BIN&#125;</span><br><span class="line">        $&#123;BUSTUB_BUILD_SUPPORT_DIR&#125;/clang_format_exclusions.txt</span><br><span class="line">        --source_dirs</span><br><span class="line">        $&#123;BUSTUB_FORMAT_DIRS&#125;</span><br><span class="line">        --fix</span><br><span class="line">        --quiet</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gtest_discover_tests</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gtest_discover_tests 是 CMake 中与gtest集成的测试自动发现和注册</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 CMake 查找 Google Test</span></span><br><span class="line">find_package(GTest REQUIRED)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加 Google Test 测试目标</span></span><br><span class="line">add_executable(my_test_target test_case1.cpp test_case2.cpp)</span><br><span class="line">target_link_libraries(my_test_target GTest::GTest GTest::GMock)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 gtest_discover_tests 自动发现测试</span></span><br><span class="line">gtest_discover_tests(my_test_target)</span><br></pre></td></tr></table></figure>

<p>生成表达式，生成表达式用 $&lt;&gt; 来表示</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">$&lt;TARGET_OBJECTS:target&gt; 用于获取一个目标的所有对象文件，常用于链接库</span></span><br><span class="line">add_library(</span><br><span class="line">  bustub_recovery</span><br><span class="line">  OBJECT</span><br><span class="line">  log_manager.cpp)</span><br><span class="line"></span><br><span class="line">set(ALL_OBJECT_FILES</span><br><span class="line"><span class="meta prompt_">  $</span><span class="language-bash">&#123;ALL_OBJECT_FILES&#125; $&lt;TARGET_OBJECTS:bustub_recovery&gt;</span></span><br><span class="line">  PARENT_SCOPE)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PARENT_SCOPE，将变量值传到父作用域</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">$&lt;BUILD_INTERFACE:path&gt; 指定在构建时使用的路径或选项，通常与 $&lt;INSTALL_INTERFACE&gt; 配合使用，指定在安装时使用的路径。</span></span><br><span class="line">target_include_directories(mylib</span><br><span class="line">    PUBLIC</span><br><span class="line">        $&lt;BUILD_INTERFACE:$&#123;CMAKE_SOURCE_DIR&#125;/include&gt;</span><br><span class="line">        $&lt;INSTALL_INTERFACE:$&#123;CMAKE_INSTALL_PREFIX&#125;/include&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>




<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>google 的gtest库是广泛使用的单元测试框架，本地mock可以使用gmock。</p>
<h4 id="静态检查和格式化"><a href="#静态检查和格式化" class="headerlink" title="静态检查和格式化"></a>静态检查和格式化</h4><p>Clang-Tidy 是一个基于 Clang 的 C++ 静态分析工具，用于执行代码检查、风格检测和代码优化。Clang-Tidy配置文件通常位于项目的根目录，名为 .clang-tidy</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Checks:          &#x27;*, -clang-analyzer-*&#x27;</span><br><span class="line">WarningsAsErrors: &#x27;true&#x27;</span><br><span class="line">HeaderFilterRegex: &#x27;.*&#x27;</span><br><span class="line">FormatStyle:     file</span><br></pre></td></tr></table></figure>


<p>Clang-Format 用于格式化 C++ 代码，并且支持根据 .clang-format 配置文件自定义格式化规则。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clang-format -i &lt;your-file.cpp&gt;</span><br><span class="line"></span><br><span class="line"># 指定风格</span><br><span class="line">clang-format -i -style=google &lt;file&gt;</span><br></pre></td></tr></table></figure>

<p>Valgrind 内存动态检查工具，可以检查内存泄漏、内存泄漏，未初始化内存访问等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 检查内存泄漏</span><br><span class="line">valgrind --leak-check=full ./your_program</span><br></pre></td></tr></table></figure>

<h4 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h4><p>使用clangd实现自动补全，命令行安装<code>sudo apt-get install clangd-10</code></p>
<p>cmake启用CMAKE_EXPORT_COMPILE_COMMANDS，会在build目录生成compile_commands.json 文件</p>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>编码使用的printf 也是一种简单的日志调试，根据输出看预期是否正确。C++日志库也可以选择google的glog。</p>
<h4 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h4><p>gdb调试普通程序，需要对普通程序编译加-g选项，也就是debug编译。</p>
<p>gdb调试命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># 运行调试器</span><br><span class="line">run</span><br><span class="line">run arg1 arg2</span><br><span class="line"></span><br><span class="line"># 设置断点</span><br><span class="line">break main</span><br><span class="line">break 10</span><br><span class="line">break 10</span><br><span class="line">break 10 if x == 5  # 条件断点</span><br><span class="line"></span><br><span class="line"># 删除断点</span><br><span class="line">delete</span><br><span class="line">delete 1</span><br><span class="line"></span><br><span class="line"># 显示断点</span><br><span class="line">info breakpoints</span><br><span class="line">info breakpoint 1</span><br><span class="line"></span><br><span class="line"># 启用和关闭断点</span><br><span class="line">enable 2</span><br><span class="line">disable 2</span><br><span class="line"></span><br><span class="line"># 断点继续执行</span><br><span class="line">continue</span><br><span class="line"></span><br><span class="line"># 单步执行</span><br><span class="line">step  # 进入函数内部执行</span><br><span class="line">next  # 会跳过函数调用</span><br><span class="line">finish  # 运行直到当前函数执行结束</span><br><span class="line"></span><br><span class="line"># 查看线程堆栈</span><br><span class="line">backtrace</span><br><span class="line">frame 1  # 切换栈</span><br><span class="line">up  # 切换到当前栈帧的上一层，即父函数的栈帧</span><br><span class="line">down  # 切换到当前栈帧的下一层，即子函数的栈帧</span><br><span class="line"></span><br><span class="line"># 查看变量值</span><br><span class="line">print x</span><br><span class="line">print my_struct.field</span><br><span class="line">print my_array[2]</span><br><span class="line"></span><br><span class="line"># 修改变量值</span><br><span class="line">set variable x = 10</span><br><span class="line"></span><br><span class="line"># 查看指定内存地址内容</span><br><span class="line">x/4xw &amp;x</span><br></pre></td></tr></table></figure>

<p>gdb多线程调试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 显示线程</span><br><span class="line">info threads</span><br><span class="line"></span><br><span class="line"># 切换线程</span><br><span class="line">thread 2</span><br><span class="line"></span><br><span class="line"># 查看线程栈</span><br><span class="line">backtrace</span><br><span class="line"></span><br><span class="line"># 打印所有线程堆栈</span><br><span class="line">thread apply all backtrace</span><br><span class="line"></span><br><span class="line"># 打印所有线程堆栈到文件</span><br><span class="line">set logging on</span><br><span class="line">set logging file &lt;filename&gt;  # 执行这两行命令，后面gdb会把结果输出到文件</span><br><span class="line">info threads</span><br><span class="line">thread apply all backtrace</span><br></pre></td></tr></table></figure>

<p>对于release 编译的调试，需要等进程运行产生core后，结合core对二进制文件进行调试。调试命令<code>gdb &lt;二进制文件&gt; &lt;core_file&gt;</code>，core文件和二进制文件必须对应，一般来说需要保证core是调试的二进制文件生成的。</p>
<p>配置linux系统生成core文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c</span><br><span class="line">ulimit -c unlimited</span><br><span class="line"># 设置将 core 文件保存在 /tmp/ 目录，并包括程序的名称 (%e) 和进程 ID (%p) 作为文件名。</span><br><span class="line">echo &quot;/tmp/core.%e.%p&quot; &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure>

<p>core文件的调试只能查看进程崩溃时的状态，以下是主要使用的命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 查看进程崩溃时的函数调用栈</span><br><span class="line">backtrace</span><br><span class="line">// 查看当前线程的栈帧和寄存器状态</span><br><span class="line">info locals</span><br><span class="line">info registers</span><br><span class="line"></span><br><span class="line"># 打印所有线程堆栈到文件</span><br><span class="line">set logging on</span><br><span class="line">set logging file &lt;filename&gt;  # 执行这两行命令，后面gdb会把结果输出到文件</span><br><span class="line">info threads</span><br><span class="line">thread apply all backtrace</span><br></pre></td></tr></table></figure>

<p>gdb 可以通过<code>gdb attach pid</code>附加到进程，执行命令后，gdb会附加到目标进程，并暂停目标进程的执行，不要在线上使用！</p>
<h4 id="进程运行时调试工具"><a href="#进程运行时调试工具" class="headerlink" title="进程运行时调试工具"></a>进程运行时调试工具</h4><p>pstack 打印正在运行进程的堆栈信息，strace打印系统调用信息。多次执行pstack和strace可以得到执行慢的调用栈、系统调用等</p>
<p>perf 是linux内核提供的性能排查工具。可进行函数级和指令级的性能瓶颈查找。</p>
<h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><h4 id="JAVA编译和运行"><a href="#JAVA编译和运行" class="headerlink" title="JAVA编译和运行"></a>JAVA编译和运行</h4><p>Java编译是将.java 文件转换为字节码（.class 文件），字节码并不是cpu可执行的汇编机器码，平台无关。编译使用java提供的编译器javac执行。</p>
<p>编译后，每个java文件都会产生一个.class文件，类似C++的.o文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 编译.java文件</span><br><span class="line">javac HelloWorld.java</span><br><span class="line">javac Class1.java Class2.java</span><br><span class="line">javac *.java</span><br><span class="line"></span><br><span class="line"># -classpath指定编译查找的类路径。</span><br><span class="line">javac -classpath /path/to/library.jar MyProgram.java</span><br><span class="line">javac -classpath /path/to/library1.jar:/path/to/library2.jar MyProgram.java</span><br><span class="line"></span><br><span class="line"># -d 指定编译输出.class 文件的目录</span><br><span class="line">javac -d bin MyProgram.java</span><br><span class="line"></span><br><span class="line"># -g添加调试信息</span><br><span class="line">javac -g MyProgram.java</span><br></pre></td></tr></table></figure>

<p>运行.class文件，只需要显示运行携带main方法的类，相关的类会自动被加载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 不需要加.class后缀</span><br><span class="line">java HelloWorld</span><br></pre></td></tr></table></figure>

<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>jdb是java提供的调试工具, jdb比较反人类的是，它的命令没有简写，例如next不能写作n, cont不能写作c, 以及反人类的命令stop at MyProgram:10</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># 开始运行</span><br><span class="line">run </span><br><span class="line"># 查看帮助信息</span><br><span class="line">help</span><br><span class="line"></span><br><span class="line"># 设置断点</span><br><span class="line">stop at MyProgram:10</span><br><span class="line">stop in MyProgram.myMethod</span><br><span class="line"></span><br><span class="line">Usage: stop at &lt;class&gt;:&lt;line_number&gt; or</span><br><span class="line">       stop in &lt;class&gt;.&lt;method_name&gt;[(argument_type,...)]</span><br><span class="line"></span><br><span class="line"># 查看断点（没错clear是查看断点）</span><br><span class="line">clear</span><br><span class="line"># 删除某个断点，不支持删除全部断点。</span><br><span class="line">clear MyProgram:10  </span><br><span class="line"></span><br><span class="line"># 断点继续运行</span><br><span class="line">cont</span><br><span class="line"></span><br><span class="line"># 单步执行</span><br><span class="line">next</span><br><span class="line">step</span><br><span class="line"></span><br><span class="line"># 返回到上层调用，类似gdb的finish</span><br><span class="line">step up</span><br><span class="line"></span><br><span class="line">list # 显示旁边代码</span><br><span class="line"></span><br><span class="line"># 查看变量</span><br><span class="line">print variableName</span><br><span class="line">print objectInstance.memberVariable</span><br><span class="line"></span><br><span class="line"># 查看线程信息</span><br><span class="line">thread  # 当前线程信息</span><br><span class="line">thread 1  # 1号线程信息</span><br><span class="line"># 暂停和恢复某线程的运行</span><br><span class="line">suspend [thread id(s)]</span><br><span class="line">resume [thread id(s)] </span><br><span class="line"></span><br><span class="line"># 查看线程的栈帧</span><br><span class="line">where  # 当前线程信息</span><br><span class="line">where 2</span><br><span class="line"></span><br><span class="line"># 查看class和method信息</span><br><span class="line">class &lt;className&gt;</span><br><span class="line">method &lt;&gt;</span><br></pre></td></tr></table></figure>

<p>调试正在运行的进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 列出正在运行的java进程</span><br><span class="line">jps -l</span><br><span class="line"></span><br><span class="line"># 连接正在运行的进程</span><br><span class="line">jdb -attach &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>JUnit 是最常用的 Java 单元测试框架，使用注解 @Test 来标记测试方法，以及 @Before 和 @After 来标记测试前后的初始化和清理方法。</p>
<h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><h4 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 编译单个文件</span><br><span class="line">go build main.go</span><br><span class="line"></span><br><span class="line"># 编译整个包</span><br><span class="line">go build</span><br><span class="line"></span><br><span class="line"># 编译参数, -gcflags</span><br><span class="line">go build -gcflags &quot;-N&quot; main.go</span><br><span class="line"></span><br><span class="line">-N  # 禁用优化</span><br><span class="line">-l  # 禁用内联优化</span><br><span class="line">-l -N  # 禁用优化和内联</span><br><span class="line">-m  # 输出优化决策信息</span><br><span class="line">-d  # 增加调试信息</span><br></pre></td></tr></table></figure>

<h4 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h4><p>golang推荐使用Delve 进行调试，安装<code>go install github.com/go-delve/delve/cmd/dlv@latest</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># 调试单个文件</span><br><span class="line">dlv debug main.go</span><br><span class="line"># 调试某个目录</span><br><span class="line">dlv debug</span><br><span class="line"></span><br><span class="line"># 设置断点</span><br><span class="line">break b</span><br><span class="line">b main.go:10</span><br><span class="line"># 显示已经设置的断点</span><br><span class="line">breakpoints (alias: bp)</span><br><span class="line"></span><br><span class="line"># 栈帧移动</span><br><span class="line">down ------------------------ Move the current frame down.</span><br><span class="line">up -------------------------- Move the current frame up.</span><br><span class="line"></span><br><span class="line"># 继续运行直到下一个断点</span><br><span class="line">continue c</span><br><span class="line"></span><br><span class="line"># 单步执行	</span><br><span class="line">next  n	# 单步执行，跳过函数调用</span><br><span class="line">step  s	# 单步进入函数内部</span><br><span class="line"></span><br><span class="line"># 打印变量值</span><br><span class="line">print p	</span><br><span class="line">p x</span><br><span class="line"></span><br><span class="line"># 显示当前代码行及上下文</span><br><span class="line">list 或 ls	</span><br><span class="line"></span><br><span class="line">goroutine ------------------- Shows or changes current goroutine</span><br><span class="line">goroutines	# 查看当前所有 Goroutines</span><br><span class="line"># 查看goroutine堆栈</span><br><span class="line">stack &lt;goroutine_id&gt;</span><br><span class="line"></span><br><span class="line">threads	显示所有线程信息</span><br><span class="line">thread (alias: tr) ---------- Switch to the specified thread.</span><br></pre></td></tr></table></figure>

<h4 id="静态代码检查"><a href="#静态代码检查" class="headerlink" title="静态代码检查"></a>静态代码检查</h4><p>gopls，通常会随 Go 扩展自动安装。可以和vscode结合配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 静态检查</span><br><span class="line">gopls check &lt;path-to-your-directory-or-file&gt;</span><br><span class="line"># 格式化代码</span><br><span class="line">gopls format &lt;path-to-your-file&gt;</span><br><span class="line"># 代码补全</span><br><span class="line">gopls completion &lt;path-to-your-file&gt;:&lt;line&gt;:&lt;column&gt;</span><br><span class="line"></span><br><span class="line"># 跳转到函数定义</span><br><span class="line">gopls definition &lt;path-to-your-file&gt;:&lt;line&gt;:&lt;column&gt;</span><br><span class="line"># 跳转到引用</span><br><span class="line">gopls references &lt;path-to-your-file&gt;:&lt;line&gt;:&lt;column&gt;</span><br></pre></td></tr></table></figure>

<h4 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h4><p>Go 自带的测试框架（testing 包）支持单元测试和性能测试。测试文件以 _test.go 结尾, 测试函数必须以 Test 开头，后面跟随被测试的内容的名称。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 运行测试</span><br><span class="line">go test</span><br><span class="line">go test -run TestAdd  # 只运行特定的测试函数</span><br><span class="line">go test -cover  # 查看覆盖率</span><br><span class="line"></span><br><span class="line"># 调试测试</span><br><span class="line">dlv test</span><br><span class="line"></span><br><span class="line"># 调试单个测试</span><br><span class="line">dlv test -- -test.run TestFunctionName</span><br></pre></td></tr></table></figure>


<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><h4 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h4><p>Python 会将源代码编译为一种字节码（Bytecode），存储为 .pyc 文件（位于 <code>__pycache__</code> 文件夹）。字节码会被 Python 虚拟机（PVM，Python Virtual Machine）翻译为底层的机器指令执行。</p>
<p>相比java通常把字节码打包成jar，后续由jvm执行; python一般直接保留源代码，python虚拟机直接执行源代码。python编译过程也不会进行类型检查，编译器优化行为少。</p>
<p>python语法比较灵活，表达式函数可以在全局执行，执行实现先于main模块。</p>
<h4 id="调试-2"><a href="#调试-2" class="headerlink" title="调试"></a>调试</h4><p>python -m pdb your_program.py 启用pdb调试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># 单步运行</span><br><span class="line">n next  # n</span><br><span class="line">s step  # 进入当前行中的函数调用，逐步执行</span><br><span class="line">c continue  # 继续执行程序，直到下一个断点</span><br><span class="line">r return  # 运行到当前函数完毕</span><br><span class="line"></span><br><span class="line"># 清理断点</span><br><span class="line">clear</span><br><span class="line">clear filename:lineno  # 删除某行所有断点</span><br><span class="line">clear number  # 删除编号断点</span><br><span class="line"></span><br><span class="line">enable bpnumber # 启动和关闭断点</span><br><span class="line">disable bpnumber </span><br><span class="line"></span><br><span class="line"># 打印变量值或表达式</span><br><span class="line">p &lt;expression&gt;</span><br><span class="line"></span><br><span class="line"># 列出当前行附近的代码</span><br><span class="line">l (list)</span><br><span class="line"></span><br><span class="line"># 设置断点</span><br><span class="line">b  break # 显示已经设置的断点</span><br><span class="line">b &lt;line_number&gt;</span><br><span class="line">b 12</span><br><span class="line">b add</span><br><span class="line"></span><br><span class="line"># 显示当前的调用栈</span><br><span class="line">w (where) </span><br><span class="line">up  # 切换到调用栈的上一层（即父函数）</span><br><span class="line">down  # 切换到调用栈的下一层（即子函数）</span><br><span class="line"></span><br><span class="line">&lt;expression&gt;  # 执行表达式，可以修改变量</span><br><span class="line">a = 10</span><br></pre></td></tr></table></figure>

<h4 id="静态检查"><a href="#静态检查" class="headerlink" title="静态检查"></a>静态检查</h4><p>pylint 工具检查代码，执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pylint &lt;your-python-file.py&gt;</span><br><span class="line">pylint &lt;your-project-folder&gt;</span><br><span class="line"></span><br><span class="line"># 生成pylint的静态检查规则</span><br><span class="line">pylint --generate-rcfile &gt; .pylintrc</span><br></pre></td></tr></table></figure>

<p>pylint不支持自动格式化，Black可以用来做python自动化代码格式化工具</p>
<h4 id="单元测试-2"><a href="#单元测试-2" class="headerlink" title="单元测试"></a>单元测试</h4><p>unittest 库，导入待测试的模块，对需要测试的模块进行单元测试</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">import</span> math_utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestMathUtils</span>(unittest.TestCase):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_add</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 测试 add 函数</span></span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(math_utils.add(<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>)</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(math_utils.add(-<span class="number">1</span>, <span class="number">1</span>), <span class="number">0</span>)</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(math_utils.add(<span class="number">0</span>, <span class="number">0</span>), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_subtract</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 测试 subtract 函数</span></span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(math_utils.subtract(<span class="number">10</span>, <span class="number">5</span>), <span class="number">5</span>)</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(math_utils.subtract(<span class="number">0</span>, <span class="number">1</span>), -<span class="number">1</span>)</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(math_utils.subtract(<span class="number">100</span>, <span class="number">50</span>), <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>


<h4 id="日志-1"><a href="#日志-1" class="headerlink" title="日志"></a>日志</h4><p>配置日志处理器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建日志器</span></span><br><span class="line">logger = logging.getLogger(<span class="string">&quot;my_logger&quot;</span>)</span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建控制台处理器</span></span><br><span class="line">console_handler = logging.StreamHandler()</span><br><span class="line">console_handler.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件处理器</span></span><br><span class="line">file_handler = logging.FileHandler(<span class="string">&quot;app.log&quot;</span>)</span><br><span class="line">file_handler.setLevel(logging.WARNING)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义日志格式</span></span><br><span class="line">formatter = logging.Formatter(<span class="string">&quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;</span>)</span><br><span class="line">console_handler.setFormatter(formatter)</span><br><span class="line">file_handler.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加处理器到日志器</span></span><br><span class="line">logger.addHandler(console_handler)</span><br><span class="line">logger.addHandler(file_handler)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试日志</span></span><br><span class="line">logger.debug(<span class="string">&quot;这是一条调试日志&quot;</span>)</span><br><span class="line">logger.info(<span class="string">&quot;这是一条一般信息日志&quot;</span>)</span><br><span class="line">logger.warning(<span class="string">&quot;这是一条警告日志&quot;</span>)</span><br><span class="line">logger.error(<span class="string">&quot;这是一条错误日志&quot;</span>)</span><br><span class="line">logger.critical(<span class="string">&quot;这是一条严重错误日志&quot;</span>)</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>编程语言(7)—编译、运行和调试</p><p><span>文章作者：</span>Infinity</p><p><span>发布时间：</span>2025-01-02</p><p><span>最后更新：</span>2025-01-11</p><p><span>原始链接：</span><a href="/2025/01/02/编程语言(7)—编译、运行和调试/">https://larrystd.github.io/2025/01/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(7)%E2%80%94%E7%BC%96%E8%AF%91%E3%80%81%E8%BF%90%E8%A1%8C%E5%92%8C%E8%B0%83%E8%AF%95/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://larrystd.github.io/2025/01/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(7)%E2%80%94%E7%BC%96%E8%AF%91%E3%80%81%E8%BF%90%E8%A1%8C%E5%92%8C%E8%B0%83%E8%AF%95/"></i></span></p><p><span>版权声明：</span>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p></div><br><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/language/" rel="tag">language</a></li></ul></div><div class="post-nav"><a class="pre" href="/2025/01/07/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%BA%95%E5%BA%A7/">分布式存储底座</a><a class="next" href="/2024/12/22/%E7%BC%93%E5%AD%98/">缓存</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="https://unpkg.com/blueimp-md5/js/md5.js"></script><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: 'Ov23lifIyMlBwTu1yQhW',
  clientSecret: '8a6951b810e0f8c75acc7af48be63e53e7d6b5ad',
  repo: 'blogtalk',
  owner: 'larrystd',
  admin: ['larrystd'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>To be a better man.</p><a class="info-icon" href="venray.kong@outlook.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/larrystd" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/application/">application</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/base/">base</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hello/">hello</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/multi-machine/">multi-machine</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/single-machine/">single-machine</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/hello/" style="font-size: 15px;">hello</a> <a href="/tags/single-machine/" style="font-size: 15px;">single-machine</a> <a href="/tags/storage/" style="font-size: 15px;">storage</a> <a href="/tags/application/" style="font-size: 15px;">application</a> <a href="/tags/base/" style="font-size: 15px;">base</a> <a href="/tags/os/" style="font-size: 15px;">os</a> <a href="/tags/language/" style="font-size: 15px;">language</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/12/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(6)%E2%80%94%E6%96%87%E4%BB%B6IO%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%93/">编程语言(6)—文件IO和网络库</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/12/22/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0/">静态变量和函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/12/14/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(5)%E2%80%94%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/">编程语言(5)—并发编程和函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/12/10/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(4)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">编程语言(4)—数据结构和算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/12/06/%E6%98%A0%E5%B0%84%E7%BB%93%E6%9E%84/">映射结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/12/05/linux%E7%B3%BB%E7%BB%9F%E8%A7%82%E6%B5%8B%E5%B7%A5%E5%85%B7/">linux系统观测工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/12/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(3)%E2%80%94%E5%8F%98%E9%87%8F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/">编程语言(3)—变量和作用域</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/07/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%BA%95%E5%BA%A7/">分布式存储底座</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(7)%E2%80%94%E7%BC%96%E8%AF%91%E3%80%81%E8%BF%90%E8%A1%8C%E5%92%8C%E8%B0%83%E8%AF%95/">编程语言(7)—编译、运行和调试</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/12/22/%E7%BC%93%E5%AD%98/">缓存</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="todo" target="_blank">todo</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Infinity Code.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>