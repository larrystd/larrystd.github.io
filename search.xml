<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算(2)——GPU计算和大模型</title>
      <link href="/2025/04/30/%E8%AE%A1%E7%AE%97(2)%E2%80%94GPU%E8%AE%A1%E7%AE%97%E5%92%8C%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
      <url>/2025/04/30/%E8%AE%A1%E7%AE%97(2)%E2%80%94GPU%E8%AE%A1%E7%AE%97%E5%92%8C%E5%A4%A7%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>前面提到，CPU运算的瓶颈往往不在于计算，而在于内存、存储和网络。相比于设计算法模型，CPU计算更侧重于工程。</p><p>相比下，GPU运算才是真正的高性能运算，虽然它的瓶颈同样可能来自GPU、显存、存储和网络，但提高计算能力、设计优秀的算法、编写高性能低开销的算子，是GPU运算的核心。GPU运算的典型场景就是大模型。</p><span id="more"></span><h3 id="GPU-运算"><a href="#GPU-运算" class="headerlink" title="GPU 运算"></a>GPU 运算</h3><p>前面提到，CPU 通过SIMD提供了向量化引擎，适用于OLAP存储和OLAP少量维度的数据分析。但如果是以下场景，就需要GPU了。</p><ol><li>数据维度高，相比OLAP往往存储二维结构化数据，且列数较少；GPU处理的数据维度高（例如图片数据）、或者是非结构化数据（如自然语言序列）</li><li><strong>需要高性能矩阵运算</strong>，如矩阵乘法、矩阵加法。</li><li>计算单元<strong>用有向无环图的形式组织</strong>，当前运算单元的输出是下一运算单元的输入，计算层很深，计算量庞大</li><li>指令数量和条件分支判断数量少</li><li>指令数量少意味着不用经常访问内存，cache数量少，无须多级cache。（GPU访问显存的频率远低于CPU访问cache的频率）</li></ol><h4 id="CUDA-GPU并行编程模型"><a href="#CUDA-GPU并行编程模型" class="headerlink" title="CUDA GPU并行编程模型"></a>CUDA GPU并行编程模型</h4><p>CUDA（Compute Unified Device Architecture）是NVIDIA为GPU设计的并行计算平台和编程模型。nvidia gpu物理上使用​​CUDA核心（FP32&#x2F;INT32）​​执行浮点和整数运算, 每一个Cuda Core由1个浮点数单元FPU和1个逻辑运算单元ALU组成。除了cuda Core，nivida还用张量核Tensor Core模块用于执行融合乘法加法。</p><p>cuda的thread是最小计算单元, 用来处理单个数据。多个thread组成block，可用来执行矩阵处理。多个线程块的集合组成grid，用来表示一个大规模计算任务。cuda 引擎会调度thread&#x2F;block&#x2F;grid上的计算到合适的GPU硬件单元上执行。</p><p>向量加法的例子，用一个block执行向量加法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向量加法核函数</span></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">addKernel</span><span class="params">(<span class="type">float</span> *a, <span class="type">float</span> *b, <span class="type">float</span> *c, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">        c[i] = a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用：addKernel&lt;&lt;&lt;ceil(n/256), 256&gt;&gt;&gt;(a, b, c, n);</span></span><br></pre></td></tr></table></figure><h4 id="pytorch-深度学习框架"><a href="#pytorch-深度学习框架" class="headerlink" title="pytorch 深度学习框架"></a>pytorch 深度学习框架</h4><p>PyTorch 是由 Facebook AI Research (FAIR) 开发的开源深度学习框架，以其 ​​动态计算图​​、​​易用性​​ 和 ​​高效的 GPU 加速​​ 著称，广泛应用于学术研究、工业界模型开发和部署。</p><p>python前端接口调用, 文档: <a href="https://pytorch.org/docs/stable/index.html">https://pytorch.org/docs/stable/index.html</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">x = torch.randn(<span class="number">3</span>, <span class="number">3</span>)  <span class="comment"># 创建张量</span></span><br><span class="line">y = x.cuda()           <span class="comment"># 移动到 GPU</span></span><br><span class="line">z = y + <span class="number">1</span>              <span class="comment"># GPU 加速计算</span></span><br><span class="line"></span><br><span class="line">x = torch.tensor(<span class="number">2.0</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">y = x**<span class="number">2</span> + <span class="number">3</span>*x + <span class="number">1</span></span><br><span class="line">y.backward()           <span class="comment"># 计算梯度 d(y)/d(x) = 2x + 3</span></span><br><span class="line"><span class="built_in">print</span>(x.grad)          <span class="comment"># 输出: 7.0</span></span><br></pre></td></tr></table></figure><p>后端C++引擎libtorch, 可以直接基于libtorch进行C++开发。</p><ol><li>​ATen 库​​：核心张量计算库，支持 CPU&#x2F;GPU 统一代码。</li><li>​TorchScript​​：将 Python 模型转换为静态计算图（ScriptModule），用于高性能推理。</li><li>​​CUDA 集成​​：通过 c10::cuda 实现低延迟 GPU 操作。</li></ol><p>pytorch 可以很容易调用cuda开发的算子，参考 <a href="https://zhuanlan.zhihu.com/p/595851188">https://zhuanlan.zhihu.com/p/595851188</a></p><p>代码结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">├── ops</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── ops_py</span><br><span class="line">│   │   ├── __init__.py</span><br><span class="line">│   │   └── sum.py</span><br><span class="line">│   └── src</span><br><span class="line">│       ├── reduce_sum</span><br><span class="line">│       │   ├── sum.cpp</span><br><span class="line">│       │   └── sum_cuda.cu</span><br><span class="line">│       └── sum_two_arrays</span><br><span class="line">│           ├── two_sum.cpp</span><br><span class="line">│           └── two_sum_cuda.cu</span><br><span class="line">├── README.md</span><br><span class="line">├── setup.py</span><br><span class="line">└── test_ops.py</span><br></pre></td></tr></table></figure><p>src&#x2F;sum_two_arrays&#x2F;two_sum_cuda.cu</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADS_PER_BLOCK 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WARP_SIZE 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIVUP(m, n) ((m + n - 1) / n)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">two_sum_kernel</span><span class="params">(<span class="type">const</span> <span class="type">float</span>* a, <span class="type">const</span> <span class="type">float</span>* b, <span class="type">float</span> * c, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    <span class="keyword">if</span> (idx &lt; n)&#123;</span><br><span class="line">        c[idx] = a[idx] + b[idx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">two_sum_launcher</span><span class="params">(<span class="type">const</span> <span class="type">float</span>* a, <span class="type">const</span> <span class="type">float</span>* b, <span class="type">float</span>* c, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="function">dim3 <span class="title">blockSize</span><span class="params">(DIVUP(n, THREADS_PER_BLOCK))</span></span>;</span><br><span class="line">    <span class="function">dim3 <span class="title">threadSize</span><span class="params">(THREADS_PER_BLOCK)</span></span>;</span><br><span class="line">    two_sum_kernel&lt;&lt;&lt;blockSize, threadSize&gt;&gt;&gt;(a, b, c, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>src&#x2F;sum_two_arrays&#x2F;two_sum.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;torch/extension.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;torch/serialize/tensor.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_CUDA(x) \</span></span><br><span class="line"><span class="meta">  TORCH_CHECK(x.type().is_cuda(), #x, <span class="string">&quot; must be a CUDAtensor &quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_CONTIGUOUS(x) \</span></span><br><span class="line"><span class="meta">  TORCH_CHECK(x.is_contiguous(), #x, <span class="string">&quot; must be contiguous &quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_INPUT(x) \</span></span><br><span class="line"><span class="meta">  CHECK_CUDA(x);       \</span></span><br><span class="line"><span class="meta">  CHECK_CONTIGUOUS(x)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">two_sum_launcher</span><span class="params">(<span class="type">const</span> <span class="type">float</span>* a, <span class="type">const</span> <span class="type">float</span>* b, <span class="type">float</span>* c, <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">two_sum_gpu</span><span class="params">(at::Tensor a_tensor, at::Tensor b_tensor, at::Tensor c_tensor)</span></span>&#123;</span><br><span class="line">    <span class="built_in">CHECK_INPUT</span>(a_tensor);</span><br><span class="line">    <span class="built_in">CHECK_INPUT</span>(b_tensor);</span><br><span class="line">    <span class="built_in">CHECK_INPUT</span>(c_tensor);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">float</span>* a = a_tensor.<span class="built_in">data_ptr</span>&lt;<span class="type">float</span>&gt;();</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span>* b = b_tensor.<span class="built_in">data_ptr</span>&lt;<span class="type">float</span>&gt;();</span><br><span class="line">    <span class="type">float</span>* c = c_tensor.<span class="built_in">data_ptr</span>&lt;<span class="type">float</span>&gt;();</span><br><span class="line">    <span class="type">int</span> n = a_tensor.<span class="built_in">size</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">two_sum_launcher</span>(a, b, c, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">PYBIND11_MODULE</span>(TORCH_EXTENSION_NAME, m) &#123;</span><br><span class="line">  m.<span class="built_in">def</span>(<span class="string">&quot;forward&quot;</span>, &amp;two_sum_gpu, <span class="string">&quot;sum two arrays (CUDA)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PYBIND11_MODULE(TORCH_EXTENSION_NAME, m) { m.def(“forward”, &amp;two_sum_gpu …)} 表示</p><ol><li>pybind11 宏，声明一个 Python 模块，并创建模块对象</li><li>将 C++ 函数 two_sum_gpu 绑定到 Python 模块，并命名为 forward。</li></ol><p>使用setup.py编译（也可以使用jit编译）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> find_packages, setup</span><br><span class="line"><span class="keyword">from</span> torch.utils.cpp_extension <span class="keyword">import</span> BuildExtension, CUDAExtension</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">&#x27;CudaDemo&#x27;</span>,</span><br><span class="line">    packages=find_packages(),</span><br><span class="line">    version=<span class="string">&#x27;0.1.0&#x27;</span>,</span><br><span class="line">    author=<span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">    ext_modules=[</span><br><span class="line">        CUDAExtension(</span><br><span class="line">            <span class="string">&#x27;sum_double&#x27;</span>,</span><br><span class="line">            [<span class="string">&#x27;./ops/src/sum_two_arrays/two_sum.cpp&#x27;</span>,</span><br><span class="line">             <span class="string">&#x27;./ops/src/sum_two_arrays/two_sum_cuda.cu&#x27;</span>,]</span><br><span class="line">        ),</span><br><span class="line">    ],</span><br><span class="line">    cmdclass=&#123;</span><br><span class="line">        <span class="string">&#x27;build_ext&#x27;</span>: BuildExtension</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>pytorch调用cuda算子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ops/ops_py/sum.py</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Function</span><br><span class="line"><span class="keyword">import</span> sum_double</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SumDouble</span>(<span class="title class_ inherited__">Function</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">ctx, array1, array2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;sum_double function forward.</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            array1 (torch.Tensor): [n,]</span></span><br><span class="line"><span class="string">            array2 (torch.Tensor): [n,]</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            ans (torch.Tensor): [n,]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        array1 = array1.<span class="built_in">float</span>()</span><br><span class="line">        array2 = array2.<span class="built_in">float</span>()</span><br><span class="line">        ans = array1.new_zeros(array1.shape)</span><br><span class="line">        sum_double.forward(array1.contiguous(), array2.contiguous(), ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">ctx, g_out</span>):</span><br><span class="line">        <span class="comment"># return None, None   # if the function is no need for backpropogation</span></span><br><span class="line"></span><br><span class="line">        g_in1 = g_out.clone()</span><br><span class="line">        g_in2 = g_out.clone()</span><br><span class="line">        <span class="keyword">return</span> g_in1, g_in2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sum_double_op = SumDouble.apply</span><br></pre></td></tr></table></figure><h4 id="cudnn和nccl"><a href="#cudnn和nccl" class="headerlink" title="cudnn和nccl"></a>cudnn和nccl</h4><p>cuDNN​​（CUDA Deep Neural Network Library）是英伟达推出的专为深度学习设计的GPU加速库。它针对深度神经网络中的核心操作（如卷积、池化、归一化等）提供高度优化的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动cudnn加速</span></span><br><span class="line">torch.backends.cudnn.enabled = <span class="literal">True</span>        <span class="comment"># 全局启用</span></span><br><span class="line">torch.backends.cudnn.benchmark = <span class="literal">True</span>      <span class="comment"># 允许自动选择最优算法（固定输入大小时启用）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 混和精度训练</span></span><br><span class="line"><span class="keyword">with</span> torch.cuda.amp.autocast():</span><br><span class="line">    outputs = model(inputs)</span><br></pre></td></tr></table></figure><p>​​NCCL（NVIDIA Collective Communications Library）​​ 是 NVIDIA 开发的 ​​GPU 专用通信库​​，旨在优化多 GPU 和多节点间的数据传输效率。cuDNN 可与 NCCL 结合实现多卡通信。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = nn.parallel.DistributedDataParallel(model, device_ids=[local_rank])</span><br></pre></td></tr></table></figure><h3 id="transformer和self-attention"><a href="#transformer和self-attention" class="headerlink" title="transformer和self-attention"></a>transformer和self-attention</h3><p>以上讲了cpu适合通用计算，也就是cpu需要能够各种任务，包括进程任务，cache和内存读写，IO存储，需要具备中断处理能力，就像工作的人一样。CPU还提供了向量化指令增加向量数据处理的能力。GPU适合专门处理矩阵浮点型运算，这种矩阵浮点运算最显著的场景就是深度学习和大模型运算。</p><p>目前大模型基本是基于transformer和self-attention架构开发，相关分析 <a href="https://zhuanlan.zhihu.com/p/624740065">https://zhuanlan.zhihu.com/p/624740065</a> 比较全面，我整理下总结</p><ol><li>每个transformer层的参数量为12h^2,训练时每个参数占20字节，推理时每个参数占2个字节。h是隐藏层维度</li><li>每个参数前向计算需要2个浮点数运算（相当于一次乘法一次加法），反向需要4个浮点数运算（反向需要根据误差计算梯度，然后根据梯度更新权重，需要两次运算，计算量是前向计算的2倍）。一般采用激活重计算技术降低中间激活层的内存占用，这样子又需要一次前向计算。每个参数总计需要8个浮点数运算。推理时每个参数只要2个浮点数运算。</li><li>显存占用主要由1. 模型参数 2. 前向计算过程产生的中间激活 3. 后向计算得到的梯度 4.优化器状态四个方面组成。其中模型参数、后向计算得到的梯度、优化器状态参数之和只和隐藏层size有关，而前向计算过程产生的中间激活参数和batchsize、序列长度有关。可以通过减少batchsize，额外的激活重计算来降低中间激活参数。</li></ol><h4 id="1-模型参数"><a href="#1-模型参数" class="headerlink" title="1. 模型参数"></a>1. 模型参数</h4><p><img src="/../images/self-attention.png" alt="self-attention"></p><ol><li>transformer由l层组成，每层分为self-attention（多头注意力）和MLP两部分。self-attention块包含3个QKV权重矩阵和一个输出权重矩阵，每个矩阵维度[h, h], 加上偏置参数量为4h^2+4h, h为隐藏层维度</li><li>MLP块由两个线性层组成，第一个线性层维度为[h, 4h], 第二个线性层维度为[4h, h], 加上偏置参数量为8h^2+5h</li><li>self-attention块和MLP块之后各有一个layer norm层，包含两个参数，缩容参数alpha和偏置参数beta，2个layer norm参数量合计为4h</li></ol><p>综上, 每个transformer层参数量为12h^2+13h, 对于l层transformer, 参数了近似为12lh^2</p><p><img src="/../images/transformer_params.png" alt="transformer_params"></p><h4 id="2-参数显存分析"><a href="#2-参数显存分析" class="headerlink" title="2. 参数显存分析"></a>2. 参数显存分析</h4><p>略</p><h4 id="3-kvcache分析"><a href="#3-kvcache分析" class="headerlink" title="3. kvcache分析"></a>3. kvcache分析</h4><p>加入kvcache后，一个典型的大模型生成式推断包含了两个阶段：</p><ol><li>预填充阶段：输入一个prompt序列，为每个transformer层生成 key cache和value cache（KV cache）。</li><li>解码阶段：使用并更新KV cache，一个接一个地生成词，当前生成的词依赖于之前已经生成的词。</li></ol><p>kvcache 只影响第一步QKV矩阵的生成，将矩阵-矩阵乘法 降低为矩阵-向量乘法，减少参数量加速计算</p><p><img src="/../images/kvcache.png" alt="kvcache"></p><p>KV Cache是Transformer推理性能优化的一项重要工程化技术，各大推理框架都已实现并将其进行了封装。可以看这篇文章 <a href="https://zhuanlan.zhihu.com/p/63083259">https://zhuanlan.zhihu.com/p/63083259</a></p><h3 id="大模型加速"><a href="#大模型加速" class="headerlink" title="大模型加速"></a>大模型加速</h3><p>大模型加速，主要分为模型侧、计算侧和内存IO侧。模型侧主要是压缩和量化，计算侧包括并行计算，cuda算子优化以及MOE训练等，内存IO侧主要在内存分配，共享，高性能存储网络等。</p><h4 id="1-模型压缩"><a href="#1-模型压缩" class="headerlink" title="1. 模型压缩"></a>1. 模型压缩</h4><ol><li><p>剪裁(Pruning), 核心思想是尽可能保证模型精度不受影响下减少网络的参数量，例如减少网络中神经元的数量<br>剪裁中常用的步骤1. 预训练大模型 2. 修剪网络, 训练小模型 3. 通过微调恢复剪裁对模型的损耗</p></li><li><p>量化Quantization<br>量化的基本思想是将浮点计算替换成更低比特的计算，从而降低模型体积加快推理速度。量化可以采用定点近似（直接缩小位宽降低精度）和范围近似（通过统计学缩放映射浮点数，需要量化和反量化，精度较高）。</p></li><li><p>知识蒸馏(Knowledge Distillation)<br>一种教师-学生的训练结构，通常是已训练好的教师模型提供知识，学生模型通过蒸馏训练来获取知识。将教师模型的输出作为软标签与学生模型的软预测计算蒸馏损失，将真实的硬标签与学生模型的硬预测计算学生损失，最终将两种损失结合训练学生模型</p></li></ol><h4 id="2-计算侧加速"><a href="#2-计算侧加速" class="headerlink" title="2. 计算侧加速"></a>2. 计算侧加速</h4><ol><li>并行计算<br>数据并行（数据集拆分），流水线并行（模型拆分成子模型），张量并行（模型按层拆分），专家并行（MOE）</li></ol><p>其中流水线并行是GPU内存不足的无奈之举，各层之间仍然是顺序执行的，并不能加速模型的运算。</p><p>张量并行可以使用nivida的Megatron库，将模型内部改为ColumnParallelLinear, ParallelMLP, ParallelAttention等结构</p><p>专家并行特指MOE训练（混和专家模型）</p><ol start="2"><li><p>kvcache<br>加速KQV矩阵的生产运算</p></li><li><p>cuda优化和算子融合<br>cuda 执行矩阵乘法，激活函数，softmax等，每个操作都对应一次cuda调用。可以自定义cuda Attention优化，以及将多个cuda算子融合到一起，减少cuda调用次数，提高性能。</p></li></ol><h4 id="内存和IO优化"><a href="#内存和IO优化" class="headerlink" title="内存和IO优化"></a>内存和IO优化</h4><ol><li><p>FlashAttention<br>加速注意力计算并减少内存占用。FlashAttention的核心原理是通过<strong>将输入分块</strong>并在每个块上执行注意力操作，从而减少对高带宽内存（HBM）的读写操作。参考文章 <a href="https://zhuanlan.zhihu.com/p/676655352">https://zhuanlan.zhihu.com/p/676655352</a></p></li><li><p>FlashDEcoding<br>FlashAttention对batch size和query length进行了并行化加速，Flash-Decoding在此基础上增加了一个新的并行化维度：keys&#x2F;values的序列长度。即使batch size很小，但只要上下文足够长，它就可以充分利用GPU。</p></li><li><p>Continuous Batching<br>一个批次中，某些请求可能会比其他请求提前“完成”，但这些完成的请求需要等待整个批次完成才释放资源。<br>Continuous Batching 不会等待批次中的每个序列完成生成，而是实现迭代级调度，一旦批处理中的序列完成生成，就可以在其位置插入新序列，不必等待整个批次完成。 参考文章 <a href="https://github.com/PaddleJitLab/CUDATutorial/blob/develop/docs/13_continuous_batch/README.md">https://github.com/PaddleJitLab/CUDATutorial/blob/develop/docs/13_continuous_batch/README.md</a></p></li><li><p>PagedAttention<br>现有的推理系统将 KV Cache 存储在连续的显存空间中，导致显存碎片浪费，以及显存无法共享。</p></li></ol><p>PagedAttention 将 KV cache 组织成了固定大小的 KV blocks，类似虚拟内存中的页。管理显存的分配，同时对推理的重复计算内存共享。</p><h3 id="大模型推理框架"><a href="#大模型推理框架" class="headerlink" title="大模型推理框架"></a>大模型推理框架</h3><h4 id="vLLM"><a href="#vLLM" class="headerlink" title="vLLM"></a>vLLM</h4><p>vLLM 是一个快速、易于使用的 LLM 推理和服务库。可以接收流式的处理请求，并调度GPU和模型执行推理和输出</p><ol><li>调度器<br>在每1个推理阶段，决定要把哪些数据送给模型做推理，同时负责给这些模型分配KV Cache物理块。</li><li>Worker<br>CacheEngine：负责管控gpu&#x2F;cpu上的KV cache物理块（调度器的block manager只负责物理块id的分配）<br>Worker.model：负责加载模型，并执行推理。</li></ol><p><a href="https://zhuanlan.zhihu.com/p/691045737">https://zhuanlan.zhihu.com/p/691045737</a></p><h4 id="TensorRT"><a href="#TensorRT" class="headerlink" title="TensorRT"></a>TensorRT</h4><p>​​TensorRT​​ 是 NVIDIA 推出的 ​​高性能深度学习推理优化器，相比vLLM主要从调度层和计算&#x2F;内存资源分配层做优化，TensorRT 主要在cuda和硬件层进行优化。</p><ol><li>层融合（Layer Fusion）​​：合并卷积、激活、归一化等连续操作为单一内核，减少内存访问开销。</li><li>​​INT8​​：通过量化感知训练或校准集动态量化，速度提升 2-4 倍。</li><li>​Dynamic Tensor Memory 在每个tensor的使用期间，TensorRT会为其指定显存，避免显存重复申请，减少内存占用和提高重复使用效率。</li><li>Multi stream execution 使用CUDA中的stream技术，最大化实现并行操作。</li></ol><h3 id="MOE训练"><a href="#MOE训练" class="headerlink" title="MOE训练"></a>MOE训练</h3><p>混合专家模型（Mixture of Experts, MOE）训练​​ 是一种通过动态路由机制将输入分配给多个子网络（专家）的高效模型架构，在大规模模型中广泛应用</p><ol><li>​​专家网络​​, 多个独立的子模型（如全连接层、Transformer块），每个专家专注不同特征模式。可以实现并行处理</li><li>​​门控网络（Gating）​​根据输入生成权重，决定各专家的贡献比例（稀疏或软选择）</li><li>​​路由策略​​控制输入如何分配给专家（如 Top-K 选择、负载均衡约束）。</li></ol><p>优势</p><ol><li>​模型容量扩展​​，混和专家模型每次只计算局部的参数（激活局部的专家），因此能在GPU有限情况下训练大量参数的模型。增加专家数量可提升模型能力，而计算量仅随激活的专家数增长。</li><li>​​稀疏计算​​：仅部分专家参与推理（如 K&#x3D;2），适合资源受限场景（如 GPU 显存优化）。</li><li>​多模态学习​​：不同专家可处理不同类型输入（文本、图像等）。</li></ol><p>参考文章，<a href="https://huggingface.co/blog/moe">https://huggingface.co/blog/moe</a></p><h3 id="deepseek开源"><a href="#deepseek开源" class="headerlink" title="deepseek开源"></a>deepseek开源</h3><h4 id="1-FlashMLA"><a href="#1-FlashMLA" class="headerlink" title="1. FlashMLA"></a>1. FlashMLA</h4><p>deepseek 借鉴了FlashAttention项目中的一些理念，针对MLA进行优化的CUDA内核算子，并可集成到pytorch</p><p>链接 <a href="https://github.com/deepseek-ai/FlashMLA">https://github.com/deepseek-ai/FlashMLA</a></p><p>文档, <a href="https://github.com/deepseek-ai/FlashMLA/blob/main/docs/20250422-new-kernel-deep-dive.md">https://github.com/deepseek-ai/FlashMLA/blob/main/docs/20250422-new-kernel-deep-dive.md</a></p><h4 id="2-DeepEP"><a href="#2-DeepEP" class="headerlink" title="2. DeepEP"></a>2. DeepEP</h4><p>DeepEP 是一个专门为混合专家（MoE）模型和专家并行（EP）设计的通信库。DeepEP is a communication library tailored for Mixture-of-Experts (MoE) and expert parallelism (EP). It provides high-throughput and low-latency all-to-all GPU kernels, which are also as known as MoE dispatch and combine. The library also supports low-precision operations, including FP8.</p><p>链接 <a href="https://github.com/deepseek-ai/DeepEP">https://github.com/deepseek-ai/DeepEP</a></p><h4 id="3-DeepGEMM"><a href="#3-DeepGEMM" class="headerlink" title="3. DeepGEMM"></a>3. DeepGEMM</h4><p>通用矩阵乘法算子</p><h4 id="4-DualPipe-EPLB"><a href="#4-DualPipe-EPLB" class="headerlink" title="4. DualPipe &amp; EPLB"></a>4. DualPipe &amp; EPLB</h4><p>DualPipe 训练时流水线调度，采用了一种独特的调度策略，使得前向传播和反向传播可以在不同的GPU上同时进行<br>EPLB 实现专家负载均衡</p><h4 id="5-3FS"><a href="#5-3FS" class="headerlink" title="5. 3FS"></a>5. 3FS</h4><p>为大模型推理提供数据集和模型读写能力，主要关注小IO和大IO读，以及大IO写。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CPU运算的适用于逻辑运算（如数据清洗），简单整数和向量计算（例如OLAP），而GPU运算适用于矩阵运算（如卷积、矩阵乘法等）。一般的计算模型是GPU-CUDA-Pytorch三件套。</p><p>大模型基于transformer构建，是基于多层矩阵运算的复杂模型。本文分析了transformer一层的参数量，计算量，显存使用量和kvcache、重计算加速等。注意大模型和传统流式处理(如Flink的区别)是，大模型是高度密集型矩阵运算，而Flink流式处理的运算并不复杂，侧重于数字或向量计算而非矩阵运算。但大模型推理后续替代Flink犹未可知。</p><p>对于大模型加速，主要分为模型侧、计算侧和内存IO侧。模型侧主要是压缩和量化，计算侧包括并行计算，cuda算子优化以及MOE训练等，内存IO侧主要在内存分配，共享，高性能存储网络等。</p><p>大模型推理框架，vLLM是一套推理工程的解决方案。最后deepseek开源了包括矩阵运算、MLP算子、高性能网络、MOE训练负责均衡以及高性能存储的项目，都很值得学习。</p><p>可以把GPU训练看到类似IO存储，以后的业务层</p><ol><li>接收网络请求，准备执行环境</li><li>执行顺序和if-else逻辑，包括鉴权、流控、日志等</li><li>执行IO存储逻辑，包括写数据库&#x2F;写文件&#x2F;写缓存&#x2F;写oss等</li><li>执行在线大数据处理逻辑，例如搜广推等（CPU计算）</li><li>执行大模型GPU推理逻辑，推理生成序列或预测结果</li><li>获得3,4,5的结果，返回给客户端</li></ol><p>业务层本身是无状态的CPU计算，主要关注的</p><ol><li>接收海量请求，也就是高并发</li><li>自身可以水平扩展</li><li>明确后台的能力，为数据库层，模型推理层提供缓存，流控，队列等，防止后端压力过大</li><li>复杂的业务逻辑解耦</li></ol><p>IO存储、在线大数据处理、大模型推理层负责提供高并发、高性能的存储和计算推理服务。</p><p>by the way, 显然实时性的业务更具有挑战性，需要低延迟、高吞吐和高QOS。例如后端业务层开发（毫无疑问要是实时返回的）、搜索广告推荐（需要实时数据分析）、大模型推理（需要实时推理）、分布式数据库和存储（需要提供实时表和文件读写服务）、量化交易（需要低延迟自动化和手段触发策略）等。如果某业务无实时性处理要求，那技术性将会大打折扣。</p>]]></content>
      
      
      <categories>
          
          <category> compute </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compute </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算(1)——CPU计算和大数据</title>
      <link href="/2025/04/27/%E8%AE%A1%E7%AE%97(1)%E2%80%94CPU%E8%AE%A1%E7%AE%97%E5%92%8C%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
      <url>/2025/04/27/%E8%AE%A1%E7%AE%97(1)%E2%80%94CPU%E8%AE%A1%E7%AE%97%E5%92%8C%E5%A4%A7%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>由于本人是存储方向，前面的文章大多数是关于存储的。计算机系统&#x3D;计算+存储，其中计算包括计算单元（CPU、GPU）、cacheline和内存态的处理, 而存储特指IO处理。计算可分为CPU计算和GPU计算两部分，前者的典型场景是操作系统处理、进程执行、互联网业务处理和大数据和OLAP处理等。后者的典型场景是大模型的训练推理。</p><p>本文介绍CPU计算。CPU计算主要包括业务处理和大数据处理两部分，<strong>CPU运算的瓶颈往往不在于计算，而在于内存、存储和网络</strong>（可能这是ddia 把大数据计算也放到内的原因）。相比于算法模型，CPU计算更侧重于工程。</p><span id="more"></span><h3 id="CPU的计算"><a href="#CPU的计算" class="headerlink" title="CPU的计算"></a>CPU的计算</h3><h4 id="流水线和分支预测、指令重排序"><a href="#流水线和分支预测、指令重排序" class="headerlink" title="流水线和分支预测、指令重排序"></a>流水线和分支预测、指令重排序</h4><p>假设系统只有一个进程运行，进程文件首先被装载到内存。CPU执行的过程大致是：取指（Fetch, 载入指令存入指令寄存器）、解码（Decode，将指令解码）、执行（Execute，执行指令）、访存（Memory Access，执行指令期间可能需要访问内存）和写回（Write Back，将指令执行结果写回内存）。常见的指令有</p><ol><li>x &#x3D; 1, 赋值指令，只需要读存、写存</li><li>x &#x3D; x + 1, 加法指令，需要读存、加法、写存</li><li>if (x), 条件判断指令，需要读存、比较、更新指令寄存器（记录下一个执行的指令）</li></ol><p>假设一个进程有4条指令，执行每个指令都需要取值、解码、执行、访存和写回五步。原始的执行方法每个指令都需要5个CPU周期，总共需要4*5&#x3D;20个周期。其中取值、解码、访存和写回CPU都是空闲的，这时候的CPU利用率只有20%。</p><p>CPU可以采用pipeline（流水线）算法执行以上5条指令，因为取值、解码、访存和写回操作是不占CPU周期的，因此CPU可以在一个周期内完成第一条指令的执行、第二条指令的解码、第三条指令的访存，如图所示。这时候CPU完成4条指令只需要8个CPU周期，CPU利用率为50%。<br><img src="/../images/cpupipeline.png" alt="cpupipeline"></p><p>在流水线算法中，每个指令任务由链式的的子任务组成，有的子任务要操作（执行阶段），有的子任务则只需要看一眼（取指、解码、访存、写回操作），不占用CPU执行周期。摆在CPU面前的是若干并行的指令，CPU每个周期只执行一个任务需要操作的子任务，在多个任务并行的情况下，CPU每个周期都有活干，不会有周期空闲。</p><p>两个因素可能导致流水线暂停</p><ol><li>条件判断指令<br>条件判断指令导致流水线暂停。由于下一条指令取决于条件判断指令的执行结果，CPU需要等待条件判断指令执行完，期间无法正常的流水线任务。（正常的流水线任务旧的指令不断结束，新的指令不断加入流水线，但执行条件判断指令相当于在它执行完之前，无新的指令加入流水线）。</li></ol><p>处理手段是采用分支预测，CPU或编译期会预测条件指令true&#x2F;false哪个概率更高，直接将概率高的指令加入流水线（相当于条件执行转为顺序执行），如果预测失败，流水线u回滚，重新执行分支后的指令。C&#x2F;C++ 可以通过likely&#x2F;unlikely 宏来提醒编译期概率高的条件。</p><ol start="2"><li>指令间相互依赖<br>也就是指令1未完全执行完，指令2无法执行。如果有这样的依赖关系，CPU就不能通过子任务流水线方式运行指令1和2，而是必须等指令1执行完最后一步写回，才能执行指令2。</li></ol><p>处理手段是指令重排序和乱序执行，若指令1，2执行有依赖，如果指令3不依赖1和2，CPU可以转而执行指令3。执行流变为1，3，2，1、3可以流水线并行，3、2也可以流水线并行。</p><p>CPU指令重排序可以保证单线程的排序前后的执行结果一致，但无法保证多线程一致（主要是可见性无法保证）。可以通过在程序中加内存屏障和内存序，保证两个指令之间不会重排序，且store-release指令的执行结果load-acquire指令一定可以看到。</p><h4 id="CPU执行的计算"><a href="#CPU执行的计算" class="headerlink" title="CPU执行的计算"></a>CPU执行的计算</h4><p>CPU的工作分为以下几种</p><ol><li>寄存器赋值，访存等读写操作。为了提高访存效率（CPU获取指令会大量访存，访存会降低CPU使用率）, CPU会引用三级cache。</li><li>x &gt;0 等bool 运算, 用于条件分支判断</li><li>x+1, x*2等整数算数运算</li><li>3.4*5.6 等浮点数运算</li><li>MMU 地址转换，MMU有TLB cache和转换单元组成。操作系统把MMU的输出到物理地址的映射记录到内存地址中，地址先通过MMU运算出结果，再根据结果从内存中找到物理地址。</li><li>CPU硬中断（如缺页中断），转而去指定地址执行中断处理程序</li><li>时钟，记录CPU周期，作为心跳触发CPU循环执行指令</li><li>控制器&#x2F;调度器，负责指令执行更精细化的控制和调度</li></ol><p><strong>CPU像真实的一个人</strong>，他的工作是循环执行指令，这些指令是串行发来的，需要调度器的思考进行分支预测、指令重排序等优化以便于流水线并行。同时随时会有其他的急事通过中断打断他。CPU更适合执行通用复杂的指令，应付各种场景，如果给他一个计算密集型任务，例如密码解密，CPU会很吃力。</p><p>相比之下GPU更像工厂的机器，专门执行特定任务，效率远高于CPU。CPU控制GPU如同现实中的人操纵机器。</p><p><strong>将专用计算从CPU卸载是硬件相当重要的发展方向，</strong>如收发网络包由CPU处理网卡到DMA再到RDMA，浮点运算由CPU 到GPU等。</p><h4 id="CPU的向量化计算"><a href="#CPU的向量化计算" class="headerlink" title="CPU的向量化计算"></a>CPU的向量化计算</h4><p>为了提高CPU的浮点和向量运算能力，英特尔引入了SIMD(Single Instruction, Multiple Data)指令集，SIMD指令集可以实现一条指令计算多个数据，如向量加法、向量乘法、向量比较、向量位运算等。</p><p>SIMD有专门的向量处理单元，SIMD寄存器一般很长，整个向量直接存到寄存器中，向量运算指令将向量数据从寄存器中取出，传入向量运算单元运算，将运算结果写入寄存器。</p><p>SIMD在IO层往往配合列式存储，执行分析运算时。程序首先从存储层读取少量列到内存，然后依靠SIMD指令对列进行向量化运算。列式存储还可以充分利用寄存器和cache的局部性，需要反复计算的向量不必经常访存。列式存储配合数据压缩，减少列式存储的size，尽可能将列数据放于缓存和内存中，减少IO和网络开销，提升性能。</p><p>ClickHouse​ 就是一个采用向量化引擎、列存储和列压缩的高性能分析性数据库。</p><h4 id="增加CPU计算能力和虚拟化"><a href="#增加CPU计算能力和虚拟化" class="headerlink" title="增加CPU计算能力和虚拟化"></a>增加CPU计算能力和虚拟化</h4><p>稳定、性能、成本是分析一个系统的主要切入点，我们从这三个角度分析增加CPU处理能力的手段</p><ol><li>多核CPU，通过多核并行能力提高CPU计算能力。与之而来的是操作系统的多进程&#x2F;线程批处理，目的之一是为了提高CPU处理能力。</li><li>多线程的锁争抢会影响线程执行，线程的阻塞（如阻塞在锁或IO）也会降低CPU的有效利用率。另外由于分配线程需要资源，操作系统能够分配的线程有限。因此引入协程来增强处理能力，协程下层的线程不会阻塞，一般创建CPU核数的线程，线程之上创建大量协程，是计算侧提高CPU利用率的有效方案。</li></ol><p>由于CPU的任务很复杂，不想GPU那样只有单一的矩阵浮点运算任务，因此CPU利用率往往比较波动。可能某时刻有大量请求进来，某时刻请求有比较少。这时候我们希望CPU的计算具有扩展能力。例如我们有一台96核12G的物理机，当请求量变多时，机器用来处理一个服务；当请求量年少时，这个机器可以处理其他服务。这样子这台物理机的CPU利用率会比较稳定。</p><p>计算侧扩展能力就要引入虚拟化，虚拟化的手段主要有两个，虚拟机和docker容器</p><ol><li>虚拟机通过 ​​Hypervisor​​（如 VMware、VirtualBox、KVM）在物理硬件上虚拟化完整的操作系统（Guest OS），每个 VM 独立运行，彼此隔离。虚拟机可以借助VT-x和virtio等技术减少虚拟化的开销。虚拟机的资源隔离性强，但耗费资源多、性能有损失、迁移能力较差，主要使用在云计算的云服务器，是计算和内存资源的包装，属于IASS层。</li><li>容器是操作系统内核提供的虚拟化技术，通过 cgroups 和 namespaces 实现资源隔离。容器相比虚拟机资源消耗低、性能高、迁移能力强，但物理机上的容器公用一个操作系统，资源可能相互影响。容器一般在物理机上以应用的形式运行，当容器资源不足，可以在线扩容容器的CPU和内存资源；若物理机资源不足，可动态将容器迁移至其他物理机。<strong>为了提高容器的调度能力，容器上的服务一般是无状态的</strong>，容器使用存储接口访问物理机或分布式文件系统的存储服务。</li><li>使用容器，降低了服务的计算成本，同时提高了服务的稳定性。一个容器挂了，备用容器会自动顶上来。容器集群中，负责容器调度的是master，而服务所在容器是worker。也就是说，容器集群中，我们的互联网服务，包括收发包、路由、鉴权、流控等，都是分布式计算。而用到的缓存、数据库和文件存储等，是分布式存储。</li></ol><p>由于CPU的任务很复杂，因此CPU利用率往往比较波动，提升比较困难。需要全方面系统的分析。</p><h3 id="大数据计算"><a href="#大数据计算" class="headerlink" title="大数据计算"></a>大数据计算</h3><p>大数据计算的3V问题</p><ol><li>Volume（数据量）​​, PB级数据存储与处理（HDFS和S3）</li><li>Velocity（速度）​​: 实时&#x2F;近实时计算（如Flink）。</li><li>Variety（多样性）​​: 结构化、半结构化、非结构化数据混合处理</li></ol><p>数据的生命周期</p><ol><li>数据获取，离线批处理需要从日志等复杂数据源中获取，而在线处理往往只需要从数据仓库获取关键数据，以提高实时性<ol><li>如日志文件（描述系统的耗时、QPS、trace等），用户请求（请求携带了用户信息、请求参数、用户行为等），数据库和仓库（历史的用户行为，用户画像等）</li><li>用户数据是互联网公司的核心资产之一，互联网流量打的公司也具有更多有价值的数据，如阿里的电商数据、字节的视频数据、百度的搜索数据、腾讯的社交和游戏数据等</li></ol></li><li>数据清洗，数据清洗也是一种大数据处理，往往用于批处理。如统一字段格式，删除重复数据，修正异常数据，对数据进行归一化等</li><li>数据模型处理<ol><li>如果是离线批处理，数据模型处理往往比较简单，例如从用户请求中提取特征和预测标签，将整理好的数据写入到数据仓库。</li><li>如果是在线处理，要拿当前的输入数据和从数据仓库获得价值数据输入模型，结合业务场景（比如推荐、广告、搜索等），拿到TopN的结果（粗排+精排），返回给客户。这个过程需要准确、快速，也需要结合业务影响（例如广告竞价排名，广告推荐等）。</li></ol></li><li>数据输出和存储。对于离线数据处理，数据会输出到数据仓库，对于在线数据处理，数据返回给客户端，或到下一层进一步处理。</li></ol><p>离线数据处理更像是纯粹的分布式计算，而在线数据数据处理需要考虑多种因素，包括实时性、业务场景、准确性指标等。</p><h4 id="OLAP和数据仓库"><a href="#OLAP和数据仓库" class="headerlink" title="OLAP和数据仓库"></a>OLAP和数据仓库</h4><p>数据仓库存储的数据通常是结构化的，即按照事先定义好的格式和模式进行组织和存储，集成了来自多个不同来源的数据。</p><ol><li>数据仓库中的数据是按照一定的主题域进行组织。主题是指用户使用数据仓库进行决策时所关心的重点方面。<strong>数据仓库的数据是用来分析的结构化数据</strong>（对应数据库的数据是主要用来处理用户请求，而非用于数据分析）。</li></ol><p>OLAP（Online Analytical Processing），是一种分析型数据库，<strong>常作为数据仓库的存储引擎</strong>。适合OLAP的场景</p><ol><li>​​数据以批量&#x2F;流式​顺序​写入​​，插入和更新操作少。读取时不按照主键读取一行，而是直接读取一列</li><li>每个列代表维度，例如数据设计时间、区域、用户群等多维度</li></ol><p>OLTP（Online Transaction Processing）OLTP通常按行（记录）存储，OLTP支持按主键读取一行，和更新数据等。OLAP表往往直接按照列读取用于分析，行数通常远大于列数（例如实时日志、用户实时特征数据等），往往以列的方式存储。</p><p>显然OLAP适合少量维度数据，每个维度大量数据的数据挖掘读取。OLAP是数据仓库的存储引擎，从数据源获取数据，进行数据清洗后，将数据写入到OLAP。OLAP支持数据挖掘模型按列读取数据进行分析处理（例如降维、预测等，会增加或减少维度），将数据处理结果写回到OLAP。</p><h4 id="ETL-离线大数据处理流程"><a href="#ETL-离线大数据处理流程" class="headerlink" title="ETL 离线大数据处理流程"></a>ETL 离线大数据处理流程</h4><p>大数据的ETL（Extract, Transform, Load）​模型​ 是数据从<strong>源系统到目标数据仓库或数据湖</strong>的核心流程</p><ol><li>​​数据抽取（Extract）​，从数据库、文件、API等拉取数据，支持全量&#x2F;增量同步</li><li>​​数据转换（Transform）​清洗（去重、缺失值处理）、标准化（字段映射）、聚合计算</li><li>​​数据加载（Load）​写入目标存储（数据仓库、数据湖），优化存储格式（列存&#x2F;分区</li></ol><p>例如，电商用户行为数据ETL​<br>​1. ​抽取​​：从Nginx日志（JSON）和MySQL订单表增量拉取数据。<br>​2. ​转换​​：日志解析（提取user_id、event_time）。订单表与日志数据JOIN，生成用户行为宽表。<br>3. ​加载​​：写入Hive分区表（按dt分区）供BI分析。</p><p>可以看到，离线大数据处理真正模型计算的部分比较简单，大致就是select检索，非结构化数据解析和清洗，维度聚合等，且计算模型往往是框架提供的。大多数的工作量在数据抽取、数据清洗上的计算、存储上的优化上。（相对比较无趣）</p><p>湖仓一体化，用数据湖（主要是S3）存储原始数据（结构化、半结构化、非结构化），数据仓库存储经过清洗、结构化处理的数据。模型的分析从数据仓库（OLAP）读取数据、处理、写回数据。</p><h4 id="Flink-实时数据处理"><a href="#Flink-实时数据处理" class="headerlink" title="Flink 实时数据处理"></a>Flink 实时数据处理</h4><p>在线数据处理的场景包括搜索、推荐、广告等，需要实时性，结果准确，同时需要结合业务。Apache Flink是一个面向分布式数据流处理和批量数据处理的开源计算平台, 本部门主要看流处理。</p><p>Flink的架构</p><ol><li>Flink支持通过producer-consumer模型接受需要处理的流数据，将流数据源做我datasource</li><li>JobManager是Flink系统的协调者，它负责接收Flink Job，调度组成Job的多个子Task的执行。JobManager还负责收集Job的状态信息。</li><li>TaskManager也是一个Actor，它是实际负责执行计算的Worker，负责执行Flink Job的Task。</li><li>每个task对应flink的一个算子，如map(…).setParallelism(2), 可并行执行</li><li>Flink基于Checkpoint机制实现容错，它的原理是不断地生成分布式Streaming数据流Snapshot。在流处理失败时，通过这些Snapshot可以恢复数据流处理。</li></ol><p><img src="/../images/flink.png" alt="flink"></p><p>应用场景</p><ol><li><p>日志实时监控<br>例如队列接受数据源的日志数据，实时监控服务器日志、应用性能指标，触发异常告警（如错误率突增、服务宕机）。</p></li><li><p>实时推荐系统<br>通过消息队列接受用户实时行为（点击、搜索），读取OLAP的用户画像，调用模型预测，将推荐结果返回给用户</p></li></ol><p><img src="/../images/onlineprocess.png" alt="onlineprocess"></p><p>基于CPU的大数据计算是低维向量运算，计算量并不大。大数据计算的瓶颈往往不在于计算，而在于内存&#x2F;存储。相比于算法模型，大数据计算更侧重于工程。</p>]]></content>
      
      
      <categories>
          
          <category> compute </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compute </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程语言——C++右值和右值引用</title>
      <link href="/2025/04/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94C++%E5%8F%B3%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
      <url>/2025/04/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94C++%E5%8F%B3%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>C++右值和右值引用是最容易用错的特性之一，相关教程普遍写得不清晰。实际上，只有在所有权转移时才需要使用右值引用，移动语义移动的是所有权，完美转发转发的也是所有权。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>先放总结</p><ol><li>左值引用的语义是绑定、const指针和不转移所有权(rust称为借用)，右值引用的语义是绑定、const指针和转移所有权</li><li><strong>是否使用右值引用，取决于是否要转移变量所有权</strong>。右值引用和左值引用在传参时都不会调用构造函数，性能一样高效。</li><li><strong>如果是字面量, 如果只是读字面量，直接用const&amp; 参数接收即可</strong> （最常见）。如果要转移所有权，例如使用容器时，字面值在当前函数创建随即交给容器，字面量的生命周期后续由容器负责。这时候容器函数应该使用&amp;&amp;，例如emplace()的接口就是右值引用。const&amp;和&amp;&amp;的开销都是一次字面量的构造函数</li><li><strong>如果是左值，如果需要转移所有权，推荐使用&amp;&amp;和std::move()。如果不要, 用左值引用或指针即可</strong>。是不是要转移所有权，在于你想要这个左值变量在当前函数析构，还是在函数外析构</li><li>新建对象，通过传std::move()左值，可以通过移动构造加快构造速度。如果传字面量，通过可以通过移动构造加快速度。但如果传左值，则需要调用拷贝构造函数。</li><li>函数返回值不要考虑右值引用，右值引用只在函数参数上使用</li></ol><span id="more"></span><h3 id="右值和右值引用"><a href="#右值和右值引用" class="headerlink" title="右值和右值引用"></a>右值和右值引用</h3><p>也许只有C++语言才有左值和右值的概念，程序语言中，左值和右值普遍的概念分别是变量和字面量。</p><p>变量可以认为是到内存地址的映射，(变量-&gt;内存地址)，通过变量我们可以拿到想访问内存的地址，修改变量也就是修改指定地址中的内存。显然变量，或者说左值是可以取地址的。</p><p>字面量是程序中写的值，这完全是编译期的概念。编译器编译成运行的指令，将字面量放入内存中。运行期时，只能通过变量来获取值（指针也是一种变量）。因此，变量&#x2F;左值是编译期和运行期都存在的概念，而字面量&#x2F;右值只是编译期的概念！</p><p>这也导致了左值引用和右值引用的区别，左值引用同时是编译期语义和运行期语义</p><ol><li>编译期语义，左值引用是一种静态类型，静态类型也是编译期的语义，运行期不存在静态类型的语义。引用类型的语义是绑定，也就是左值引用可以绑定左值，右值引用可以绑定右值。</li><li>运行期语义，左值引用在运行期的语义基本等于const 指针, 即可以修改引用的对象，但不能修改指针的指向。</li></ol><p>右值引用同样1. 编译期语义，右值引用也是静态类型, 可以绑定右值 2. 运行期语言，右值引用记录字面量对象的地址</p><p>注意<strong>字面量虽然不能被取地址，但它是有地址的，右值引用就记录字面量对象的地址。因此右值引用可以取地址，修改字面量对象，和左值引用一样。</strong></p><h4 id="引用绑定和构造函数"><a href="#引用绑定和构造函数" class="headerlink" title="引用绑定和构造函数"></a>引用绑定和构造函数</h4><p>引用类型的编译期语义是绑定，类型的构造函数，即拷贝构造、移动构造、拷贝赋值和移动赋值就是<strong>依赖引用类型的绑定来接收左值或右值</strong>。</p><p>下列代码可以得到</p><ol><li>拷贝构造和拷贝赋值传入左值引用，移动构造和移动赋值传入右值引用。这代表编译期拷贝函数的参数需要绑定左值，移动函数的参数需要绑定右值。如果传入左值，则不可调用移动函数，反之不可调用拷贝函数。</li><li>在使用变量创建IntVector时，由于拷贝函数绑定左值，因此会调用拷贝函数; 使用字面量(如IntVector{})创建IntVector，会调用移动函数。</li><li>移动构造和移动赋值的语义是所有权转移，例如使用字面量创建IntVector{}，如auto x &#x3D; IntVector(IntVector{});, 代表字面量对象的所有权交给了新建的对象x。</li></ol><p>移动构造和移动赋值的所有权语言更典型的体现是在容器中，例如vec.emplace_back(1), 表示字面量的所有权交给了vec容器。清理容器时会清理这个字面量，字面量的生命周期由容器控制，不再由函数控制。</p><p>std::move可以把左值转为右值，这也是编译期的概念。例如vec.emplace_back(std::move(a)), 表示a的所有权交给了vec容器。清理vec时会清理a，<strong>a的生命周期由vec控制，不再由函数控制。</strong> 变量通过转换成右值，借助移动构造函数将所有权转移，当前函数后续就不能直接操作这个变量，当前函数不具有变量的所有权。</p><p>简单讲一下所有权，所有权代表生命周期控制，函数&#x2F;对象都可以持有所有权。持有所有权代表函数&#x2F;类负责对象的生命周期，例如类持有成员变量的所有权吗，<strong>当对象的生命周期脱离控制，也就是失去了该对象的所有权。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// std::copy</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>   <span class="comment">// std::swap</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntVector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">IntVector</span>() : <span class="built_in">data_</span>(<span class="literal">nullptr</span>), <span class="built_in">size_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">IntVector</span><span class="params">(<span class="type">size_t</span> size)</span> </span></span><br><span class="line"><span class="function">        : data_(new int[size]), size_(size) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">IntVector</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数（深拷贝）</span></span><br><span class="line">    <span class="built_in">IntVector</span>(<span class="type">const</span> IntVector&amp; other) </span><br><span class="line">        : <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">int</span>[other.size_]), <span class="built_in">size_</span>(other.size_) &#123;</span><br><span class="line">        std::<span class="built_in">copy</span>(other.data_, other.data_ + size_, data_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数（转移资源）</span></span><br><span class="line">    <span class="built_in">IntVector</span>(IntVector&amp;&amp; other) <span class="keyword">noexcept</span> </span><br><span class="line">        : <span class="built_in">data_</span>(other.data_), <span class="built_in">size_</span>(other.size_) &#123;</span><br><span class="line">        other.data_ = <span class="literal">nullptr</span>; <span class="comment">// 置空原对象指针</span></span><br><span class="line">        other.size_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">    IntVector&amp; <span class="keyword">operator</span>=(<span class="type">const</span> IntVector&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123; <span class="comment">// 避免自我赋值</span></span><br><span class="line">            <span class="keyword">delete</span>[] data_;   <span class="comment">// 释放现有资源</span></span><br><span class="line">            data_ = <span class="keyword">new</span> <span class="type">int</span>[other.size_];</span><br><span class="line">            size_ = other.size_;</span><br><span class="line">            std::<span class="built_in">copy</span>(other.data_, other.data_ + size_, data_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值运算符</span></span><br><span class="line">    IntVector&amp; <span class="keyword">operator</span>=(IntVector&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data_;    <span class="comment">// 释放现有资源</span></span><br><span class="line">            data_ = other.data_;</span><br><span class="line">            size_ = other.size_;</span><br><span class="line">            other.data_ = <span class="literal">nullptr</span>; <span class="comment">// 置空原对象</span></span><br><span class="line">            other.size_ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数组大小</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) &#123; <span class="keyword">return</span> data_[index]; &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) <span class="type">const</span> &#123; <span class="keyword">return</span> data_[index]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换函数（辅助移动赋值）</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(IntVector&amp; a, IntVector&amp; b)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(a.data_, b.data_);</span><br><span class="line">        <span class="built_in">swap</span>(a.size_, b.size_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data_;</span><br><span class="line">    <span class="type">size_t</span> size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这部分总结就是</p><ol><li>左值引用和右值引用的编译期语义分别是绑定左值和右值</li><li>拷贝函数参数是左值引用，它绑定一个左值，根据这个左值拷贝得到新对象；</li><li>移动函数参数是右值引用，它绑定一个右值，根据这个右值移动得到新对象。移动构造函数实现时可以移动右值的成员到新对象，可以减少拷贝，这本身是所有权转移，于是右值引用又增加了移动所有权的语义。</li></ol><p>前面讲到左值引用和右值引用都有绑定和指针的语义，这里又增加了右值引用的移动所有权的语义，相反左值引用的语义则是不移动所有权</p><ol><li>需要注意C++的灵活性，你通过左值引用传左值到新函数，同时在新函数将该左值析构。这代码上没错，但违反了左值引用不移动所有权的语义。正确的使用是传通过右值引用传右值到新函数，新函数可以将该右值移动或析构。在rust中，前一种操作会直接编译报错。</li><li><strong>总之编码时只有右值引用才转移所有权（例如将unique_ptr传给新函数，推荐使用右值引用，因为发生所有权转移）。传指针&#x2F;引用都不应该转移所有权，这种编码风格才是推荐的。通过函数参数就知道对象被谁管理。</strong></li></ol><p>为什么不拷贝&#x2F;移动函数不使用值传递，因为值传递过程中就需要拷贝，拷贝有需要拷贝函数。。。拷贝函数&#x2F;移动函数通过左值引用和右值引用，在传参时都不会有拷贝。</p><h4 id="移动函数和拷贝函数的调用时机"><a href="#移动函数和拷贝函数的调用时机" class="headerlink" title="移动函数和拷贝函数的调用时机"></a>移动函数和拷贝函数的调用时机</h4><p>观察下面程序，可以得到</p><ol><li><code>MyClass bb = a</code> 调用构造函数，<code>MyClass bb; bb = std::move(a)</code> 调用赋值函数。</li><li>执行<code>c = MyClass&#123;&#125;</code>，虽然是调用移动函数, 但会MyClass{}字面量的构造需要调用一次构造函数。<code>MyClass bb = a</code> 只需要一次拷贝构造函数，不用构造函数</li><li><code>c = std::move(a);</code> 是真正的只要调用一次移动赋值函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// std::copy</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>   <span class="comment">// std::swap</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;构造函数\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;析构函数\n&quot;</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;拷贝构造函数\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;移动构造函数\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;拷贝赋值函数\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;移动赋值函数\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass a;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;MyClass b(a);\n&quot;</span>);</span><br><span class="line">    <span class="function">MyClass <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;MyClass bb = a;\n&quot;</span>);</span><br><span class="line">    MyClass bb = a;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;MyClass c(std::move(a));\n&quot;</span>);</span><br><span class="line">    <span class="function">MyClass <span class="title">c</span><span class="params">(std::move(a))</span></span>;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;b = a\n&quot;</span>);</span><br><span class="line">    b = a;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;c = std::move(a)\n&quot;</span>);</span><br><span class="line">    c = std::<span class="built_in">move</span>(a);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;c = MyClass&#123;&#125;;\n&quot;</span>);</span><br><span class="line">    c = MyClass&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">构造函数</span><br><span class="line"><span class="function">MyClass <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">拷贝构造函数</span><br><span class="line">MyClass bb = a;</span><br><span class="line">拷贝构造函数</span><br><span class="line"><span class="function">MyClass <span class="title">c</span><span class="params">(std::move(a))</span></span>;</span><br><span class="line">移动构造函数</span><br><span class="line">b = a</span><br><span class="line">拷贝赋值函数</span><br><span class="line">c = std::<span class="built_in">move</span>(a)</span><br><span class="line">移动赋值函数</span><br><span class="line">c = MyClass&#123;&#125;;</span><br><span class="line">构造函数</span><br><span class="line">移动赋值函数</span><br><span class="line">析构函数</span><br><span class="line">析构函数</span><br><span class="line">析构函数</span><br><span class="line">析构函数</span><br><span class="line">析构函数</span><br></pre></td></tr></table></figure><p>字面量使用const&amp;和&amp;&amp;的区别,<br>观察下面程序，可以看到</p><ol><li>const&amp;和&amp;&amp;作为引用，传参时都不会调用构造函数</li><li>左值优先匹配const&amp;，右值优先匹配&amp;&amp;</li><li>std::move()后的左值优先匹配&amp;&amp;</li><li>const&amp; 函数对传的变量只能只读, 而&amp;&amp;可以修改参数变量。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> MyClass&amp; object)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;const&amp; 接收\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(MyClass&amp;&amp; object)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;&amp;&amp;接收\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">const</span> MyClass&amp; object)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;强制const&amp; 接收\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass object1;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;func(object1);\n&quot;</span>);</span><br><span class="line">    <span class="built_in">func</span>(object1);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;func(std::move(object1));\n&quot;</span>);</span><br><span class="line">    <span class="built_in">func</span>(std::<span class="built_in">move</span>(object1));</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;func(MyClass());\n&quot;</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="built_in">MyClass</span>());</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;func1(MyClass());\n&quot;</span>);</span><br><span class="line">    <span class="built_in">func1</span>(<span class="built_in">MyClass</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">构造函数</span><br><span class="line"><span class="built_in">func</span>(object1);</span><br><span class="line"><span class="type">const</span>&amp; 接收</span><br><span class="line"><span class="built_in">func</span>(std::<span class="built_in">move</span>(object1));</span><br><span class="line">&amp;&amp;接收</span><br><span class="line"><span class="built_in">func</span>(<span class="built_in">MyClass</span>());</span><br><span class="line">构造函数</span><br><span class="line">&amp;&amp;接收</span><br><span class="line">析构函数</span><br><span class="line"><span class="built_in">func1</span>(<span class="built_in">MyClass</span>());</span><br><span class="line">构造函数</span><br><span class="line">强制<span class="type">const</span>&amp; 接收</span><br><span class="line">析构函数</span><br><span class="line">析构函数</span><br></pre></td></tr></table></figure></li></ol><p>右值引用可以设置值，取地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(MyClass&amp;&amp; object)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;&amp;&amp;接收\n&quot;</span>);</span><br><span class="line">    object.a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;object address %p\n&quot;</span>, &amp;object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左值引用的取地址是绑定变量的地址</p><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p>前面讲了函数参数，我们得到当传一个左值或右值且所有权转移，使用右值引用绑定；否则使用左值引用或指针绑定。</p><p>引用传参，无论是左值引用还是右值引用，都不会触发构造语义。如果我们返回一个对象呢，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MyClass</span>();  <span class="comment">// ✅ RVO 触发，直接在调用处构造</span></span><br><span class="line">&#125;</span><br><span class="line">MyClass x = <span class="built_in">create</span>();</span><br></pre></td></tr></table></figure><p>事实上返回值一般会执行返回值优化，即返回的对象在调用处直接构造，无须构造临时对象。因此我们没有任何必要调用<code>return std::move(xx)</code>。</p><p>实际编码中，我们推荐</p><ol><li>使用引用或指针函数参数只读或修改对象</li><li>用专门的工厂函数创建对象，并返回对象的指针，或者返回shared_from_this()</li><li>函数返回错误码，尽量避免返回对象</li></ol><p>因此右值引用一般只用于函数参数，用来绑定右值并执行移动语义和所有权转移，无须在返回值中考虑右值引用</p><h4 id="什么时候用右值引用"><a href="#什么时候用右值引用" class="headerlink" title="什么时候用右值引用"></a>什么时候用右值引用</h4><p>由上我们总结, 右值引用和左值引用在传参时都不会调用构造函数，性能一样高效。是否使用右值引用，取决于是否要转移变量所有权<br>1.<strong>如果是字面量, 如果只是读字面量，直接用const&amp; 参数接收即可</strong> 。如果要转移所有权，例如使用容器时，字面值在当前函数创建随即交给容器，字面量的生命周期后续由容器负责。这时候容器函数应该使用&amp;&amp;，例如emplace()的接口就是右值引用。使用左值引用接收右值，需要1构造+1拷贝函数，而右值引用需要1构造+1移动函数<br>2. <strong>如果是左值，如果需要转移所有权，推荐使用&amp;&amp;和std::move()。如果不要, 用左值引用或指针即可</strong>。是不是要转移所有权，在于你想要这个左值变量在当前函数析构，还是在函数外析构<br>3. 移动构造函数使用右值引用作为参数，可以加快构造速度。但移动构造函数只有在新建对象时才使用。<br>4. 函数返回值不要考虑右值引用，右值引用只在函数参数上使用</p><h4 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h4><p>std::move(x) 将左值转为右值，从而利用右值引用函数参数(右值也是转成右值)</p><p><code>std::forward&lt;T&gt;</code>, 若T是左值引用，返回左值。若 T 是右值引用，返回右值。完美转发主要处理《右值引用也是一种左值》这个问题，使用forward，可以把右值引用再次转成右值，从而继续使用下一个函数的右值引用函数参数。</p><p>所有权语义上分析，完美转发就是在A函数将对象所有权转移到B函数，B函数再将对象所有权转给C函数。移动语义移动的是所有权，完美转发转发的也是对象所有权。</p><p>如果参数是通用引用，对于需要转移所有权的右值引用，B函数会将参数传递给C函数，对于无须转移所有权的左值引用，B函数不会转移所有权给C函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;左值: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;右值: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">relay</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg)); <span class="comment">// 完美转发, 二次转发对象。arg如果是左值引用，这里转型为左值，如果是右值引用，这里转型为右值</span></span><br><span class="line">    <span class="comment">// 如果是process(arg), arg将一直认为是左值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">relay</span>(a);       <span class="comment">// 传递左值 → 调用 process(int&amp;)</span></span><br><span class="line">    <span class="built_in">relay</span>(<span class="number">20</span>);      <span class="comment">// 传递右值 → 调用 process(int&amp;&amp;)</span></span><br><span class="line">    <span class="built_in">relay</span>(std::<span class="built_in">move</span>(a)); <span class="comment">// 传递右值引用 → 调用 process(int&amp;&amp;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转型、左右值、左右值函数引用，函数参数优先匹配等逻辑，都是编译期的行为。</p>]]></content>
      
      
      <categories>
          
          <category> base </category>
          
      </categories>
      
      
        <tags>
            
            <tag> language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程语言——C++协程和高性能编程</title>
      <link href="/2025/04/20/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94C++%E5%8D%8F%E7%A8%8B%E5%92%8C%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/"/>
      <url>/2025/04/20/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94C++%E5%8D%8F%E7%A8%8B%E5%92%8C%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>C++可以写出性能高效的程序，一个原因来自语言本身的因素，例如</p><ol><li>C++程序编译器可以进行优化，编译直接得到机器码，这让编译后需要执行的指令更少（解释器性能比编译期差的主要原因就是是解释器单行编译执行，而编译器是文件编译执行，获得的信息更多，优化空间更大。明确的类型信息也让编译期获得内存信息，可以在无须创建对象情况下进行优化）</li><li>没有虚函数的C++程序编译后的执行码和C语言一样，没有golang interface{}, java 虚函数等额外的内存开销。C++的class, template等功能抽象不会带来额外的性能开销</li><li>C++可以直接管理内存，轻松写出内存零拷贝的程序，无需GC额外的性能开销。</li></ol><p>除了语言本身的因素，生态因素对于高性能同样重要。用户程序不可能每次都造轮子，如果没有高性能的库，C++不会成为性能高效程序的首选。例如Python语言的性能虽然差，但python有tensorflow, pytorch等高性能神经网络框架，这让python写出的神经网络性能同样高效。</p><p>dpdk和spdk工具链让C++开发高性能网络服务器和高性能存储服务变得容易，GPU等新硬件和cuda等生态让C++成为高性能计算的基础。C++20提供了协程支持，deepseek 开源的3FS 就是C++20高性能编程的典型例子。</p><span id="more"></span><h3 id="C-20协程"><a href="#C-20协程" class="headerlink" title="C++20协程"></a>C++20协程</h3><p>C++20 提供了协程支持，协程可以看做任务，任务执行期间可以在某个位置暂停-继续。</p><p>C++ 提供std::coroutine_handle&lt;&gt;作为协程句柄, 协程句柄需要传入自定义的Promise类型，用来指定协程的返回值，初始化和退出行为等。<br>promise_type 必须实现以下成员函数</p><ol><li><code>std::coroutine_handle&lt;promise&gt;</code> get_return_object() 返回coroutine_handle对象</li><li>initial_suspend()控制协程启动时是否立即挂起，返回 suspend_always 表示协程创建后挂起, 需要调用一次resume才会执行, 返回 suspend_never表示协程创建后立即执行</li><li>final_suspend()控制协程结束时是否挂起, 同样可以返回 suspend_always 或者 suspend_never</li><li>yield_value(value)接受co_yield 表达式返回值, 可以处理</li><li>return_value(value)  接受co_return value返回值，可以处理</li><li>return_void() 执行co_return后执行该函数</li><li>unhandled_exception()处理协程中未捕获的异常。</li></ol><p>通过以上函数，可以实现协程创建后，销毁前，co_return&#x2F;co_yield之后的行为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    T current_value;</span><br><span class="line">    <span class="comment">// 协程挂起时的返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">yield_value</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        current_value = value;</span><br><span class="line">        <span class="keyword">return</span> std::suspend_always&#123;&#125;; <span class="comment">// 每次生成后暂停</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 协程初始化设置</span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">    <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123; std::<span class="built_in">terminate</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::coroutine_handle&lt;promise_type&gt;;</span><br></pre></td></tr></table></figure><p>协程一重要的关键字是co_await，表示挂起当前协程，执行流切换到其他任务。co_await 后面需要加Awaiter对象.<br>awaiter必须要实现的三个函数</p><ol><li>bool await_ready() const noexcept; 表示调用co_await后是否立即执行，如果返回true，则直接执行，不会挂起当前协程。</li><li>void await_suspend(std::coroutine_handle&lt;&gt; handle) noexcept; 参数为当前协程句柄, 可以将执行流切给指定的coroutine_handle</li><li>T await_resume() noexcept; 当协程处于co_await状态，调用resume时执行该函数。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">custom_awaiter</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否直接继续执行（true=不挂起）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起时执行（参数为当前协程句柄）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; h)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复时执行的逻辑与返回值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>协程执行例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义协程返回类型 Task</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        <span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;创建协程对象\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> Task&#123;std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="comment">// 返回suspend_always 对象, 协程初始化后挂起</span></span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;初始化挂起\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="comment">// 协程结束后挂起</span></span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;最终挂起\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;协程返回\n&quot;</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            std::<span class="built_in">terminate</span>(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; handle;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Task</span><span class="params">(std::coroutine_handle&lt;promise_type&gt; h)</span> : handle(h) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Task</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (handle) handle.<span class="built_in">destroy</span>();</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;销毁协程\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 恢复当前协程执行</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!handle.<span class="built_in">done</span>()) &#123;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;恢复协程执行\n&quot;</span>);</span><br><span class="line">            handle.<span class="built_in">resume</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义可等待对象（Awaiter）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AsyncOperation</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;检查是否就绪\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 总是挂起</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; h)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;开始异步操作...\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 新建额外线程, suspend不阻塞</span></span><br><span class="line">        std::<span class="built_in">thread</span>([h] &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;异步操作完成\n&quot;</span>);</span><br><span class="line">            h.<span class="built_in">resume</span>(); <span class="comment">// 完成后恢复协程</span></span><br><span class="line">        &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;处理操作结果\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 协程函数定义</span></span><br><span class="line"><span class="function">Task <span class="title">my_coroutine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;协程开始执行\n&quot;</span>);</span><br><span class="line">    <span class="keyword">co_await</span> AsyncOperation&#123;&#125;; <span class="comment">// 等待异步操作</span></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;继续执行协程体\n&quot;</span>);</span><br><span class="line">    <span class="keyword">co_await</span> std::suspend_always&#123;&#125;; <span class="comment">// 主动挂起</span></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;协程最终阶段\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Task task = <span class="built_in">my_coroutine</span>(); <span class="comment">// 创建并初始化协程, 协程挂起</span></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;首次恢复协程:\n&quot;</span>);</span><br><span class="line">    task.<span class="built_in">resume</span>();             <span class="comment">// 第一次, 启动协程</span></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;执行流切回主线程:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;二次恢复协程:\n&quot;</span>);</span><br><span class="line">    task.<span class="built_in">resume</span>();             <span class="comment">// 第二次恢复</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;\n程序结束\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">创建协程对象</span><br><span class="line">初始化挂起</span><br><span class="line">首次恢复协程:</span><br><span class="line">恢复协程执行</span><br><span class="line">协程开始执行</span><br><span class="line">检查是否就绪</span><br><span class="line">开始异步操作...</span><br><span class="line">执行流切回主线程:</span><br><span class="line">异步操作完成</span><br><span class="line">处理操作结果</span><br><span class="line">继续执行协程体</span><br><span class="line">二次恢复协程:</span><br><span class="line">恢复协程执行</span><br><span class="line">协程最终阶段</span><br><span class="line">协程返回</span><br><span class="line">最终挂起</span><br><span class="line"></span><br><span class="line">程序结束</span><br><span class="line">销毁协程</span><br></pre></td></tr></table></figure><p>执行流分析</p><ol><li>Task task &#x3D; my_coroutine() 时，创建协程和初始化对象, 分别执行Task get_return_object() 和std::suspend_always initial_suspend()两个函数</li><li>task.resume(); 执行会启动协程，协程执行到co_await，挂起。协程挂起后，执行流交给main函数, 也就是调用resume()的函数</li><li>await_suspend 创建了新线程用来执行异步任务，异步任务执行完成后在新线程中调用h.resume()，协程继续在新线程执行，主线程这时候在sleep()</li><li>新线程继续执行协程，直到co_await std::suspend_always{}; 直接挂起（显然std::suspend_always{}; 也是一种awaiter表示无条件挂起）。这时候新线程执行完毕退出，但协程对象挂在co_await</li><li>最后主线程sleep()完执行task.resume(); 协程又继续执行, 直到协程执行完毕, 调用final_suspend由于final_suspend返回std::suspend_always{};，协程被挂起而不是销毁</li><li>主线程执行完毕, 最后调用handle.destroy();销毁协程</li></ol><p>执行co_await 时将当前协程交给线程池异步执行, 当前协程切回协程resume的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadPoolAwaiter</span> &#123;</span><br><span class="line">    ThreadPool&amp; pool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; h)</span> </span>&#123;</span><br><span class="line">        pool.<span class="built_in">enqueue</span>([h] &#123; h.<span class="built_in">resume</span>(); &#125;); <span class="comment">// 提交到线程池</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">co_await</span> ThreadPoolAwaiter&#123;my_thread_pool&#125;;</span><br></pre></td></tr></table></figure><h4 id="协程链式调用"><a href="#协程链式调用" class="headerlink" title="协程链式调用"></a>协程链式调用</h4><p>我们想要像函数调用那样实现协程调用, 也是co_awaiter一个协程, 当子协程执行完毕后, 返回给父协程继续执行。</p><ol><li>这样的子协程是一个类, 需要实现promise_type管理协程生命周期, 也需要实现Awaiter 接受co_await调用</li><li>await_suspend函数会传父协程handle，需要把它记住。当子协程执行完毕, 需要在final_suspend()中把父协程恢复。</li></ol><p>举例, </p><ol><li>每个协程函数都返回Task类型。执行co_await Task, 会调用Task的await_suspend(), 将父协程设置成子协程的nextjob, 返回当前协程(Task同时是Awaiter和协程), 表示执行当前协程</li><li>对于PromiseBase, final_suspend() 返回一个FinalAwaiter.协程销毁后会调用FinalAwaiter的await_suspend(), 执行协程的nextjob，也就是恢复父协程<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">struct</span> <span class="title class_">FinalAwaiter</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> -&gt; <span class="type">bool</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;Promise&gt; handle)</span> <span class="keyword">noexcept</span> -&gt; <span class="type">void</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="built_in">assert</span>(handle.<span class="built_in">done</span>() &amp;&amp; <span class="string">&quot;handle should done here&quot;</span>);</span><br><span class="line">      <span class="keyword">auto</span>&amp; promise = handle.<span class="built_in">promise</span>();</span><br><span class="line">      <span class="comment">// 这一步同时更新了promise.mNextJob==nullptr, 也就是标识task执行完了</span></span><br><span class="line">      <span class="keyword">auto</span> next = promise.mNextJob.<span class="built_in">exchange</span>(<span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">if</span> (next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (promise.<span class="built_in">getState</span>() != <span class="literal">nullptr</span>) [[unlikely]] &#123;</span><br><span class="line">          promise.<span class="built_in">getState</span>()-&gt;<span class="built_in">store</span>(JobState::Final, std::memory_order_release);</span><br><span class="line">          promise.<span class="built_in">getState</span>()-&gt;<span class="built_in">notify_one</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next == &amp;detail::kDetachJob) &#123;</span><br><span class="line">        <span class="keyword">if</span> (promise.<span class="built_in">getState</span>() != <span class="literal">nullptr</span>) [[unlikely]] &#123;</span><br><span class="line">          promise.<span class="built_in">getState</span>()-&gt;<span class="built_in">store</span>(JobState::Final, std::memory_order_release);</span><br><span class="line">          promise.<span class="built_in">getState</span>()-&gt;<span class="built_in">notify_one</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        promise.mThisHandle.<span class="built_in">destroy</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next != &amp;detail::kEmptyJob) &#123;</span><br><span class="line">        <span class="comment">// 把nextjob加入到loop, 由主线程执行(ExeOpt::prefInOne)</span></span><br><span class="line">        Proactor::<span class="built_in">get</span>().<span class="built_in">execute</span>(next, ExeOpt::<span class="built_in">prefInOne</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> -&gt; <span class="type">void</span> </span>&#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PromiseBase</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">initial_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> -&gt; std::suspend_always </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> -&gt; FinalAwaiter </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">unhandled_exception</span><span class="params">()</span> <span class="keyword">noexcept</span> -&gt; <span class="type">void</span> </span>&#123; mExceptionPtr = std::<span class="built_in">current_exception</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">setNextJob</span><span class="params">(WorkerJob* next)</span> <span class="keyword">noexcept</span> -&gt; <span class="type">void</span> </span>&#123; mNextJob = next; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">getNextJob</span><span class="params">()</span> <span class="keyword">noexcept</span> -&gt; std::atomic&lt;WorkerJob*&gt;&amp; </span>&#123; <span class="keyword">return</span> mNextJob; &#125;</span><br><span class="line"></span><br><span class="line">  CoroJob mThisJob&#123;<span class="keyword">this</span>, &amp;CoroJob::run&#125;;</span><br><span class="line">  std::coroutine_handle&lt;&gt; mThisHandle;</span><br><span class="line">  std::atomic&lt;WorkerJob*&gt; mNextJob&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">  std::exception_ptr mExceptionPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> promise_type = Promise&lt;T&gt;;</span><br><span class="line">  <span class="keyword">using</span> coroutine_handle_type = std::coroutine_handle&lt;promise_type&gt;;</span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Task</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Task</span><span class="params">(coroutine_handle_type handle)</span> <span class="keyword">noexcept</span> : mHandle(handle)</span></span><br><span class="line"><span class="function">  &#123;</span></span><br><span class="line">    <span class="built_in">assert</span>(mHandle != <span class="literal">nullptr</span>);</span><br><span class="line">    mHandle.<span class="built_in">promise</span>().<span class="built_in">setCoHandle</span>(mHandle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">AwaiterBase</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> -&gt; <span class="type">bool</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;Promise&gt; handle)</span> <span class="keyword">noexcept</span> -&gt; <span class="type">void</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">// 设置为handle.promise.nextjob</span></span><br><span class="line">      mHandle.<span class="built_in">promise</span>().<span class="built_in">setNextJob</span>(handle.<span class="built_in">promise</span>().<span class="built_in">getThisJob</span>());</span><br><span class="line">      mHandle.<span class="built_in">promise</span>().<span class="built_in">setState</span>(handle.<span class="built_in">promise</span>().<span class="built_in">getState</span>());</span><br><span class="line">        <span class="comment">// 执行当前协程</span></span><br><span class="line">      Proactor::<span class="built_in">get</span>().<span class="built_in">execute</span>(mHandle.<span class="built_in">promise</span>().<span class="built_in">getThisJob</span>(), ExeOpt::<span class="built_in">prefInOne</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    coroutine_handle_type mHandle;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li></ol><p>folly库实现的协程链式调用</p><ol><li>保存父协程promise.continuation_ &#x3D; continuation;</li><li>返回当前task的coro_handle, coro_, 执行当前task</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line"><span class="function">FOLLY_NOINLINE <span class="keyword">auto</span> <span class="title">await_suspend</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    coroutine_handle&lt;Promise&gt; continuation)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(coro_);</span><br><span class="line">  <span class="keyword">auto</span>&amp; promise = coro_.<span class="built_in">promise</span>();</span><br><span class="line"></span><br><span class="line">  promise.continuation_ = continuation;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span>&amp; calleeFrame = promise.<span class="built_in">getAsyncFrame</span>();</span><br><span class="line">  calleeFrame.<span class="built_in">setReturnAddress</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(detail::promiseHasAsyncFrame_v&lt;Promise&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; callerFrame = continuation.<span class="built_in">promise</span>().<span class="built_in">getAsyncFrame</span>();</span><br><span class="line">    folly::<span class="built_in">pushAsyncStackFrameCallerCallee</span>(callerFrame, calleeFrame);</span><br><span class="line">    <span class="keyword">return</span> coro_;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    folly::<span class="built_in">resumeCoroutineWithNewAsyncStackRoot</span>(coro_);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(coro_);</span><br><span class="line">  SCOPE_EXIT &#123;</span><br><span class="line">    std::<span class="built_in">exchange</span>(coro_, &#123;&#125;).<span class="built_in">destroy</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">move</span>(coro_.<span class="built_in">promise</span>().<span class="built_in">result</span>()).<span class="built_in">value</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="协程和异步"><a href="#协程和异步" class="headerlink" title="协程和异步"></a>协程和异步</h4><p>我们可以思考链式协程模式的特点</p><ol><li>每个协程Task既是一个挂起-恢复的协程任务，也是一个Awaiter。协程的await_suspend会记录父协程, final_suspend恢复父协程。</li><li>协程的阻塞任务, 包括申请锁, sleep, IO等都可以封装成一个Awaiter, 这个awaiter可以在suspend的时候挂起，如果需要调用read等阻塞调用，需要创建新线程执行</li><li>执行协程的线程会执行一个循环(eventloop)，这个线程用于不会阻塞。这个线程做的事情就是1. 循环遍历，如果有协程挂起并创建新线程执行异步任务，就查看异步任务是否执行完，若执行完恢复该协程的调用。 2. 如果协程全部执行完了, 线程根据链式调用, 恢复该协程父协程的执行。3. 尝试接受新的协程任务</li></ol><p><strong>协程锁可以通过标志和等待队列实现,</strong></p><ol><li>尝试申请锁时, 如果锁未被申请, 则持有锁, 协程继续执行</li><li>如果锁已被申请, 则将当前协程加入等待队列, 并挂起当前协程</li><li>释放锁时，唤醒处于等待队列的一个协程恢复它执行<br>执行协程的线程会执行一个循环，如果无协程可执行（协程全部在挂起），线程则进入下一个循环</li></ol><p>协程也可以实现类似golang的channel。channel 由一个ringbuffer和reader, writer两个队列组成。</p><ol><li>reader 进入时, 如果ringbuffer为空，则挂起reader; ringbuffer不为空，则读取ringbuffer中的数, 同时唤醒等待队列的writer</li><li>writer写入时，如果ringbuffer满了，则挂起；否则写入并唤醒所有reader; reader被唤醒时，读取writer写入的数据。<br>显然协程的一个核心是《唤醒》的实现，只需要coroutine.resume()即可, 这比线程的唤醒要简单很多。</li></ol><p>协程可以在await_suspend中调用liburing等异步io函数，然后挂起。同时主线程循环检查liburing的cqe(complete queue entry)，对于完成的IO，唤醒对应的协程继续处理。</p><h4 id="有栈协程"><a href="#有栈协程" class="headerlink" title="有栈协程"></a>有栈协程</h4><p>C++20的协程是无栈协程，无栈协程就是一个Task对象，这个task对象可以通过co_await挂起, 并记录当前的状态。等到resume时，可以从当前的状态继续执行。coroutine对象会记录当前协程函数内的局部变量（包括参数）、挂起点等状态。</p><p>相比无栈协程，有栈协程更容易理解，在有栈协程中，每个协程函数都相当于给指定线程的任务队列加入一个任务</p><ol><li>一般来说，每个线程会执行一个loop循环, 该循环从任务队列取出一个协程任务，执行，然后下一个</li><li>当协程需要挂起时，会保存当前的上下文，将自己放到等待队列，将挂起的任务提交到异步执行</li><li>当异步任务完成后，从等待队列唤醒对应的任务加到执行队列，继续执行。</li></ol><p>执行有栈协程的线程 相当于操作系统的线程CPU调度，典型的就是golang的协程。golang的GMP 调度模型 就类似操作系统的进程-CPU-调度器。有栈协程不需要固定的对象保存状态，需要挂起协程时就创建栈保存状态，协程继续执行时就清理栈恢复状态。而无栈协程通过coroutine对象来保存状态和管理协程生命周期。无栈协程的状态保存和恢复相比有栈协程性能更高，同时执行流更清晰，有利于编译器的优化。</p><p>代码越静态，结果越容易预测，越有利于编译期的优化。</p><h3 id="异步编程模型"><a href="#异步编程模型" class="headerlink" title="异步编程模型"></a>异步编程模型</h3><h4 id="SQE-CQE-模型"><a href="#SQE-CQE-模型" class="headerlink" title="SQE&#x2F;CQE 模型"></a>SQE&#x2F;CQE 模型</h4><p>​​SQE（Submission Queue Entry，提交队列项）和 CQE（Completion Queue Entry，完成队列项）​​ 是高性能异步 I&#x2F;O 框架（如 Linux io_uring、SPDK、DPDK）中的核心机制，用于实现高效的 ​​生产者-消费者模型​​。</p><p>SQE和CQE 一般是两个环形队列，对于SQE，用户程序是生产者，内核&#x2F;硬件是消费者。对于CQE，内核&#x2F;硬件是生产者，应用程序是消费者。</p><ol><li>​SQE（任务提交）​​, 应用程序将 I&#x2F;O 请求（如读、写）封装为 SQE，提交到​​提交队列（Submission Queue, SQ）​​，通知硬件或内核处理。</li><li>​CQE（完成通知）​​：硬件或内核处理完请求后，生成 CQE 并放入​​完成队列（Completion Queue, CQ）​​，应用程序轮询或异步接收结果。</li></ol><p>C++ 协程可以很容易的和SQE&#x2F;CQE 模型结合，await_suspend函数将任务加到SQE队列等待执行, 而主线程定期轮询CQE队列，对于CQE中完成的异步任务，主线程会唤醒协程继续执行。</p><p>io_uring 的SQE和CQE模型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io_uring.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交队列项（SQE）结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">io_uring_sqe</span> &#123;</span><br><span class="line">    __u8    opcode;     <span class="comment">// 操作类型（如 IORING_OP_READV）</span></span><br><span class="line">    __u64   addr;       <span class="comment">// 数据地址（如缓冲区指针）</span></span><br><span class="line">    __u32   len;        <span class="comment">// 数据长度</span></span><br><span class="line">    __u64   user_data;  <span class="comment">// 用户自定义数据（用于关联请求上下文）</span></span><br><span class="line">    <span class="comment">// ... 其他字段（文件描述符、标志位等）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成队列项（CQE）结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">io_uring_cqe</span> &#123;</span><br><span class="line">    __u64   user_data;  <span class="comment">// 对应 SQE 的 user_data</span></span><br><span class="line">    __s32   res;        <span class="comment">// 操作结果（成功时为字节数，失败时为负的错误码）</span></span><br><span class="line">    __u32   flags;      <span class="comment">// 附加标志</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交请求到 SQ</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io_uring_prep_read</span><span class="params">(<span class="keyword">struct</span> io_uring_sqe *sqe, <span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">unsigned</span> nbytes, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="built_in">io_uring_submit</span>(&amp;ring); <span class="comment">// 提交 SQEs 到内核</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 CQ 获取结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">io_uring_cqe</span> *cqe;</span><br><span class="line"><span class="built_in">io_uring_peek_cqe</span>(&amp;ring, &amp;cqe); <span class="comment">// 非阻塞获取 CQE</span></span><br><span class="line"><span class="built_in">io_uring_cq_advance</span>(&amp;ring, <span class="number">1</span>);  <span class="comment">// 标记 CQE 已处理</span></span><br></pre></td></tr></table></figure><p>SPDK 通过SQE&#x2F;CQE模型向nvme ssd驱动提交IO请求</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">spdk_nvme_ns</span> *ns = ...;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">spdk_nvme_qpair</span> *qpair = ...;</span><br><span class="line"><span class="type">char</span> *buffer = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交读请求（SQE）</span></span><br><span class="line"><span class="built_in">spdk_nvme_ns_cmd_read</span>(ns, qpair, buffer, lba, lba_count, </span><br><span class="line">                      completion_cb, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 CQE（回调函数）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">completion_cb</span><span class="params">(<span class="type">void</span> *ctx, <span class="type">const</span> <span class="keyword">struct</span> spdk_nvme_cpl *cpl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">spdk_nvme_cpl_is_error</span>(cpl)) &#123;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DPDK 通过SQE&#x2F;CQE模型向提交网络包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rte_mbuf</span> *tx_pkts[<span class="number">32</span>];</span><br><span class="line"><span class="comment">// 填充发送包（SQE）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">    tx_pkts[i] = ...; <span class="comment">// 构造数据包</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提交发送请求</span></span><br><span class="line"><span class="type">uint16_t</span> sent = <span class="built_in">rte_eth_tx_burst</span>(port_id, queue_id, tx_pkts, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收完成的数据包（CQE）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rte_mbuf</span> *rx_pkts[<span class="number">32</span>];</span><br><span class="line"><span class="type">uint16_t</span> received = <span class="built_in">rte_eth_rx_burst</span>(port_id, queue_id, rx_pkts, <span class="number">32</span>);</span><br></pre></td></tr></table></figure><h4 id="事件通知模型"><a href="#事件通知模型" class="headerlink" title="事件通知模型"></a>事件通知模型</h4><p>事件通知模型不像sqe&#x2F;cqe模型有明确的任务提交队列和任务完成队列，而是通过接收事件来确定是否可读可写。典型的就是linux的epoll。对于读操作，sqe&#x2F;cqe模型只需要提交一个读任务，然后等待完成队列中的读任务完成即可。但对epoll，需要等待读事件触发，才能执行读操作。sqe&#x2F;cqe是一个主动请求等待返回的模型, 而epoll是一个被动等待触发的模型。</p><p>mtcp 实现了一个用户态的epoll，</p><ol><li>通过 DPDK 的轮询模式驱动（Poll Mode Driver, PMD）直接从网卡收取数据包，解析为 TCP 报文。</li><li>当收到TCP报文时，会将对应的连接设置成数据可读（EPOLLIN）、可写（EPOLLOUT）或新连接到达（EPOLLACCEPT）事件，并将该事件加入到就绪队列中</li><li>应用层通过 mtcp_epoll_wait() 等接口从就绪队列中获取事件，执行回调或进一步处理。</li></ol><p>协程和事件通知模型结合时，await_suspend可以将操作加入等待队列，而epoll_wait 返回触发的事件时，可以将数据写到指定的buffer，然后通知等待队列里对应的协程继续执行。</p><p>可见相比epoll的事件通知模型，协程liburing等sqe&#x2F;cqe 模型更自然的结合, 通过轮询cqe的方式对IO完成的协程继续执行。</p><p>DPDK（Data Plane Development Kit）和SPDK（Storage Performance Development Kit）是两款由英特尔发起的开源项目，分别专注于提升网络数据平面和存储I&#x2F;O的性能。DPDK目的是成为用户态网络包处理的标准框架，SPDK则是成为用户态绕过内核操作nvme 协议的块设备IO处理的标准框架。</p><p>DPDK​, 包括mTCP, 是一个用户态TCP协议栈。数据包直接从网卡读取，发给用户态组成TCP包。</p><ol><li>​用户态网络驱动​​。绕过内核协议栈，直接在用户态处理网络包，减少数据拷贝和上下文切换。</li><li>​​零拷贝技术​​。通过大页内存（HugePage）和内存池（Memory Pool）减少内存访问开销。</li><li>轮询模式​​。使用无锁队列（Ring）和CPU轮询（Poll-mode Driver）避免中断延迟。</li><li>​多核扩展​​ 基于线程绑定（CPU affinity）和流水线模型实现高性能多核处理。</li></ol><p>​​SPDK​，是用户态的NVME设备IO框架。IO数据直接从nvme设备到用户态</p><ol><li>​用户态NVMe驱动​​ 完全用户态实现NVMe协议，避免内核存储栈的开销。</li><li>​异步无锁设计​​ 使用异步I&#x2F;O和事件驱动模型，减少锁竞争。</li><li>​​零拷贝访问​​ 通过内存映射（Memory-mapped I&#x2F;O）和直接访问SSD的PRP（Physical Region Page）列表提升效率。</li><li>​高并发优化​​ 支持多队列（Multi-queue）和并行I&#x2F;O请求，充分利用NVMe SSD的多核能力。</li></ol><p>iouring 是linux 内核提供的异步IO接口，相比spdk, 存储层还是会经过内核，走vfs接口, 利用内核的pagecache缓存和块设备抽象。</p><p>rdma是远程内存访问，通过支持RDMA的网卡（RNIC）直接读写远程内存，需要专门的RDMA网卡。RDMA可以和dpdk&#x2F;spdk&#x2F;iouring结合，rdma 是针对rdma专用网卡的网络协议、数据收发，而后者侧重描述的是从用户传输层到网卡的通用架构。rdma 侧重于高性能计算存储，dpdk侧重于更通用的tcp服务。</p><p>dpdk, spdk, rdma, iouring 采用的模型都是cqe&#x2F;sqe 生产消费模型。C++ 通过以上生态，实现了网络和存储IO的高性能。再加上流行的gpu cuda高性能计算框架，使C++在高性能计算&#x2F;存储&#x2F;网络领域不可替代。</p>]]></content>
      
      
      <categories>
          
          <category> language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> coroutine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储——谈存储文件系统</title>
      <link href="/2025/04/07/%E5%AD%98%E5%82%A8%E2%80%94%E8%B0%88%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2025/04/07/%E5%AD%98%E5%82%A8%E2%80%94%E8%B0%88%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>文件系统是组织磁盘的形式, 文件系统提供了文件元数据信息，以及文件内容寻址能力（即将文件offset+length映射为磁盘位置）；另一方面适配不同的磁盘硬件，让用户程序无须考虑硬件的区别。对用户程序来说，存储等于文件系统。</p><p>文件系统整体可以由客户端、元数据服务、数据服务三个部分组成, 包括read, write, setattr, getattr, lookup, readdir, create, rename, hardlink, symlink, readlink, remove等12个接口，支持随机读写文件。</p><p>为什么要有分布式文件系统? 1. 提供水平可扩展, 海量高性能存储 2. 提供多客户端的并发访问服务</p><span id="more"></span><h3 id="对象存储系统和minIO"><a href="#对象存储系统和minIO" class="headerlink" title="对象存储系统和minIO"></a>对象存储系统和minIO</h3><p>文件系统大致包括如下12个接口</p><ol><li>read, write读写文件</li><li>setattr, getattr，读写文件属性（元数据）</li><li>lookup，目录结构使用，根据父handle+文件名获得子文件handle</li><li>readdir, 目录结构使用，获得目录中的文件名，相当于读目录</li><li>create，创建文件</li><li>rename，目录结构使用，将某文件从当前目录move到其他目录下</li><li>hardlink，目录结构用，创建文件的硬链接（硬链接相当于文件具有两个path）</li><li>symlink, readlink，目录结构用，创建和读软链接，基本等价于create和read</li><li>remove，删除文件或空目录</li></ol><p>最简单的是不支持目录的系统，也就是对象存储。对象存储的文件系统和文件分别称为bucket和object，object 完全平铺在bucket 根目录。<br>对象存储只支持read(getobject), write(putobject, appendobject), setattr(putobject), getattr(getobjectmeta)，create(putobject), remove(remove object)</p><p>对象存储的写文件只支持append写，不支持随机写，不支持删除数据(truncate)</p><p>对象存储几乎是最简单的文件系统，我们可以看下对象存储简化操作后的好处</p><ol><li>不支持目录，水平扩展简单。目录通过父目录-子目录的递归结构将文件系统组织成树的形式，目录树的水平扩展就需要按照目录树拆分，并且即使按照目录树划分，水平扩展也没有那么丝滑。对象存储水平扩展简单，一个object可以存在任意机器。这让oss的bucket 的object数量理论无上限，具有规模成本优势，可以随意建大规模object，无须担心性能退化。</li><li>文件read, write, create, remove等接口的调用也容易水平扩展，这让对象存储的IOPS极高。</li><li>只支持append写，容易加EC码降成本，性能不会受随机写和truncate的波动，性能稳定</li></ol><p>对象存储容量和IOPS可水平扩展，性能高且稳定，十分适合作为数据的基础存储，例如ceph就使用对象存储作为块和文件存储的基础。</p><p>minIO是一个开源的对象存储，采用Golang语言实现。集群部署采用去中心化无共享架构，各节点间为对等关系，连接至任一节点均可实现对集群的访问。</p><ol><li>一般的，客户端使用hash算法确定某个bucket和object name对应的erasure set 位置，object的数据和元数据指定存储在某erasure set。（每个erasure set包含一组硬盘，其数量通常为4至16块；EC的每一笔写会划分成若干段，例如8+3纠删码分成8段，同时生成3个校验块，最后11段数据每段独立写到不同磁盘，随机写不利于纠删码创建和优化）</li><li>如果后台增删节点导致object位置发生变化，后端服务器将请求路由到目标服务器，客户端更新位置信息。</li><li>object数据和元数据在相同erasure set中存储，object之间shared-nothing（就是完全独立），容易水平扩展。object的数据和元数据都对应server指定磁盘文件系统的文件。</li><li>客户端使用https之上的s3协议。</li></ol><p>minIO 旨在提供s3协议的对象存储服务，用来存储静态数据，并支持EC保证数据安全。但其并非作为存储底座，因此性能一般且没有太多性能优化。此外。listobject性能很差。</p><p>对象存储作为存储底座（可横向扩展、高性能、容错的分布式文件系统），可以参考ceph和lustre。</p><h3 id="linux-ext4文件系统"><a href="#linux-ext4文件系统" class="headerlink" title="linux ext4文件系统"></a>linux ext4文件系统</h3><p>2008年发布</p><p>元数据由内存的inode 数据结构记录，inode 索引表，是个kv结构，key是inode号，value是对应的块位置。用来快速根据inode号找到inode结构在磁盘的位置。inode索引表常驻内存。每个inode 在内存中通过address_space（基数树）标志inode 使用的page 树。内存的page 会记录该page对应的磁盘块，从而调动磁盘读写数据。</p><p>linux&#x2F;ext4 系统使用文件名 hash快速找到文件inode结构（通过dentry）</p><p>ext4用块为单位组织磁盘，块大小为4KB，块可以分为两类，元数据块用来存inode结构，对应内存的inode结构，数据库则用来存数据，对应内存的page。块使用bitmap标志块有无使用, 作用1. 快速分配新块来写数据，2. 快速定位块的位置</p><p>linux 使用 vfs 向实现不同的文件系统向用户程序提供提供一致的接口，vfs只支持posix语义的文件系统，也就是必须支持上述12个文件系统操作，以及支持文件随机读写和truncate操作。vfs支持的posix文件系统包括ext4, nfs, fuse等</p><p>ext4 文件系统的问题</p><ol><li>ext4文件系统不可跨磁盘存在，可扩展性有限</li><li>ext4文件系统元数据和数据一起存放，未分离，但运行时文件元数据基本存放在内存中，元数据性能很强</li></ol><h3 id="Glusterfs"><a href="#Glusterfs" class="headerlink" title="Glusterfs"></a>Glusterfs</h3><p>GlusterFS 文件系统， </p><ol><li>存储服务器的Brick 是存储基本单位，Brick通过冗余性保证数据安全。Brick是一个目录。客户端根据 hash 算法定位到 Brick，找到Brick后进一步读写文件数据和元数据</li><li>Brick是文件系统的一个目录，Brick本身是可以横向扩展的。Brick中的文件读写创建和内部目录的readdir 性能都比较高</li><li>但需要跨Brick的rename, ls性能比较差</li><li>客户端通过 FUSE 或 NFS&#x2F;SMB 协议挂载 GlusterFS 卷，执行读写操作。客户端直接与存储节点通信，无需经过中心元数据服务器。<br>GlusterFS 相当于简单粗暴的直接按照目录拆分文件系统实现水平扩展，Brick目录内部的操作（包括子目录）性能很好，但ls, rename, link等需要跨Brick的操作性能较差。</li></ol><p>文档, <a href="https://docs.gluster.org/en/main/Quick-Start-Guide/Architecture/#types-of-translators">https://docs.gluster.org/en/main/Quick-Start-Guide/Architecture/#types-of-translators</a></p><h3 id="Lustre"><a href="#Lustre" class="headerlink" title="Lustre"></a>Lustre</h3><p>Lustre 2003年发布, 底座为对象存储的分布式文件系统。由元数据服务(mds)、对象存储服务(oss)和客户端(client) 三个部分组成</p><p>mds，提供目录和元数据服务。元数据和目录均按照固定大小的条带存储，通过handle hash来定位存储位置（类似ext4）。文件系统的目录可能跨条带（对于大目录），跨mds 的rename 操作需要分布式锁保护，性能较低。</p><p>oss 对象存储作为数据存储, 每个oss object代表一个文件, object内部也是固定大小的条带化存储。Lustre的object 支持随机读写，object内部的条带像是块存储的条带，支持随机读写。</p><p><img src="/../images/lustre.png" alt="lustre"></p><h3 id="CephFS"><a href="#CephFS" class="headerlink" title="CephFS"></a>CephFS</h3><p>Ceph 发布于2006年，底层是RADOS（Reliable Autonomic Distributed Object Store）对象存储系统，这个对象同样是可以随机读写的（实际是条带）<br>RADOS 是具有负载均衡、容错的分布式存储服务，组成</p><ol><li>​​OSD（Object Storage Daemon）具体存放数据的存储节点</li><li>​​PG（Placement Group）​负责维护对象到OSD的映射，以及基于映射的负载均衡</li></ol><p><img src="/../images/ceph.png" alt="ceph"></p><p>元数据服务MDS, </p><ol><li>MDS 将目录树拆分为多个子树，分配给不同 MDS 实例管理。会根据子树的访问热度执行动态调度</li><li>MDS 在内存态存放每个子树目录的目录项，文件元数据。持久化时还是以键值对形式存储在目录的 RADOS 对象中。对于MDS的操作会先通过日志持久化到 RADOS</li></ol><p>官方文档，<a href="https://docs.ceph.com/en/latest/architecture/">https://docs.ceph.com/en/latest/architecture/</a></p><h3 id="GPFS"><a href="#GPFS" class="headerlink" title="GPFS"></a>GPFS</h3><p>IBM 商业文件系统，闭源。</p><p>节点角色</p><ol><li>NSD（Network Shared Disk） Server, 管理物理存储设备（如磁盘阵列、SAN），将本地磁盘抽象为逻辑 NSD（Network Shared Disk）, 负责数据容错，存储节点。文件被分割为固定大小的块（默认 256KB~16MB），分布到多个 NSD 上。</li><li>Manager Node​​, 文件系统管理器（File System Manager）​​，负责元数据操作（如目录结构、文件锁）以及颁发token用来协调客户端。同时通过仲裁节点（Quorum Node）实现高可用，通常部署奇数个节点（如 3 个）。Manager Node是无状态的, 元数据（inode、目录项）集中存储于专用 NSD。</li><li>​​Client Node。挂载 GPFS 文件系统的计算节点，直接读写数据。客户端通过向Manager Node申请令牌（Token）协调并发访问，避免冲突和减少锁的使用（例如如果只有一个客户端执文件创建，那目录NSD的写入操作不需要分布式锁）</li></ol><p>令牌是一种lease，客户端需向Manager Node申请令牌，获得权限后方可操作。​​令牌类型包括</p><ol><li>​元数据锁​​, 控制目录结构修改（如重命名、删除）。</li><li>​数据锁​​, 协调文件块的读写冲突（如并发写入同一区域）。</li></ol><p>客户端节点缓存元数据（如目录项、文件属性），减少对Manager Node的频繁访问, 其他客户端的修改会触发缓存失效。</p><p>在高性能分布式系统中，通过lease协调的读写减少分布式锁的使用</p><ol><li>避免多写只允许一个节点写</li><li>每个客户端节点都有缓存，写完的节点通知其他节点更新缓存<br>这种<strong>客户端&#x2F;服务端协调的读写架构，性能远比允许客户端随便发读写请求、通过加锁保证一致性的性能高。</strong></li></ol><p>gpfs文档，<a href="https://www.ibm.com/docs/en/storage-scale/5.2.1?topic=overview-gpfs-architecture">https://www.ibm.com/docs/en/storage-scale/5.2.1?topic=overview-gpfs-architecture</a></p><h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3><p>不支持posix 语义, 设计目录是作为大数据分析中的存储系统，是GFS 的一种实现。</p><p>结构比较简单</p><ol><li>使用NameNode 管理元数据，同时维护数据块物理信息，元数据不可水平扩展</li><li>DataNode 存储数据，数据块可以水平扩展</li><li>Client，元数据操作访问NameNode， 数据操作访问DataNode按需更新NameNode</li></ol><p>NameNode 是性能和容量瓶颈, 并且由于hdfs是JAVA 开发, 一般用来配合Hbase 等hadoop全家桶用于大数据领域。</p><p><img src="/../images/hdfs.png" alt="hdfs"></p><h3 id="JuiceFS"><a href="#JuiceFS" class="headerlink" title="JuiceFS"></a>JuiceFS</h3><p>支持posix 语义, 数据存储在对象存储（如 S3、OSS），元数据支持 Redis&#x2F;MySQL&#x2F;TiDB等一系列数据库作为元数据存储引擎, 借助TiDB 等分布式数据库提供了元数据的可扩展性。客户端借助fuse提供 操作系统接口。</p><ol><li>最主要的优点是数据存储直接和S3对接，利用对象存储无限容量和底成本存储优势</li><li>本地内存和磁盘缓存加速元数据和数据性能。元数据可能是性能瓶颈，但付费版支持高性能元数据引擎</li></ol><p>分布式数据库的数据表可以横向扩展（一般以partition为单位），文件系统的元数据就是若干数据表（KV表），因此自然提供了元数据扩展性。但通用的分布式KV引擎的readdir, rename 性能可能不高，需要针对优化。因此得到文件系统元数据对分布式KV存储的要求</p><ol><li>单点查询性能高</li><li>范围查询（对应readdir）性能高</li><li>支持事务, 删除旧key+增加新key的性能高（对应rename）</li><li>partition 拆分合理, 同一文件系统的若干partition 分布在距离近的机器, 需要有针对优化</li></ol><p>JuiceFS架构文档, <a href="https://juicefs.com/docs/zh/community/architecture/">https://juicefs.com/docs/zh/community/architecture/</a></p><h3 id="3FS"><a href="#3FS" class="headerlink" title="3FS"></a>3FS</h3><p>3FS (Fire-Flyer File System) 是一款高性能的分布式文件系统, 由 DeepSeek 在 2025 年 2 月开源。</p><ol><li>3FS 的元数据以表的形式存在foundationDB服务中，操作元数据时，请求先发给元数据服务处理，然后发送到foundationDB。foundationDB以事务的形式写元数据，Read-only transactions used for metadata queries: fstat, lookup, listdir etc. Read-write transactions used for metadata updates: create, link, unlink, rename etc.</li><li>storage service用户存储数据，数据被划分成等大的块(chunk， 条带)，每三个块组成一条复制链（链式写入三副本保证容错性）,以chain为单位打散storage server。文件到数据块的layout信息存在元数据服务中。storage server使用rocksdb维护自己的元数据信息（例如可用的块列表，块的分配情况等）。</li><li>提供FUSE 客户端和用户态客户端USRBIO（绕过内核和ring零拷贝），客户端会尽可能缓存文件的layout信息（文件chunk的分布情况），read&#x2F;write请求客户端直接访问storage server。</li><li>客户端，meta server，storage server两两之间均使用RDMA通信。</li></ol><p>3FS文档, <a href="https://github.com/deepseek-ai/3FS/blob/main/docs/design_notes.md">https://github.com/deepseek-ai/3FS/blob/main/docs/design_notes.md</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对象存储，<strong>无目录结构</strong>，数据和元数据水平扩展简单，性能高，适合作为基础存储服务。<br>块存储，<strong>整个块设备可以认为是一个文件</strong>。支持随机读写和设备大小水平拓展。块设备需要极低延迟，块设备上可以格式化Ext4等单机文件系统。</p><p>支持分布式元数据的文件系统GlusterFS、CephFS、GPFS、JuiceFS、3FS; Lustre和HDFS不支持</p><p>使用块来存储目录项的文件系统, Ext4、GlusterFS、Lustre、CephFS、GPFS；使用KV 引擎存储目录项的文件系统, JuiceFS和3FS。在kv存储中，readdir 等于key的范围查询, rename等操作需要支持事务, 通过数据表水平拆分实现分布式元数据。</p><p>通过lease 来减少分布式锁的文件系统, GPFS。</p><ol><li>Ext4。单机文件系统，posix语义, 数据元数据按照块组织, 元数据和layout常驻内存。元数据和数据无法扩展</li><li>GlusterFS。Brick 是组织数据和元数据基本单位，代表文件系统的一个目录（即按照目录拆分）。客户端的操作首先根据fsname和文件名定位到Brick，跨Brick的操作性能低。数据和元数据操作可能相互影响。</li><li>Lustre。条带化对象存储作为数据存储，MDS负责管理元数据，元数据和目录项存到MDS本地，无元数据扩展能力。采用专用硬件（高速网络、低延迟存储）, 适用于高性能存储。</li><li>CephFS。底层使用对象存储RADOS提供可扩展性和容错性，MDS 将目录树按子树拆分，MDS是无状态的，目录项和元数据内容同样持久化到RADOS中。为通用存储设计。</li><li>GPFS。NSD 负责数据存储，Manager Node管理元数据，元数据同样存储到NSD。客户端通过申请不同粒度的令牌在实现一致性的同时减少锁冲突。</li><li>HDFS。非posix语义，NameNode 管理元数据, 元数据不可水平扩展，为大数据分析设计。</li><li>JuiceFS可直接用S3 存储数据, KV和OLTP数据库管理元数据。利用本地内存和磁盘缓存加速元数据和数据性能。</li><li>3FS适用于高性能存储, 网络通信采用RDMA，元数据使用foundationDB, 数据使用链式块组织。<br>此外，基于paxos协议实现的zookeeper, etcd也是一种分布式文件系统, 提供高可用。但其只对外提供元数据服务，不适合存储大规模数据。常用的使用方式是1. 通过创建文件和lease 对外提供分布式锁 2. 以KV的形式存储少量重要数据，例如配置文件</li></ol><p>以上，<strong>分布式文件系统建议基于CephFS和3FS建设</strong>，CephFS是通用文件系统，3FS侧重于高性能计算领域。优先考虑使用分布式KV作为元数据引擎。</p><p>by the way<br>我曾统计过我接触到的阿里云内部基础服务的开源替代性，发现最难以替代的是盘古分布式文件系统（其次是夸父高性能网络）。高性能，高可用，低成本的分布式文件系统毫无疑问是各大公司的核心科技。开源存储系统方便使用且满足高性能需求的很少，且相比于以上简要的架构，分布式存储系统的优化更重要。主要的优化点可能是</p><ol><li>客户端和服务端联合优化，包括实现缓存减少后端访问，前后端流控，零拷贝，避免一方空转</li><li>分布式元数据。paxos协议高可用, 元数据尽可能内存化（通过压缩等手段存内存，性能比从磁盘读好很多），减少分布式锁导致性能下降，增强元数据可扩展性。元数据自动根据load调度</li><li>存储层提高IO性能，保证数据安全，降低存储成本，以及坏盘检测等优化</li><li>网络通信，通过用户态网络、rdma等技术，降低传输延迟</li></ol><p>最后推荐三篇阿里云的论文</p><ol><li>盘古存储 More Than Capacity: Performance-oriented Evolution of Pangu in Alibaba. 链接 <a href="https://www.usenix.org/system/files/fast23-li-qiang_more.pdf">https://www.usenix.org/system/files/fast23-li-qiang_more.pdf</a></li><li>夸父网络 From Luna to Solar: The Evolutions of the Compute-to-Storage Networks in Alibaba Cloud. 链接 <a href="https://rmiao.github.io/assets/pdf/solar-sigcomm22.pdf">https://rmiao.github.io/assets/pdf/solar-sigcomm22.pdf</a></li><li>分布式KV引擎ArkDB ArkDB A Key-Value Engine for Scalable Cloud Storage Services 链接 <a href="https://dl.acm.org/doi/10.1145/3448016.3457553">https://dl.acm.org/doi/10.1145/3448016.3457553</a> 这个链接无法下载论文，可以看 <a href="https://zhuanlan.zhihu.com/p/414054332">https://zhuanlan.zhihu.com/p/414054332</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> storage </category>
          
      </categories>
      
      
        <tags>
            
            <tag> storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leveldb(2)—线程模型和并发控制</title>
      <link href="/2025/02/15/leveldb(2)%E2%80%94%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
      <url>/2025/02/15/leveldb(2)%E2%80%94%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>leveldb前台可并发读，但只能串行写。</p><p>leveldb memtable通过无锁skiplist结构 支持读写并发</p><p>leveldb的后台线程只有一个，只处理compaction这一个任务, leveldb的minor compaction和major compaction是一起处理的</p><span id="more"></span><h3 id="线程调度和后台compaction"><a href="#线程调度和后台compaction" class="headerlink" title="线程调度和后台compaction"></a>线程调度和后台compaction</h3><p>线程调度的函数</p><p>util&#x2F;env_posix.cc</p><p>PosixEnv::Schedule</p><ol><li>如果background_thread 未创建，创建之</li><li>background_thread  执行BackgroundThreadEntryPoint函数，即从background_work_queue_中拿任务执行；如果没有任务，执行cv.wait()<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PosixEnv::Schedule</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> (*background_work_function)(<span class="type">void</span>* background_work_arg),</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* background_work_arg)</span> </span>&#123;</span><br><span class="line">  background_work_mutex_.<span class="built_in">Lock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start the background thread, if we haven&#x27;t done so already.</span></span><br><span class="line">  <span class="keyword">if</span> (!started_background_thread_) &#123;</span><br><span class="line">    started_background_thread_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">background_thread</span><span class="params">(PosixEnv::BackgroundThreadEntryPoint, <span class="keyword">this</span>)</span></span>;</span><br><span class="line">    background_thread.<span class="built_in">detach</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the queue is empty, the background thread may be waiting for work.</span></span><br><span class="line">  <span class="keyword">if</span> (background_work_queue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    background_work_cv_.<span class="built_in">Signal</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  background_work_queue_.<span class="built_in">emplace</span>(background_work_function, background_work_arg);</span><br><span class="line">  background_work_mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">BackgroundThreadEntryPoint</span><span class="params">(PosixEnv* env)</span> </span>&#123;</span><br><span class="line">env-&gt;<span class="built_in">BackgroundThreadMain</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PosixEnv::BackgroundThreadMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    background_work_mutex_.<span class="built_in">Lock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until there is work to be done.</span></span><br><span class="line">    <span class="keyword">while</span> (background_work_queue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      background_work_cv_.<span class="built_in">Wait</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(!background_work_queue_.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">auto</span> background_work_function = background_work_queue_.<span class="built_in">front</span>().function;</span><br><span class="line">    <span class="type">void</span>* background_work_arg = background_work_queue_.<span class="built_in">front</span>().arg;</span><br><span class="line">    background_work_queue_.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    background_work_mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="built_in">background_work_function</span>(background_work_arg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p> PosixEnv::Schedule在哪里被调用</p><ol><li>DBImpl::MaybeScheduleCompaction<br>background_compaction_scheduled_ &#x3D; true;<br>env_-&gt;Schedule(&amp;DBImpl::BGWork, this);</li></ol><p>DBImpl::BGWork minor, major compaction都执行</p><p>只有compaction被调用。。</p><p>PosixEnv::StartThread<br>直接开启新线程执行thread_main</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StartThread</span><span class="params">(<span class="type">void</span> (*thread_main)(<span class="type">void</span>* thread_main_arg),</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">void</span>* thread_main_arg)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">new_thread</span><span class="params">(thread_main, thread_main_arg)</span></span>;</span><br><span class="line">new_thread.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StartThread 被测试和benchmark调用</p><h3 id="前台线程"><a href="#前台线程" class="headerlink" title="前台线程"></a>前台线程</h3><p>DBImpl的接口<br>Status Put(const WriteOptions&amp;, const Slice&amp; key,<br>             const Slice&amp; value) override;<br>  Status Delete(const WriteOptions&amp;, const Slice&amp; key) override;<br>  Status Write(const WriteOptions&amp; options, WriteBatch* updates) override;<br>  Status Get(const ReadOptions&amp; options, const Slice&amp; key,<br>             std::string* value) override;<br>可以被多线程执行，即前台多线程。</p><p>leveldb前台可并发读，但只能串行写。</p><h4 id="Get-读"><a href="#Get-读" class="headerlink" title="Get 读"></a>Get 读</h4><p>支持多线程读，即以下逻辑执行是可以多线程的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unlock while reading from files and memtables</span></span><br><span class="line">&#123;</span><br><span class="line">  mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">  <span class="comment">// First look in the memtable, then in the immutable memtable (if any).</span></span><br><span class="line">  <span class="function">LookupKey <span class="title">lkey</span><span class="params">(key, snapshot)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (mem-&gt;<span class="built_in">Get</span>(lkey, value, &amp;s)) &#123;</span><br><span class="line">    <span class="comment">// Done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm != <span class="literal">nullptr</span> &amp;&amp; imm-&gt;<span class="built_in">Get</span>(lkey, value, &amp;s)) &#123;</span><br><span class="line">    <span class="comment">// Done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    s = current-&gt;<span class="built_in">Get</span>(options, lkey, value, &amp;stats);</span><br><span class="line">    have_stat_update = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不担心和写冲突吗？</p><ol><li>如果是读tablefile，读只可能和compaction冲突。但对于compaction时的sst，读操作只可能读旧文件。即对于执行A-&gt;B，前台读只可能读到A，因此前台读不会和compaction 写冲突</li><li>如果读memtable，采用的是无锁跳表，保证读写原子性。</li></ol><p>读skiplist key流程，即SkipList&lt;Key, Comparator&gt;::Iterator::Seek(const Key&amp; target)</p><p>读和写skiplist核心都是获得FindGreaterOrEqual，读的目的是拿到key节点，写的目的是拿到key节点，然后插入它的next</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> <span class="title class_">Comparator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> SkipList&lt;Key, Comparator&gt;::Iterator::<span class="built_in">Seek</span>(<span class="type">const</span> Key&amp; target) &#123;</span><br><span class="line">  node_ = list_-&gt;<span class="built_in">FindGreaterOrEqual</span>(target, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> <span class="title class_">Comparator</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> SkipList&lt;Key, Comparator&gt;::Node*</span><br><span class="line">SkipList&lt;Key, Comparator&gt;::<span class="built_in">FindGreaterOrEqual</span>(<span class="type">const</span> Key&amp; key,</span><br><span class="line">                                              Node** prev) <span class="type">const</span> &#123;</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  <span class="type">int</span> level = <span class="built_in">GetMaxHeight</span>() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    Node* next = x-&gt;<span class="built_in">Next</span>(level);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">KeyIsAfterNode</span>(key, next)) &#123;</span><br><span class="line">      <span class="comment">// Keep searching in this list</span></span><br><span class="line">      x = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (prev != <span class="literal">nullptr</span>) prev[level] = x;</span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Switch to next list</span></span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> <span class="title class_">Comparator</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SkipList</span>&lt;Key, Comparator&gt;::Node &#123;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Node</span><span class="params">(<span class="type">const</span> Key&amp; k)</span> : key(k) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  Key <span class="type">const</span> key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Accessors/mutators for links.  Wrapped in methods so we can</span></span><br><span class="line">  <span class="comment">// add the appropriate barriers as necessary.</span></span><br><span class="line">  <span class="function">Node* <span class="title">Next</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Use an &#x27;acquire load&#x27; so that we observe a fully initialized</span></span><br><span class="line">    <span class="comment">// version of the returned Node.</span></span><br><span class="line">    <span class="keyword">return</span> next_[n].<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetNext</span><span class="params">(<span class="type">int</span> n, Node* x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Use a &#x27;release store&#x27; so that anybody who reads through this</span></span><br><span class="line">    <span class="comment">// pointer observes a fully initialized version of the inserted node.</span></span><br><span class="line">    next_[n].<span class="built_in">store</span>(x, std::memory_order_release);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Array of length equal to the node height.  next_[0] is lowest level link.</span></span><br><span class="line">  std::atomic&lt;Node*&gt; next_[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>写skiplist流程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WriteBatchInternal::InsertInto</span><span class="params">(<span class="type">const</span> WriteBatch* b, MemTable* memtable)</span> </span>&#123;</span><br><span class="line">  MemTableInserter inserter;</span><br><span class="line">  inserter.sequence_ = WriteBatchInternal::<span class="built_in">Sequence</span>(b);</span><br><span class="line">  inserter.mem_ = memtable;</span><br><span class="line">  <span class="keyword">return</span> b-&gt;<span class="built_in">Iterate</span>(&amp;inserter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemTableInserter</span> : <span class="keyword">public</span> WriteBatch::Handler &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  SequenceNumber sequence_;</span><br><span class="line">  MemTable* mem_;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Put</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    mem_-&gt;<span class="built_in">Add</span>(sequence_, kTypeValue, key, value);</span><br><span class="line">    sequence_++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    mem_-&gt;<span class="built_in">Add</span>(sequence_, kTypeDeletion, key, <span class="built_in">Slice</span>());</span><br><span class="line">    sequence_++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemTable::Add</span><span class="params">(SequenceNumber s, ValueType type, <span class="type">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Format of an entry is concatenation of:</span></span><br><span class="line">  <span class="comment">//  key_size     : varint32 of internal_key.size()</span></span><br><span class="line">  <span class="comment">//  key bytes    : char[internal_key.size()]</span></span><br><span class="line">  <span class="comment">//  value_size   : varint32 of value.size()</span></span><br><span class="line">  <span class="comment">//  value bytes  : char[value.size()]</span></span><br><span class="line">  <span class="type">size_t</span> key_size = key.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">size_t</span> val_size = value.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">size_t</span> internal_key_size = key_size + <span class="number">8</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> encoded_len = <span class="built_in">VarintLength</span>(internal_key_size) +</span><br><span class="line">                             internal_key_size + <span class="built_in">VarintLength</span>(val_size) +</span><br><span class="line">                             val_size;</span><br><span class="line">  <span class="type">char</span>* buf = arena_.<span class="built_in">Allocate</span>(encoded_len);</span><br><span class="line">  <span class="type">char</span>* p = <span class="built_in">EncodeVarint32</span>(buf, internal_key_size);</span><br><span class="line">  std::<span class="built_in">memcpy</span>(p, key.<span class="built_in">data</span>(), key_size);</span><br><span class="line">  p += key_size;</span><br><span class="line">  <span class="built_in">EncodeFixed64</span>(p, (s &lt;&lt; <span class="number">8</span>) | type);</span><br><span class="line">  p += <span class="number">8</span>;</span><br><span class="line">  p = <span class="built_in">EncodeVarint32</span>(p, val_size);</span><br><span class="line">  std::<span class="built_in">memcpy</span>(p, value.<span class="built_in">data</span>(), val_size);</span><br><span class="line">  <span class="built_in">assert</span>(p + val_size == buf + encoded_len);</span><br><span class="line">  table_.<span class="built_in">Insert</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> <span class="title class_">Comparator</span>&gt;</span><br><span class="line"><span class="type">void</span> SkipList&lt;Key, Comparator&gt;::<span class="built_in">Insert</span>(<span class="type">const</span> Key&amp; key) &#123;</span><br><span class="line">  <span class="comment">// TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()</span></span><br><span class="line">  <span class="comment">// here since Insert() is externally synchronized.</span></span><br><span class="line">  Node* prev[kMaxHeight];</span><br><span class="line">  Node* x = <span class="built_in">FindGreaterOrEqual</span>(key, prev);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Our data structure does not allow duplicate insertion</span></span><br><span class="line">  <span class="built_in">assert</span>(x == <span class="literal">nullptr</span> || !<span class="built_in">Equal</span>(key, x-&gt;key));</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> height = <span class="built_in">RandomHeight</span>();</span><br><span class="line">  <span class="keyword">if</span> (height &gt; <span class="built_in">GetMaxHeight</span>()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">GetMaxHeight</span>(); i &lt; height; i++) &#123;</span><br><span class="line">      prev[i] = head_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// It is ok to mutate max_height_ without any synchronization</span></span><br><span class="line">    <span class="comment">// with concurrent readers.  A concurrent reader that observes</span></span><br><span class="line">    <span class="comment">// the new value of max_height_ will see either the old value of</span></span><br><span class="line">    <span class="comment">// new level pointers from head_ (nullptr), or a new value set in</span></span><br><span class="line">    <span class="comment">// the loop below.  In the former case the reader will</span></span><br><span class="line">    <span class="comment">// immediately drop to the next level since nullptr sorts after all</span></span><br><span class="line">    <span class="comment">// keys.  In the latter case the reader will use the new node.</span></span><br><span class="line">    max_height_.<span class="built_in">store</span>(height, std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 插入节点到prev数组元素的next</span></span><br><span class="line">  x = <span class="built_in">NewNode</span>(key, height);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">    <span class="comment">// NoBarrier_SetNext() suffices since we will add a barrier when</span></span><br><span class="line">    <span class="comment">// we publish a pointer to &quot;x&quot; in prev[i].</span></span><br><span class="line">    x-&gt;<span class="built_in">NoBarrier_SetNext</span>(i, prev[i]-&gt;<span class="built_in">NoBarrier_Next</span>(i));</span><br><span class="line">    prev[i]-&gt;<span class="built_in">SetNext</span>(i, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Write写"><a href="#Write写" class="headerlink" title="Write写"></a>Write写</h4><p>DBImpl::Write，为什么释放锁？<br>log_-&gt;AddRecord和 WriteBatchInternal::InsertInto 实际只有一个线程执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">status = log_-&gt;<span class="built_in">AddRecord</span>(WriteBatchInternal::<span class="built_in">Contents</span>(write_batch));</span><br><span class="line"><span class="type">bool</span> sync_error = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (status.<span class="built_in">ok</span>() &amp;&amp; options.sync) &#123;</span><br><span class="line">  status = logfile_-&gt;<span class="built_in">Sync</span>();</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    sync_error = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">  status = WriteBatchInternal::<span class="built_in">InsertInto</span>(write_batch, mem_);</span><br><span class="line">&#125;</span><br><span class="line">mutex_.<span class="built_in">Lock</span>();</span><br></pre></td></tr></table></figure><p>原因在于writer<br>构造使用mutex_构造<br>3. 构造writer<br>4. 将writer放入writers_的尾部<br>5. 线程持续等待，知道当前writer是writers_的队首</p><p>这保证只有一个线程把writer处理完，从writers_出队，后面的线程才能处理writer</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Write</span><span class="params">(<span class="type">const</span> WriteOptions&amp; options, WriteBatch* updates)</span> </span>&#123;</span><br><span class="line">  <span class="function">Writer <span class="title">w</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  w.batch = updates;</span><br><span class="line">  w.sync = options.sync;</span><br><span class="line">  w.done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  writers_.<span class="built_in">push_back</span>(&amp;w);</span><br><span class="line">  <span class="keyword">while</span> (!w.done &amp;&amp; &amp;w != writers_.<span class="built_in">front</span>()) &#123;</span><br><span class="line">    w.cv.<span class="built_in">Wait</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (w.done) &#123;</span><br><span class="line">    <span class="keyword">return</span> w.status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// writer构造， mutex用于writer.wait()</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DBImpl</span>::Writer &#123;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Writer</span><span class="params">(port::Mutex* mu)</span></span></span><br><span class="line"><span class="function">      : batch(nullptr), sync(false), done(false), cv(mu) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  Status status;</span><br><span class="line">  WriteBatch* batch;</span><br><span class="line">  <span class="type">bool</span> sync;</span><br><span class="line">  <span class="type">bool</span> done;</span><br><span class="line">  port::CondVar cv;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="并发benchmark"><a href="#并发benchmark" class="headerlink" title="并发benchmark"></a>并发benchmark</h3><p>写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteRandom</span><span class="params">(ThreadState* thread)</span> </span>&#123; <span class="built_in">DoWrite</span>(thread, <span class="literal">false</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWrite</span><span class="params">(ThreadState* thread, <span class="type">bool</span> seq)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num_ != FLAGS_num) &#123;</span><br><span class="line">    <span class="type">char</span> msg[<span class="number">100</span>];</span><br><span class="line">    std::<span class="built_in">snprintf</span>(msg, <span class="built_in">sizeof</span>(msg), <span class="string">&quot;(%d ops)&quot;</span>, num_);</span><br><span class="line">    thread-&gt;stats.<span class="built_in">AddMessage</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  RandomGenerator gen;</span><br><span class="line">  WriteBatch batch;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="type">int64_t</span> bytes = <span class="number">0</span>;</span><br><span class="line">  KeyBuffer key;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_; i += entries_per_batch_) &#123;</span><br><span class="line">    batch.<span class="built_in">Clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; entries_per_batch_; j++) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="type">int</span> k = seq ? i + j : thread-&gt;rand.<span class="built_in">Uniform</span>(FLAGS_num);</span><br><span class="line">      key.<span class="built_in">Set</span>(k);</span><br><span class="line">      batch.<span class="built_in">Put</span>(key.<span class="built_in">slice</span>(), gen.<span class="built_in">Generate</span>(value_size_));</span><br><span class="line">      bytes += value_size_ + key.<span class="built_in">slice</span>().<span class="built_in">size</span>();</span><br><span class="line">      thread-&gt;stats.<span class="built_in">FinishedSingleOp</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    s = db_-&gt;<span class="built_in">Write</span>(write_options_, &amp;batch);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      std::<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;put error: %s\n&quot;</span>, s.<span class="built_in">ToString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">      std::<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  thread-&gt;stats.<span class="built_in">AddBytes</span>(bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReadRandom</span><span class="params">(ThreadState* thread)</span> </span>&#123;</span><br><span class="line">  ReadOptions options;</span><br><span class="line">  std::string value;</span><br><span class="line">  <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">  KeyBuffer key;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; reads_; i++) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> k = thread-&gt;rand.<span class="built_in">Uniform</span>(FLAGS_num);</span><br><span class="line">    key.<span class="built_in">Set</span>(k);</span><br><span class="line">    <span class="keyword">if</span> (db_-&gt;<span class="built_in">Get</span>(options, key.<span class="built_in">slice</span>(), &amp;value).<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      found++;</span><br><span class="line">    &#125;</span><br><span class="line">    thread-&gt;stats.<span class="built_in">FinishedSingleOp</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span> msg[<span class="number">100</span>];</span><br><span class="line">  std::<span class="built_in">snprintf</span>(msg, <span class="built_in">sizeof</span>(msg), <span class="string">&quot;(%d of %d found)&quot;</span>, found, num_);</span><br><span class="line">  thread-&gt;stats.<span class="built_in">AddMessage</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多线程执行<br>线程数量为n</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunBenchmark</span><span class="params">(<span class="type">int</span> n, Slice name,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">void</span> (Benchmark::*method)(ThreadState*))</span> </span>&#123;</span><br><span class="line">  <span class="function">SharedState <span class="title">shared</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">  ThreadArg* arg = <span class="keyword">new</span> ThreadArg[n];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    arg[i].bm = <span class="keyword">this</span>;</span><br><span class="line">    arg[i].method = method;</span><br><span class="line">    arg[i].shared = &amp;shared;</span><br><span class="line">    ++total_thread_count_;</span><br><span class="line">    <span class="comment">// Seed the thread&#x27;s random state deterministically based upon thread</span></span><br><span class="line">    <span class="comment">// creation across all benchmarks. This ensures that the seeds are unique</span></span><br><span class="line">    <span class="comment">// but reproducible when rerunning the same set of benchmarks.</span></span><br><span class="line">    arg[i].thread = <span class="keyword">new</span> <span class="built_in">ThreadState</span>(i, <span class="comment">/*seed=*/</span><span class="number">1000</span> + total_thread_count_);</span><br><span class="line">    arg[i].thread-&gt;shared = &amp;shared;</span><br><span class="line">    g_env-&gt;<span class="built_in">StartThread</span>(ThreadBody, &amp;arg[i]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> single-machine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> single-machine </tag>
            
            <tag> storage </tag>
            
            <tag> leveldb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis(2)——网络处理和持久化</title>
      <link href="/2025/02/12/redis(2)%E2%80%94%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2025/02/12/redis(2)%E2%80%94%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>redis 通过网络服务接收远程命令，进行处理，将执行结果返回。</p><p>redis 4.0版本监听网络请求，处理请求和命令都由一个主线程完成。</p><ol><li>好处是redis 主IO路径无须加锁保护。</li><li>缺点是redis 不可处理耗时长的命令，这在使用自定义命令和复杂lua脚本里需要注意。此外redis 无法利用多核cpu，这对部署机器的cpu单核能力有要求。</li></ol><p>redis的rdb和aof 都是经典的数据持久化&#x2F;备份手段，rdb关注数据库的数据, aof关注数据库的操作。</p><span id="more"></span><h3 id="网络处理"><a href="#网络处理" class="headerlink" title="网络处理"></a>网络处理</h3><p>redis 的网络处理类似常见的IO多路复用网络库，通过事件通知实现单线程处理大量来自不同客户端的事件。</p><h4 id="事件和eventloop-事件循环"><a href="#事件和eventloop-事件循环" class="headerlink" title="事件和eventloop 事件循环"></a>事件和eventloop 事件循环</h4><p>三种事件aeFileEvent（注册的网络事件），aeTimeEvent（定时事件），firedEvent用来存放epoll返回的就绪事件（即需要处理的事件）</p><p>网络事件通过epoll 监听fd可读可写（即网络包可读可写）触发；定时事件通过获得下一个最近事件的执行时间、定时触发；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">aeFileEvent</span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">/* File event structure */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">aeFileEvent</span> &#123;</span><br><span class="line">    <span class="type">int</span> mask; <span class="comment">/* one of AE_(READABLE|WRITABLE) */</span></span><br><span class="line">    aeFileProc *rfileProc;</span><br><span class="line">    aeFileProc *wfileProc;</span><br><span class="line">    <span class="type">void</span> *clientData;</span><br><span class="line">&#125; aeFileEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Time event structure */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">aeTimeEvent</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> id; <span class="comment">/* time event identifier. */</span></span><br><span class="line">    <span class="type">long</span> when_sec; <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">long</span> when_ms; <span class="comment">/* milliseconds */</span></span><br><span class="line">    aeTimeProc *timeProc;</span><br><span class="line">    aeEventFinalizerProc *finalizerProc;</span><br><span class="line">    <span class="type">void</span> *clientData;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">aeTimeEvent</span> *next;</span><br><span class="line">&#125; aeTimeEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A fired event */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">aeFiredEvent</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line">&#125; aeFiredEvent;</span><br></pre></td></tr></table></figure><p>eventloop的核心是aeProcessEvents函数，执行逻辑如下</p><ol><li>计算最近的定时事件需要等待的时间t。shortest &#x3D; aeSearchNearestTimer(eventLoop) </li><li>numevents &#x3D; aeApiPoll(eventLoop, tvp); 执行epoll_wait，超时时间为上述需要等待的时间t</li><li>遍历eventLoop-&gt;fired[j].fd获得触发的事件，根据事件读写类型执行处理函数；fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);  fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</li><li>处理定时事件processTimeEvents</li></ol><h4 id="事件处理函数"><a href="#事件处理函数" class="headerlink" title="事件处理函数"></a>事件处理函数</h4><ol><li>acceptTcpHandler<br>用来接受和建立连接，acceptTcpHandler会创建client</li></ol><p>创建Client时，同时创建对该client的fileevent 可读事件，处理函数是readQueryFromClient。linux的accept() 会从监听 socket 的已完成连接队列中取出一个客户端连接，并为其创建一个 新的 socket。该fd标志了client和filevent可读事件。</p><ol start="2"><li>readQueryFromClient</li></ol><p><code>void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask)</code></p><ol><li>生成c-&gt;querybuf &#x3D; sdsMakeRoomFor(c-&gt;querybuf, readlen);</li><li>nread &#x3D; read(fd, c-&gt;querybuf+qblen, readlen);</li><li>调用processInputBuffer(c);函数</li></ol><p>processInputBuffer 内部是processCommand，主要执行两步</p><ol><li>获取命令<code>c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[0]-&gt;ptr);</code></li><li>处理命令call(c,CMD_CALL_FULL);</li></ol><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>redis 4.0版本监听网络请求，处理请求和命令都由一个主线程完成。</p><ol><li>好处是redis 主IO路径无须加锁保护。</li><li>缺点是redis 不可处理耗时长的命令，这在使用自定义命令和复杂lua脚本里需要注意。此外redis 无法利用多核cpu，这对部署机器的cpu单核能力有要求。</li></ol><p>redis 使用多线程的地方很少，只有adb, aof后台执行，和lazyfree等操作。</p><h4 id="fork-子进程"><a href="#fork-子进程" class="headerlink" title="fork 子进程"></a>fork 子进程</h4><p>fork() 创建子进程，对于父进程：fork() 返回新创建子进程的进程ID（PID）。这是一个正整数。<br>对于子进程：fork() 返回0。<br>如果 fork() 失败：则返回-1，并设置 errno 以指示错误原因。</p><p>fork使用到的地方</p><ol><li>后台创建子进程执行rdb备份任务</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rdbSaveBackground</span><span class="params">(<span class="type">char</span> *filename, rdbSaveInfo *rsi)</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> childpid;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span> || server.rdb_child_pid != <span class="number">-1</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    server.dirty_before_bgsave = server.dirty;</span><br><span class="line">    server.lastbgsave_try = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">openChildInfoPipe</span>();</span><br><span class="line"></span><br><span class="line">    start = <span class="built_in">ustime</span>();</span><br><span class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line">        <span class="built_in">closeListeningSockets</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">redisSetProcTitle</span>(<span class="string">&quot;redis-rdb-bgsave&quot;</span>);</span><br><span class="line">        retval = <span class="built_in">rdbSave</span>(filename,rsi);</span><br></pre></td></tr></table></figure><ol start="2"><li>aof 创建子进程执行rewriteAppendOnlyFile</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> childpid;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span> || server.rdb_child_pid != <span class="number">-1</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">aofCreatePipes</span>() != C_OK) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="built_in">openChildInfoPipe</span>();</span><br><span class="line">    start = <span class="built_in">ustime</span>();</span><br><span class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line">        <span class="built_in">closeListeningSockets</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">redisSetProcTitle</span>(<span class="string">&quot;redis-aof-rewrite&quot;</span>);</span><br><span class="line">        <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">&quot;temp-rewriteaof-bg-%d.aof&quot;</span>, (<span class="type">int</span>) <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">rewriteAppendOnlyFile</span>(tmpfile) == C_OK) &#123;</span><br><span class="line">            <span class="type">size_t</span> private_dirty = <span class="built_in">zmalloc_get_private_dirty</span>(<span class="number">-1</span>);</span><br><span class="line">            ....</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        server.stat_fork_time = <span class="built_in">ustime</span>()-start;</span><br><span class="line">        server.stat_fork_rate = (<span class="type">double</span>) <span class="built_in">zmalloc_used_memory</span>() * <span class="number">1000000</span> / server.stat_fork_time / (<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>); <span class="comment">/* GB per second. */</span></span><br><span class="line">        <span class="built_in">latencyAddSampleIfNeeded</span>(<span class="string">&quot;fork&quot;</span>,server.stat_fork_time/<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>server如果设置了daemonize，则当前进程退出，创建子进程执行后续任务<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">daemonize</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() != <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* parent exits */</span></span><br><span class="line">    <span class="built_in">setsid</span>(); <span class="comment">/* create a new session */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Every output goes to /dev/null. If Redis is daemonized but</span></span><br><span class="line"><span class="comment">     * the &#x27;logfile&#x27; is set to &#x27;stdout&#x27; in the configuration file</span></span><br><span class="line"><span class="comment">     * it will not log at all. */</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR, <span class="number">0</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">dup2</span>(fd, STDIN_FILENO);</span><br><span class="line">        <span class="built_in">dup2</span>(fd, STDOUT_FILENO);</span><br><span class="line">        <span class="built_in">dup2</span>(fd, STDERR_FILENO);</span><br><span class="line">        <span class="keyword">if</span> (fd &gt; STDERR_FILENO) <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>sentinelRunPendingScripts，子进程执行脚本，父进程返回<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Run pending scripts if we are not already at max number of running</span></span><br><span class="line"><span class="comment"> * scripts. */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sentinelRunPendingScripts</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listIter li;</span><br><span class="line">    <span class="type">mstime_t</span> now = <span class="built_in">mstime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find jobs that are not running and run them, from the top to the</span></span><br><span class="line"><span class="comment">     * tail of the queue, so we run older jobs first. */</span></span><br><span class="line">    <span class="built_in">listRewind</span>(sentinel.scripts_queue,&amp;li);</span><br><span class="line">    <span class="keyword">while</span> (sentinel.running_scripts &lt; SENTINEL_SCRIPT_MAX_RUNNING &amp;&amp;</span><br><span class="line">           (ln = <span class="built_in">listNext</span>(&amp;li)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sentinelScriptJob *sj = ln-&gt;value;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">        pid = fork();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">/* Parent (fork error).</span></span><br><span class="line"><span class="comment">             * We report fork errors as signal 99, in order to unify the</span></span><br><span class="line"><span class="comment">             * reporting with other kind of errors. */</span></span><br><span class="line">            <span class="built_in">sentinelEvent</span>(LL_WARNING,<span class="string">&quot;-script-error&quot;</span>,<span class="literal">NULL</span>,</span><br><span class="line">                          <span class="string">&quot;%s %d %d&quot;</span>, sj-&gt;argv[<span class="number">0</span>], <span class="number">99</span>, <span class="number">0</span>);</span><br><span class="line">            sj-&gt;flags &amp;= ~SENTINEL_SCRIPT_RUNNING;</span><br><span class="line">            sj-&gt;pid = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* Child */</span></span><br><span class="line">            <span class="built_in">execve</span>(sj-&gt;argv[<span class="number">0</span>],sj-&gt;argv,environ);</span><br><span class="line">            <span class="comment">/* If we are here an error occurred. */</span></span><br><span class="line">            _exit(<span class="number">2</span>); <span class="comment">/* Don&#x27;t retry execution. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sentinel.running_scripts++;</span><br><span class="line">            sj-&gt;pid = pid;</span><br><span class="line">            <span class="built_in">sentinelEvent</span>(LL_DEBUG,<span class="string">&quot;+script-child&quot;</span>,<span class="literal">NULL</span>,<span class="string">&quot;%ld&quot;</span>,(<span class="type">long</span>)pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="pthread-create-多线程"><a href="#pthread-create-多线程" class="headerlink" title="pthread_create 多线程"></a>pthread_create 多线程</h4><p>pthread_create创建线程被bio封装</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initialize the background system, spawning the thread. */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bioInit</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">size_t</span> stacksize;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialization of state vars and objects */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BIO_NUM_OPS; j++) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;bio_mutex[j],<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_cond_init</span>(&amp;bio_newjob_cond[j],<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_cond_init</span>(&amp;bio_step_cond[j],<span class="literal">NULL</span>);</span><br><span class="line">        bio_jobs[j] = <span class="built_in">listCreate</span>();</span><br><span class="line">        bio_pending[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the stack size as by default it may be small in some system */</span></span><br><span class="line">    <span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line">    <span class="built_in">pthread_attr_getstacksize</span>(&amp;attr,&amp;stacksize);</span><br><span class="line">    <span class="keyword">if</span> (!stacksize) stacksize = <span class="number">1</span>; <span class="comment">/* The world is full of Solaris Fixes */</span></span><br><span class="line">    <span class="keyword">while</span> (stacksize &lt; REDIS_THREAD_STACK_SIZE) stacksize *= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">pthread_attr_setstacksize</span>(&amp;attr, stacksize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ready to spawn our threads. We use the single argument the thread</span></span><br><span class="line"><span class="comment">     * function accepts in order to pass the job ID the thread is</span></span><br><span class="line"><span class="comment">     * responsible of. */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BIO_NUM_OPS; j++) &#123;</span><br><span class="line">        <span class="type">void</span> *arg = (<span class="type">void</span>*)(<span class="type">unsigned</span> <span class="type">long</span>) j;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thread,&amp;attr,bioProcessBackgroundJobs,arg) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">serverLog</span>(LL_WARNING,<span class="string">&quot;Fatal: Can&#x27;t initialize Background Jobs.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        bio_threads[j] = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bioCreateBackgroundJob</span><span class="params">(<span class="type">int</span> type, <span class="type">void</span> *arg1, <span class="type">void</span> *arg2, <span class="type">void</span> *arg3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">bio_job</span> *job = <span class="built_in">zmalloc</span>(<span class="built_in">sizeof</span>(*job));</span><br><span class="line"></span><br><span class="line">    job-&gt;time = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    job-&gt;arg1 = arg1;</span><br><span class="line">    job-&gt;arg2 = arg2;</span><br><span class="line">    job-&gt;arg3 = arg3;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;bio_mutex[type]);</span><br><span class="line">    <span class="built_in">listAddNodeTail</span>(bio_jobs[type],job);</span><br><span class="line">    bio_pending[type]++;</span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;bio_newjob_cond[type]);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;bio_mutex[type]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bioCreateBackgroundJob 使用的地方</p><ol><li>aof后台fsync</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">aof_background_fsync</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">bioCreateBackgroundJob</span>(BIO_AOF_FSYNC,(<span class="type">void</span>*)(<span class="type">long</span>)fd,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>lazyfree<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Empty a Redis DB asynchronously. What the function does actually is to</span></span><br><span class="line"><span class="comment"> * create a new empty set of hash tables and scheduling the old ones for</span></span><br><span class="line"><span class="comment"> * lazy freeing. */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">emptyDbAsync</span><span class="params">(redisDb *db)</span> </span>&#123;</span><br><span class="line">    dict *oldht1 = db-&gt;dict, *oldht2 = db-&gt;expires;</span><br><span class="line">    db-&gt;dict = <span class="built_in">dictCreate</span>(&amp;dbDictType,<span class="literal">NULL</span>);</span><br><span class="line">    db-&gt;expires = <span class="built_in">dictCreate</span>(&amp;keyptrDictType,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">atomicIncr</span>(lazyfree_objects,<span class="built_in">dictSize</span>(oldht1));</span><br><span class="line">    <span class="built_in">bioCreateBackgroundJob</span>(BIO_LAZY_FREE,<span class="literal">NULL</span>,oldht1,oldht2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="rdb持久化"><a href="#rdb持久化" class="headerlink" title="rdb持久化"></a>rdb持久化</h3><p>rdb, replicate db</p><p>暂只看rdbsave和rdbload</p><h4 id="rdbsave"><a href="#rdbsave" class="headerlink" title="rdbsave"></a>rdbsave</h4><p><code>int rdbSave(char *filename, rdbSaveInfo *rsi)</code></p><ol><li>snprintf(tmpfile,256,”temp-%d.rdb”, (int) getpid()); fp &#x3D; fopen(tmpfile,”w”);</li><li>rioInitWithFile(&amp;rdb,fp);</li><li>rdbSaveRio(&amp;rdb,&amp;error,RDB_SAVE_NONE,rsi)</li><li>fflush(fp) &#x3D;&#x3D; EOF fsync(fileno(fp)  fclose(fp) &#x3D;&#x3D; EOF</li><li>rename(tmpfile,filename)</li></ol><p>fflush是flush文件流到page cache，fsync是刷page cache到文件落盘</p><p>其中的rdbSaveRio 函数，rdbSaveRio(&amp;rdb,&amp;error,RDB_SAVE_NONE,rsi)</p><ol><li>写入”REDIS%04d”,RDB_VERSION</li><li>rdbSaveInfoAuxFields(rdb,flags,rsi)</li><li>遍历server.dbnum<ol><li>对每个db，redisDb。每个db内部其实是db-&gt;dict，</li><li>写入一些元数据，包括rdbSaveType(rdb,RDB_OPCODE_SELECTDB)</li><li>rdbSaveLen(rdb,j)</li><li>rdbSaveType(rdb,RDB_OPCODE_RESIZEDB) </li><li>rdbSaveLen(rdb,db_size)</li><li>rdbSaveLen(rdb,expires_size)</li><li>遍历db-&gt;dict，拿到sds keystr &#x3D; dictGetKey(de);，robj key, <code>*o = dictGetVal(de);</code>，执行rdbSaveKeyValuePair(rdb,&amp;key,o,expire,now)</li></ol></li></ol><h4 id="rdbsave-的调用"><a href="#rdbsave-的调用" class="headerlink" title="rdbsave 的调用"></a>rdbsave 的调用</h4><p>rdbSaveBackground执行调用childpid &#x3D; fork() 启动进程，在子进程里执行rdbSave(filename,rsi);</p><p>fork()的子进程初始利用写时复制共享父进程内存。写时复制情况下，父子进程修改共享内存页时，均会复制共享页到新的物理内存页。</p><p>写时复制保证子进程的内存始终和父进程调用fork()时的状态一致，就是说，<strong>子进程rdbSave 的dict 内容和父进程fork()时的一致，且不会因后续父进程对dict的写入而改变。。</strong>以上由操作系统保证。太6了</p><p>如果父进程大量修改数据（触发大量 COW），可能导致内存和 CPU 压力增大，但这属于资源问题，影响可控</p><p>rdbsave的定时和手动调度</p><p>后台执行时会设置执行的child_pid，从而判断是否后台正在执行备份<br>server.rdb_child_pid !&#x3D; -1 || server.aof_child_pid !&#x3D; -1</p><p>replicationCron -&gt; startBgsaveForReplication<br>replicationCron 一秒钟执行一次</p><p>syncCommand-&gt; startBgsaveForReplication</p><h4 id="rdbLoadRio"><a href="#rdbLoadRio" class="headerlink" title="rdbLoadRio"></a>rdbLoadRio</h4><p><code>int rdbLoadRio(rio *rdb, rdbSaveInfo *rsi)</code></p><p>从文件里读数据</p><ol><li>首先读到”REDIS\0”</li><li>然后是一字节版本，rdbver &#x3D; atoi(buf+5);。算法<br>从第一个非空白字符开始，取一个可选的初始加号或者减号，后跟尽可能多的十进制数字，并将它们转换为一个<code>int</code>类型的数值。</li><li>循环执行<ol><li>type &#x3D; rdbLoadType(rdb)</li><li>根据type 类型执行以下操作，type的类型可以是RDB_OPCODE_EOF表示结束</li><li>解析出key &#x3D; rdbLoadStringObject(rdb) 和val &#x3D; rdbLoadObject(type,rdb)</li><li>将kv写入到hash table dbAdd(db,key,val);</li></ol></li></ol><p>显然rdb会将某时刻hashtable的所有kv写入到rdb文件中。</p><h3 id="aof持久化"><a href="#aof持久化" class="headerlink" title="aof持久化"></a>aof持久化</h3><p>aof, append only file</p><p>rdb关心的是复制db的dict 的key, value，通过写kv数据恢复数据库状态。aof关心的是复制db的增删改操作，通过replay操作恢复数据库状态。</p><h4 id="aof-rewrite"><a href="#aof-rewrite" class="headerlink" title="aof rewrite"></a>aof rewrite</h4><p>aof 可以实现全量复制和增量复制。</p><p>aof 的rewrite 是将当前状态的dict的key value，全部保存为<code>set key value</code>操作，从而实现全量复制。</p><p>aof 增量复制通过父进程将写操作发给子进程实现。进程通信的方式是使用管道。创建管道会返回两个fd，分别给父子进程。进程利用fd和fileevent事件可以监听管道，子进程监听可写事件，父进程监听可读事件。</p><p>当执行aof时，父进程接收到写请求，在处理请求之外，会把写操作写入到管道。当执行rdb或aof时，redis会把执行的子进程id记录，通过判断子进程id存在可以得到是否正在执行rdb&#x2F;aof。</p><p>Redis 4.0 引入了 混合持久化（通过配置 aof-use-rdb-preamble yes 启用）：重写后的 AOF 文件会以 RDB 格式开头，后续追加增量 AOF 命令。<br>此时，AOF 重写过程会先生成 RDB 数据，再追加新写入的 AOF 命令。</p><p>子进程执行逻辑</p><ol><li>如果设置了server.aof_use_rdb_preamble，处理rdb；否则，执行rewriteAppendOnlyFileRio，遍历dict，将当前dict存放的key, value转换成SET key value 写入到aof文件</li><li>循环执行aofReadDiffFromParent(); 读rewrite期间父进程的写入，到server.aof_child_diff</li><li>执行rioWrite(&amp;aof,server.aof_child_diff,sdslen(server.aof_child_diff)，写入到rio</li></ol><p>aofReadDiffFromParent 从管道读数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function is called by the child rewriting the AOF file to read</span></span><br><span class="line"><span class="comment"> * the difference accumulated from the parent into a buffer, that is</span></span><br><span class="line"><span class="comment"> * concatenated at the end of the rewrite. */</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">aofReadDiffFromParent</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">65536</span>]; <span class="comment">/* Default pipe buffer size on most Linux systems. */</span></span><br><span class="line">    <span class="type">ssize_t</span> nread, total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((nread =</span><br><span class="line">            <span class="built_in">read</span>(server.aof_pipe_read_data_from_parent,buf,<span class="built_in">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        server.aof_child_diff = <span class="built_in">sdscatlen</span>(server.aof_child_diff,buf,nread);</span><br><span class="line">        total += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rio对应一个文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rioInitWithFile</span><span class="params">(rio *r, FILE *fp)</span> </span>&#123;</span><br><span class="line">    *r = rioFileIO;</span><br><span class="line">    r-&gt;io.file.fp = fp;</span><br><span class="line">    r-&gt;io.file.buffered = <span class="number">0</span>;</span><br><span class="line">    r-&gt;io.file.autosync = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> rio rioFileIO = &#123;</span><br><span class="line">    rioFileRead,</span><br><span class="line">    rioFileWrite,</span><br><span class="line">    rioFileTell,</span><br><span class="line">    rioFileFlush,</span><br><span class="line">    <span class="literal">NULL</span>,           <span class="comment">/* update_checksum */</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/* current checksum */</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/* bytes read or written */</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/* read/write chunk size */</span></span><br><span class="line">    &#123; &#123; <span class="literal">NULL</span>, <span class="number">0</span> &#125; &#125; <span class="comment">/* union for io-specific vars */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主进程执行逻辑</p><ol><li>格式化数据到Buf，<code>server.expireCommand,argv[1], exarg</code></li><li>如果开启了aof，执行server.aof_buf &#x3D; sdscatlen(server.aof_buf,buf,sdslen(buf));</li><li>如果server.aof_child_pid !&#x3D; -1，表示有rewrite进程，执行aofRewriteBufferAppend((unsigned char*)buf,sdslen(buf));</li></ol><h3 id="pub-sub"><a href="#pub-sub" class="headerlink" title="pub-sub"></a>pub-sub</h3><p>pub-sub 是常用的网络服务</p><p>订阅-发布和关注某个up主，收到他们更新的消息，是类似的</p><h4 id="SubscribeChannel"><a href="#SubscribeChannel" class="headerlink" title="SubscribeChannel"></a>SubscribeChannel</h4><p>Subscribe a client to a channel. Returns 1 if the operation succeeded</p><p>c-&gt;pubsub_channels 是一个dict。注册的结果，key是channel，value是一个client list</p><h4 id="pubsubPublishMessage"><a href="#pubsubPublishMessage" class="headerlink" title="pubsubPublishMessage"></a>pubsubPublishMessage</h4><ol><li>利用dictFind(server.pubsub_channels,channel) 找到channel(key)，返回client list（value）</li><li>遍历list，对每个client，执行<code>addReply(c,shared.mbulkhdr[3]);</code>，<code>addReply(c,shared.messagebulk);</code> addReplyBulk(c,channel); addReplyBulk(c,message);</li></ol><p>addReply</p><ol><li>传入<code>robj *obj</code></li><li>addReplyToBuffer(c,obj-&gt;ptr,sdslen(obj-&gt;ptr)</li></ol><p>subscribeCommand</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">subscribeCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">        <span class="built_in">pubsubSubscribeChannel</span>(c,c-&gt;argv[j]);</span><br><span class="line">    c-&gt;flags |= CLIENT_PUBSUB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>publish command</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">publishCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> receivers = <span class="built_in">pubsubPublishMessage</span>(c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled)</span><br><span class="line">        <span class="built_in">clusterPropagatePublish</span>(c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        forceCommandPropagation(c,PROPAGATE_REPL);</span><br><span class="line">    <span class="built_in">addReplyLongLong</span>(c,receivers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> single-machine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> single-machine </tag>
            
            <tag> storage </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis(1)——数据结构</title>
      <link href="/2025/02/09/redis(1)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2025/02/09/redis(1)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>redis 是最值得学习的开源项目，</p><ol><li>它广泛应用 </li><li>它实现了单机缓存数据库，同时支持网络访问、复制、集群、订阅等高级特性 </li><li>redis依赖很少，数据结构、日志等基础库也是自行实现，有利于学习 </li><li>redis代码精悍、质量高，甚至很难找到优化点。</li></ol><p>本文阐释redis数据结构，redis 数据结构设计的一大特点是节省内存。原因是redis作为内存数据库需要节省内存使用(连续内存的数组能减少内存碎片)。这对架构设计同样有借鉴意义，通过节省元数据内存使用来把更多元数据&#x2F;索引放在内存上，可以大大提高处理的吞吐和延迟。</p><span id="more"></span><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>在redis的数据结构中</p><ol><li>sds 最常用做dict的key</li><li>list 作为redis 内部结构使用，例如事件列表，客户端列表</li><li>dict 作为数据库使用</li><li>redisObject 作为数据库的value使用，object可以划分成string, list, hashtable, set, sorted set 五种基本类型<ol><li>string 通过sds实现</li><li>list 通过quicklist实现；quicklist又是list和ziplist的组合</li><li>hashtable，少量数据通过ziplist实现（减小内存碎片），大量数据通过dict实现</li><li>set，整数且少量数据通过intset实现，大量数据通过dict实现</li><li>sorted set，少量数据通过ziplist实现，大量数据通过dict+skiplist实现（skiplist用来保序）</li></ol></li></ol><h4 id="sds-simple-dynamic-string"><a href="#sds-simple-dynamic-string" class="headerlink" title="sds, simple dynamic string"></a>sds, simple dynamic string</h4><p>sds 就是动态字符串，在C char* 之上的封装，增加了常用的变量和成员函数。<strong>sds 在redis使用广泛，最常用的是作为dict的key。</strong></p><p>sds有sdshdr8，sdshdr16，sdshdr32等。后面的8, 16, 32 表示sds的最长长度为2^8, 2^16, 2^32(128byte, 64K, 4M)。一般来说，sdshdr8和sdshdr16就够用了</p><p>一般来说</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__attribute__</span> ((__packed__)) sdshdr5 &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__attribute__</span> ((__packed__)) sdshdr8 &#123;</span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__attribute__</span> ((__packed__)) sdshdr16 &#123;</span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__attribute__</span> ((__packed__)) sdshdr32 &#123;</span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__attribute__</span> ((__packed__)) sdshdr64 &#123;</span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>buf 实际存放数据，等同于C语言的<code>char *</code></li><li>获得长度不需要遍历buf，只需要将(s)-(sizeof(struct sdshdr##T))强制转型为struct sdshdr##T，然后调用sdshdr##T的方法即可</li></ol><p>SDS_HDR(T,s) 表示就s 转型为struct sdshdr##T</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">sdslen</span><span class="params">(<span class="type">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">SDS_TYPE_5_LEN</span>(flags);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">SDS_HDR</span>(<span class="number">8</span>,s)-&gt;len;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>创建sds，传入C风格的char *，</p><ol><li>通过strlen获得C风格字符串长度</li><li>根据长度确定type</li><li>构造sdsHeader</li><li>memcpy(s, init, initlen); 将C风格字符串 copy到sds 的buf成员<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new sds string starting from a null terminated C string. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *init)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sdsnewlen</span>(init, initlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *init, <span class="type">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="type">void</span> *sh;</span><br><span class="line">    sds s;</span><br><span class="line">    <span class="type">char</span> type = <span class="built_in">sdsReqType</span>(initlen);</span><br><span class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class="line"><span class="comment">     * since type 5 is not good at this. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line">    <span class="type">int</span> hdrlen = <span class="built_in">sdsHdrSize</span>(type);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line"></span><br><span class="line">    sh = <span class="built_in">s_malloc</span>(hdrlen+initlen<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!init)</span><br><span class="line">        <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen+initlen<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    s = (<span class="type">char</span>*)sh+hdrlen;</span><br><span class="line">    fp = ((<span class="type">unsigned</span> <span class="type">char</span>*)s)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            <span class="built_in">SDS_HDR_VAR</span>(<span class="number">8</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen);</span><br><span class="line">    s[initlen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));</span></span><br></pre></td></tr></table></figure></li></ol><p>sds还实现了trim, cmp等常用函数, 是s字符串设计的良好参考</p><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>双向链表, 增加了len成员变量记录链表的长度</p><p>redis 双向链表主要应用在系统结构，例如事件列表fileEvents，定时器事件列表，client列表，slave列表等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">listNode</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">listNode</span> *prev;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">listNode</span> *next;</span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">listIter</span> &#123;</span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="type">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">list</span> &#123;</span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="built_in">void</span> (*free)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="built_in">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure><h4 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h4><p>dict 是kv哈希表，是redis 的核心存储单元。redis 接收到的kv 就是存放在dict结构里。</p><p>每个dict对象有两个dictht，每个dictht是一个hash表。使用两个hash表是后续用来rehash。rehash是哈希表扩容，哈希表扩容期间，由于长度变大，会导致key重新排布。rehash的期望是在key重新排布期间，不影响前台IO对哈希表的读写操作。</p><ol><li>redis rehash线程和前台操作使用相同线程，可以避免对dict加锁</li><li>使用两张表，可以渐进式rehash，每次迁移一个桶。rehash期间，表1的长度是旧长度，表2是新长度。读操作需要先读2，后读1；写操作只需要写表2，删除更新操作也需要同时处理两个表。</li><li>rehash时，只需要复制key和value的指针，不需要拷贝数据，因此对内存的消耗有限<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dictEntry</span> &#123;</span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dictEntry</span> *next;</span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dictType</span> &#123;</span><br><span class="line">    <span class="built_in">uint64_t</span> (*hashFunction)(<span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    <span class="built_in">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    <span class="built_in">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);</span><br><span class="line">    <span class="built_in">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dictht</span> &#123;</span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dict</span> &#123;</span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If safe is set to 1 this is a safe iterator, that means, you can call</span></span><br><span class="line"><span class="comment"> * dictAdd, dictFind, and other functions against the dictionary even while</span></span><br><span class="line"><span class="comment"> * iterating. Otherwise it is a non safe iterator, and only dictNext()</span></span><br><span class="line"><span class="comment"> * should be called while iterating. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dictIterator</span> &#123;</span><br><span class="line">    dict *d;</span><br><span class="line">    <span class="type">long</span> index;</span><br><span class="line">    <span class="type">int</span> table, safe;</span><br><span class="line">    dictEntry *entry, *nextEntry;</span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> fingerprint;</span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure></li></ol><h4 id="object"><a href="#object" class="headerlink" title="object"></a>object</h4><p>object最常见的使用是作为dict的value存在, </p><p>redis key 只有sds一种类型，value有五种类型。</p><ol><li>String字符串，支持SET, GET命令，底层使用sds实现</li><li>List有序可重复的列表，支持LPUSH, RPOP, LRANGE命令，底层使用quicklist实现</li><li>Hash键值对集合，支持HSET, HGET, HGETALL，底层使用ziplist, hashtable实现</li><li>Set无序唯一的集合，支持SADD, SMEMBER，底层使用intset, hashtable实现</li><li>Sorted Set有序唯一的集合（带权重），支持ZADD, ZRANGE, ZRANK命令，底层使用ziplist, skiplist+hashtable组合结构实现</li></ol><p>intset 只用来实现set，不用来实现sorted set，原因是sorted set的entry需要有参数作为排序的权重, intset不能支持。</p><p>其中redis的hashtable就是dict</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dict</span> &#123;</span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>redis 的常用操作命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 设置key value, value </span><br><span class="line">SET key value</span><br><span class="line"></span><br><span class="line"># value 是列表</span><br><span class="line">LPUSH key value1 value2  # 左侧插入</span><br><span class="line">RPUSH key value1 value2  # 右侧插入</span><br><span class="line">LPOP key                 # 左侧弹出元素</span><br><span class="line">RPOP key                 # 右侧弹出元素</span><br><span class="line"></span><br><span class="line"># value是哈希表</span><br><span class="line">HSET key field1 val1 field2 val2   # 批量设置&lt;field val&gt;</span><br><span class="line">HMGET key field1 field2  # 批量获取</span><br><span class="line"></span><br><span class="line"># value是集合</span><br><span class="line">SADD key member1 member2  # 添加成员</span><br><span class="line">SMEMBERS key              # 获取所有成员</span><br><span class="line"></span><br><span class="line"># value是有序集合</span><br><span class="line">ZADD key score1 member1 score2 member2  # 添加带分值的成员</span><br><span class="line">ZRANGE key start stop [WITHSCORES]      # 按分值升序获取成员</span><br></pre></td></tr></table></figure><p>object核心的成员，type，encoding，ptr</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisObject</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>encoding有10种, robj可以看成不同实现数据结构的统一接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Objects encoding. Some kind of objects like Strings and Hashes can be</span></span><br><span class="line"><span class="comment"> * internally represented in multiple ways. The &#x27;encoding&#x27; field of the object</span></span><br><span class="line"><span class="comment"> * is set to one of this fields for this object. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">createQuicklistObject</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    quicklist *l = <span class="built_in">quicklistCreate</span>();</span><br><span class="line">    robj *o = <span class="built_in">createObject</span>(OBJ_LIST,l);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_QUICKLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">createZiplistObject</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl = <span class="built_in">ziplistNew</span>();</span><br><span class="line">    robj *o = <span class="built_in">createObject</span>(OBJ_LIST,zl);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">createSetObject</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    dict *d = <span class="built_in">dictCreate</span>(&amp;setDictType,<span class="literal">NULL</span>);</span><br><span class="line">    robj *o = <span class="built_in">createObject</span>(OBJ_SET,d);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_HT;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">createIntsetObject</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    intset *is = <span class="built_in">intsetNew</span>();</span><br><span class="line">    robj *o = <span class="built_in">createObject</span>(OBJ_SET,is);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_INTSET;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>object 可以序列化到rdb，也可以被load</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Load a Redis object of the specified type from the specified file.</span></span><br><span class="line"><span class="comment"> * On success a newly allocated object is returned, otherwise NULL. */</span></span><br><span class="line"><span class="function">robj *<span class="title">rdbLoadObject</span><span class="params">(<span class="type">int</span> rdbtype, rio *rdb)</span> </span>&#123;</span><br><span class="line">    robj *o = <span class="literal">NULL</span>, *ele, *dec;</span><br><span class="line">    <span class="type">uint64_t</span> len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rdbtype == RDB_TYPE_STRING) &#123;</span><br><span class="line">        <span class="comment">/* Read string value */</span></span><br><span class="line">        <span class="keyword">if</span> ((o = <span class="built_in">rdbLoadEncodedStringObject</span>(rdb)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        o = <span class="built_in">tryObjectEncoding</span>(o);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h4><p>quicklist 用来实现列表类型value。</p><p>quicklist 是一个由多个 ziplist（压缩列表）节点组成的双向链表。quicklist的节点就是 ziplist。</p><p>quicklist支持对 ziplist 节点进行 LZF 压缩, 从而节省内存。<br>（redis是内存数据库，节省内存的使用是它必须考虑的设计）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* quicklistNode is a 32 byte struct describing a ziplist for a quicklist.</span></span><br><span class="line"><span class="comment"> * We use bit fields keep the quicklistNode at 32 bytes.</span></span><br><span class="line"><span class="comment"> * count: 16 bits, max 65536 (max zl bytes is 65k, so max count actually &lt; 32k).</span></span><br><span class="line"><span class="comment"> * encoding: 2 bits, RAW=1, LZF=2.</span></span><br><span class="line"><span class="comment"> * container: 2 bits, NONE=1, ZIPLIST=2.</span></span><br><span class="line"><span class="comment"> * recompress: 1 bit, bool, true if node is temporarry decompressed for usage.</span></span><br><span class="line"><span class="comment"> * attempted_compress: 1 bit, boolean, used for verifying during testing.</span></span><br><span class="line"><span class="comment"> * extra: 12 bits, free for future use; pads out the remainder of 32 bits */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">quicklistNode</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">quicklistNode</span> *prev;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">quicklistNode</span> *next;</span><br><span class="line">    <span class="comment">// ziplist</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;             <span class="comment">/* ziplist size in bytes */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;     <span class="comment">/* count of items in ziplist */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can&#x27;t compress; too small */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">quicklist</span> &#123;</span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;        <span class="comment">/* total count of all entries in all ziplists */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;          <span class="comment">/* number of quicklistNodes */</span></span><br><span class="line">    <span class="type">int</span> fill : <span class="number">16</span>;              <span class="comment">/* fill factor for individual nodes */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> compress : <span class="number">16</span>; <span class="comment">/* depth of end nodes not to compress;0=off */</span></span><br><span class="line">&#125; quicklist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">quicklistIter</span> &#123;</span><br><span class="line">    <span class="type">const</span> quicklist *quicklist;</span><br><span class="line">    quicklistNode *current;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zi;</span><br><span class="line">    <span class="type">long</span> offset; <span class="comment">/* offset in current ziplist */</span></span><br><span class="line">    <span class="type">int</span> direction;</span><br><span class="line">&#125; quicklistIter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">quicklistEntry</span> &#123;</span><br><span class="line">    <span class="type">const</span> quicklist *quicklist;</span><br><span class="line">    quicklistNode *node;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zi;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *value;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> longval;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;</span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">&#125; quicklistEntry;</span><br></pre></td></tr></table></figure><h4 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h4><p>quicklist的元素是ziplist, 除了quicklist, ziplist还作为元素数量少的 hashtable和sorted set的存储结构。</p><p>ziplist是一种紧凑的、连续内存存储的线性数据结构，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+---------+--------+--------+--------+--------+---------+</span><br><span class="line">| zlbytes | zltail | zllen  | entry1 | entry2 | ... | zlend |</span><br><span class="line">+---------+--------+--------+--------+--------+---------+</span><br><span class="line"></span><br><span class="line">zltail（4字节）：最后一个节点的偏移量（用于快速定位尾部）。</span><br><span class="line"></span><br><span class="line">+------------------+----------------+----------------+</span><br><span class="line">| prev_entry_len   | encoding       | content        |</span><br><span class="line">+------------------+----------------+----------------+</span><br><span class="line"></span><br><span class="line">prev_entry_len 前驱节点长度，用于反向遍历</span><br><span class="line">encoding 编码类型</span><br></pre></td></tr></table></figure><p>每个entry主要由三部分组成， prev_entry_len，encoding，content。content就是一段序列，char *p。</p><p>当ziplist存放hashtable时，content是dictEntry。当ziplist存放sorted set是，content就是sds。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">zlentry</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlensize; <span class="comment">/* Bytes used to encode the previos entry len*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlen;     <span class="comment">/* Previous entry len. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lensize;        <span class="comment">/* Bytes used to encode this entry type/len.</span></span><br><span class="line"><span class="comment">                                    For example strings have a 1, 2 or 5 bytes</span></span><br><span class="line"><span class="comment">                                    header. Integers always use a single byte.*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;            <span class="comment">/* Bytes used to represent the actual entry.</span></span><br><span class="line"><span class="comment">                                    For strings this is just the string length</span></span><br><span class="line"><span class="comment">                                    while for integers it is 1, 2, 3, 4, 8 or</span></span><br><span class="line"><span class="comment">                                    0 (for 4 bit immediate) depending on the</span></span><br><span class="line"><span class="comment">                                    number range. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> headersize;     <span class="comment">/* prevrawlensize + lensize. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> encoding;      <span class="comment">/* Set to ZIP_STR_* or ZIP_INT_* depending on</span></span><br><span class="line"><span class="comment">                                    the entry encoding. However for 4 bits</span></span><br><span class="line"><span class="comment">                                    immediate integers this can assume a range</span></span><br><span class="line"><span class="comment">                                    of values and must be range-checked. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p;            <span class="comment">/* Pointer to the very start of the entry, that</span></span><br><span class="line"><span class="comment">                                    is, this points to prev-entry-len field. */</span></span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure><h4 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h4><p>intset 整数集合用来实现元素数量较小的set，需要满足</p><ol><li>元素均为整数</li><li>元素个数小于阈值set-max-intset-entries 512</li></ol><p>intset 采用连续内存存储，内部元素有序排布，支持二分查找</p><p>intset 支持三种整数类型，按需动态升级：</p><ol><li>INTSET_ENC_INT16：每个元素占 2 字节（范围 -32,768 ~ 32,767）。</li><li>INTSET_ENC_INT32：每个元素占 4 字节（范围 -2^31 ~ 2^31-1）。</li><li>INTSET_ENC_INT64：每个元素占 8 字节（范围 -2^63 ~ 2^63-1）。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// intset.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">intset</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> encoding;  <span class="comment">// 编码方式（INTSET_ENC_INT16/32/64）</span></span><br><span class="line">    <span class="type">uint32_t</span> length;    <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];  <span class="comment">// 动态数组，按 encoding 存储整数</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>intset add的都是整数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Insert an integer in the intset */</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetAdd</span><span class="params">(intset *is, <span class="type">int64_t</span> value, <span class="type">uint8_t</span> *success)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="type">uint32_t</span> pos;</span><br></pre></td></tr></table></figure><h4 id="skiplist和dict结合"><a href="#skiplist和dict结合" class="headerlink" title="skiplist和dict结合"></a>skiplist和dict结合</h4><p>跳跃表，和dict 合作实现有序集合</p><p>redis 通过哈希表，实现有序集合O(1)的点查询；通过跳跃表，实现集合的有序和范围查询。</p><p>哈希表存放zskiplistNode的地址即可，关键成员是sds ele和double score</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">zskiplistNode</span> &#123;</span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">zskiplistNode</span> *backward;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">zskiplistLevel</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">zskiplistNode</span> *forward;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">zskiplist</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">zskiplistNode</span> *header, *tail;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">zset</span> &#123;</span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> single-machine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> single-machine </tag>
            
            <tag> storage </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leveldb(1)—概览</title>
      <link href="/2025/01/31/leveldb(1)%E2%80%94%E6%A6%82%E8%A7%88/"/>
      <url>/2025/01/31/leveldb(1)%E2%80%94%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<p>leveldb 可分为五大块。db, iterator，version, memtable+log, tablefile。</p><p>leveldb 的架构图资料上有很多，可以参考<a href="https://youjiali1995.github.io/storage/leveldb-architecture/">网站</a></p><span id="more"></span><h3 id="db"><a href="#db" class="headerlink" title="db"></a>db</h3><p>主要接口Open，Put&#x2F;Write，Delete，Get</p><h4 id="Open"><a href="#Open" class="headerlink" title="Open"></a>Open</h4><p><code>Status DB::Open(const Options&amp; options, const std::string&amp; dbname, DB** dbptr)</code><br>Open 需要传入options，options记录了1. 限制参数，例如max_open_files，max_file_size，block_size 2. Env* env; env提供创建文件等接口</p><p>open的执行过程</p><ol><li>利用manifest recover；impl-&gt;Recover(&amp;edit, &amp;save_manifest);<ol><li>包含两部分1. versions_-&gt;Recover(save_manifest);  2. <code>RecoverLogFile(logs[i], (i == logs.size() - 1), save_manifest, edit, &amp;max_sequence);</code></li><li>在dbdir 里找到logfile，根据文件名的序号排序，将排序后的logfile按序执行RecoverLogFile</li></ol></li><li>version和logfile replay后将状态记录给versionEdit，versionEdit的内容主要包括log_number_、last_sequence_、next_file_number_和new_files_(tablefile)。</li><li>最后执行VersionSet::LogAndApply，将VersionEdit SaveTo Version，然后把version append到versionSet</li></ol><h4 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h4><p>Write的执行过程</p><ol><li><code>MakeRoomForWrite(updates == nullptr);</code> 如果mem空间不够，将mem设置成imm，新建mem，触发dump</li><li><code>WriteBatch* write_batch = BuildBatchGroup(&amp;last_writer);</code> 将writer放入到WriteBatchInternal::Append</li><li><code>log_-&gt;AddRecord(WriteBatchInternal::Contents(write_batch));</code></li><li><code>WriteBatchInternal::InsertInto(write_batch, mem_);</code></li><li><code>DB::Write</code>可以多线程执行，使用生产者消费者作为线程切换。线程同时可以是生产者，也可以是消费者。线程申请锁，把write放入队列，然后检查writer队列，如果有writer则执行具体write</li></ol><h4 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h4><p>Get的执行过程</p><ol><li>如果没有传入snapshot，设置snapshot为snapshot &#x3D; versions_-&gt;LastSequence();</li><li>LookupKey lkey(key, snapshot); lookup key包含了seq</li><li>mem-&gt;Get(lkey, value, &amp;s)</li><li>imm-&gt;Get(lkey, value, &amp;s)</li><li>current-&gt;Get(options, lkey, value, &amp;stats) (即Version::Get)<ol><li>对L0的文件按照filenumber从大到小排序，遍历检索(L0 tablefile内部key有序，文件之间key无序, 文件有number顺序)</li><li>对L1以下的文件，每层使用二分查找找到指定的tablefile</li><li>对tablefile内部，首先使用TableCache::Get 尝试在cache中查找。cache是tablefile共享的，key是filenumber。如果tablefile没有cache，则读取文件插入cache。注意到tablecache只是pagecache上面的一层，tablecache 会cache住tablefile的metaindex_handle、index_block等元数据信息</li><li>tablefile内的检索过程 1. rep_-&gt;index_block-&gt;NewIterator 迭代器seek index_block 2. Iterator* block_iter &#x3D; BlockReader(this, options, iiter-&gt;value()); seek block</li></ol></li></ol><p>skiplist的元素顺序</p><ol><li>元素格式| key_size | key | seq,type | value_size | value</li><li>从key部分之后开始排序</li><li>对于key相同的，包括delete标签，按照seq从大到小排序</li><li>mem-&gt;Get 主要调用的是SkipList<code>&lt;Key, Comparator&gt;::FindGreaterOrEqual</code>，默认get key的seq是最近的seq，FindGreaterOrEqual会直接得到第一个key（也就是seq最大的key）。设置快照后get key会得到&lt;&#x3D;某seq的key。</li></ol><p>Delete 和Write实现一致，key会有个标签标志该key是delete。</p><p>db检索元素使用的是迭代器的seek，例如<br><code>inline void SkipList&lt;Key, Comparator&gt;::Iterator::Seek(const Key&amp; target)</code></p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器基本接口</p><ol><li>检索void Seek(const Key&amp; target);</li><li>获得前后元素void Next(); void Prev();</li><li>获得指向的节点</li><li>插入元素void Insert(const Key&amp; key);</li></ol><p>主要迭代器<br>SkipList::Iterator 用于操作mem和Imm table</p><p>TwoLevelIterator 用于检索tablefile，一次性需要把一个tablefile完全加载到内存</p><p>Block::Iter，操作tablefile的一个datablock，用于检索。1. 检索到RestartPoint 2. 从RestartPoint进一步检索得到key</p><p>MergingIterator 用于compaction。管理一层的若干tablefile，用来合并成为新的tablefile。采用多路败者树进行多个有序文件合并</p><p>只有skiplist需要插入修改，tablefile的修改只有append写。</p><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>versionEdit对应manifest的一条记录</p><p>version只记录了tablefile的分布，不记录redolog和skiplist部分。redolog和skiplist 使用seq记录版本。<br>seq+version构成了快照，一个快照在tablefile中对应一个版本，被快照引用的tablefile不会被回收（即使被compaction了）</p><p>恢复版本就是选择版本包含的tablefile进行管理；恢复快照还需要把redolog 全量恢复，其中log_number用来恢复memtable，prev_log_number用来恢复immutable。切换logfile时会向manifest写入新的log_number。</p><h3 id="memtable-log"><a href="#memtable-log" class="headerlink" title="memtable+log"></a>memtable+log</h3><p>memtable就是skiplist，节点格式</p><p>| key_size | key | seq,type | value_size | value</p><p>log的记录是writebatch序列化的结果，对于write操作，格式</p><p>| kTypeValue, seq | key_size | key | value_size | value |  … </p><p>对于delete操作，格式</p><p>| kTypeDeletion，seq |  key_size | key |</p><h3 id="tablefile"><a href="#tablefile" class="headerlink" title="tablefile"></a>tablefile</h3><p>tablefile使用TableBuilder构建</p><p>tablefile没有header<br>格式</p><ol><li>data block</li><li>Write filter block</li><li>Write metaindex block</li><li>Write index block</li><li>Write footer</li></ol><p>indexblock 每个元素是datablock的最后一个key</p><p>metaindex block记录除datablock, indexblock之外的block的位置，例如filter block（布隆过滤器）</p><p>footer<br>| metaindex_handle_ | index_handle_ | kTableMagicNumber | </p><p>metaindex_handle_，index_handle_ 记录了metaindex block和index block的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Footer::EncodeTo</span><span class="params">(std::string* dst)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> original_size = dst-&gt;<span class="built_in">size</span>();</span><br><span class="line">  metaindex_handle_.<span class="built_in">EncodeTo</span>(dst);</span><br><span class="line">  index_handle_.<span class="built_in">EncodeTo</span>(dst);</span><br><span class="line">  dst-&gt;<span class="built_in">resize</span>(<span class="number">2</span> * BlockHandle::kMaxEncodedLength);  <span class="comment">// Padding</span></span><br><span class="line">  <span class="built_in">PutFixed32</span>(dst, <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(kTableMagicNumber &amp; <span class="number">0xffffffffu</span>));</span><br><span class="line">  <span class="built_in">PutFixed32</span>(dst, <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(kTableMagicNumber &gt;&gt; <span class="number">32</span>));</span><br><span class="line">  <span class="built_in">assert</span>(dst-&gt;<span class="built_in">size</span>() == original_size + kEncodedLength);</span><br><span class="line">  (<span class="type">void</span>)original_size;  <span class="comment">// Disable unused variable warning.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="借助单元测试分析源码"><a href="#借助单元测试分析源码" class="headerlink" title="借助单元测试分析源码"></a>借助单元测试分析源码</h3><p>unittest是分析代码的有效入口，以db_test为例</p><h4 id="case1-Empty"><a href="#case1-Empty" class="headerlink" title="case1 Empty"></a>case1 Empty</h4><p>DBTest, Empty，尝试以不同option配置打开db<br>可选择的配置，<code>&#123; kDefault, kReuse, kFilter, kUncompressed, kEnd &#125;</code></p><p>执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(DBTest, Empty) &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">ASSERT_TRUE</span>(db_ != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;NOT_FOUND&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">ChangeOptions</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Switch to a fresh database with the next option configuration to</span></span><br><span class="line">  <span class="comment">// test.  Return false if there are no more configurations to test.</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">ChangeOptions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    option_config_++;</span><br><span class="line">    <span class="keyword">if</span> (option_config_ &gt;= kEnd) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">DestroyAndReopen</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">OptionConfig</span> &#123; kDefault, kReuse, kFilter, kUncompressed, kEnd &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">DestroyAndReopen</span><span class="params">(Options* options = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> db_;</span><br><span class="line">    db_ = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">DestroyDB</span>(dbname_, <span class="built_in">Options</span>());</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">TryReopen</span>(options));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Status TryReopen(Options* options) 需要传入Option</span></span><br><span class="line">  <span class="function">Status <span class="title">TryReopen</span><span class="params">(Options* options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> db_;</span><br><span class="line">    db_ = <span class="literal">nullptr</span>;</span><br><span class="line">    Options opts;</span><br><span class="line">    <span class="keyword">if</span> (options != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      opts = *options;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      opts = <span class="built_in">CurrentOptions</span>();</span><br><span class="line">      opts.create_if_missing = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    last_options_ = opts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DB::<span class="built_in">Open</span>(opts, dbname_, &amp;db_);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>cmake debug模式编译<br>cmake -DCMAKE_BUILD_TYPE&#x3D;Debug ..</p><h4 id="case02，03-EmptyKey-EmptyValue"><a href="#case02，03-EmptyKey-EmptyValue" class="headerlink" title="case02，03 EmptyKey, EmptyValue"></a>case02，03 EmptyKey, EmptyValue</h4><p>不同option打开db，put key同时可以get到</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(DBTest, EmptyKey) &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">Put</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;v1&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v1&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">Put</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;v2&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v2&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">ChangeOptions</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST_F</span>(DBTest, EmptyValue) &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">Put</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;v1&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v1&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;key&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">Put</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;key&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">Put</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;v2&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v2&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;key&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">ChangeOptions</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="case04-ReadWrite"><a href="#case04-ReadWrite" class="headerlink" title="case04 ReadWrite"></a>case04 ReadWrite</h4><p>读写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(DBTest, ReadWrite) &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">Put</span>(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;v1&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v1&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">Put</span>(<span class="string">&quot;bar&quot;</span>, <span class="string">&quot;v2&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">Put</span>(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;v3&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v3&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v2&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;bar&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">ChangeOptions</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="case05-PutDeleteGet"><a href="#case05-PutDeleteGet" class="headerlink" title="case05 PutDeleteGet"></a>case05 PutDeleteGet</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(DBTest, PutDeleteGet) &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(db_-&gt;<span class="built_in">Put</span>(<span class="built_in">WriteOptions</span>(), <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;v1&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v1&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(db_-&gt;<span class="built_in">Put</span>(<span class="built_in">WriteOptions</span>(), <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;v2&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v2&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(db_-&gt;<span class="built_in">Delete</span>(<span class="built_in">WriteOptions</span>(), <span class="string">&quot;foo&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;NOT_FOUND&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">ChangeOptions</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPECT_LEVELDB_OK(expression) \</span></span><br><span class="line"><span class="meta">  EXPECT_THAT(expression, leveldb::test::IsOK())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT_LEVELDB_OK(expression) \</span></span><br><span class="line"><span class="meta">  ASSERT_THAT(expression, leveldb::test::IsOK())</span></span><br></pre></td></tr></table></figure><h4 id="case06-GetFromImmutableLayer"><a href="#case06-GetFromImmutableLayer" class="headerlink" title="case06 GetFromImmutableLayer"></a>case06 GetFromImmutableLayer</h4><p>核心是三行</p><p>env_-&gt;delay_data_sync_.store(true, std::memory_order_release);<br>Put(“k1”, std::string(100000, ‘x’));  &#x2F;&#x2F; Fill memtable.<br>Put(“k2”, std::string(100000, ‘y’));  &#x2F;&#x2F; Trigger compaction.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(DBTest, GetFromImmutableLayer) &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    Options options = <span class="built_in">CurrentOptions</span>();</span><br><span class="line">    options.env = env_;</span><br><span class="line">    options.write_buffer_size = <span class="number">100000</span>;  <span class="comment">// Small write buffer</span></span><br><span class="line">    <span class="built_in">Reopen</span>(&amp;options);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">Put</span>(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;v1&quot;</span>));</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v1&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Block sync calls.</span></span><br><span class="line">    env_-&gt;delay_data_sync_.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">    <span class="built_in">Put</span>(<span class="string">&quot;k1&quot;</span>, std::<span class="built_in">string</span>(<span class="number">100000</span>, <span class="string">&#x27;x&#x27;</span>));  <span class="comment">// Fill memtable.</span></span><br><span class="line">    <span class="built_in">Put</span>(<span class="string">&quot;k2&quot;</span>, std::<span class="built_in">string</span>(<span class="number">100000</span>, <span class="string">&#x27;y&#x27;</span>));  <span class="comment">// Trigger compaction.</span></span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v1&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">    <span class="comment">// Release sync calls.</span></span><br><span class="line">    env_-&gt;delay_data_sync_.<span class="built_in">store</span>(<span class="literal">false</span>, std::memory_order_release);</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">ChangeOptions</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put key2时，1. 将mem变成imm 2. 后台触发compaction</p><p>如果delay_data_sync_ 设置true，后台compaction线程阻塞在L0-&gt;L1的DBImpl::WriteLevel0Table。imm_尚未被删除，foo还是会在imm_中读取</p><p>write_buffer_size 作用<br>DBImpl::MakeRoomForWrite 发现mem_-&gt;ApproximateMemoryUsage() &gt; options_.write_buffer_size)，认为没有空间，然后执行</p><ol><li>s &#x3D; env_-&gt;NewWritableFile(LogFileName(dbname_, new_log_number), &amp;lfile);</li><li>设置Imm,imm_ &#x3D; mem_;<br>   has_imm_.store(true, std::memory_order_release);<br>   mem_ &#x3D; new MemTable(internal_comparator_);</li><li>MaybeScheduleCompaction();</li></ol><p>delay_data_sync_ 的作用，从取名上作用是延迟sync。其实就是datafile的sync()函数一直阻塞。</p><p>什么时候执行Sync()</p><ol><li>recover时，如果db不存在，执行DBImpl::NewDB()。执行manifest file-&gt;Sync();</li><li> DBImpl::FinishCompactionOutputFile 执行compact-&gt;outfile-&gt;Sync();<ol><li>FinishCompactionOutputFile函数在minor compaction和major compaction执行完之后都会执行</li></ol></li><li>DBImpl::Write 执行logfile_-&gt;Sync();</li><li>DBImpl::WriteLevel0Table 执行BuildTable，最后执行s &#x3D; file-&gt;Sync();</li></ol><p>如果delay_data_sync_ 设置true，会卡在L0-&gt;L1的DBImpl::WriteLevel0Table。imm_尚未被删除，数据还是会在imm_中读取</p><p>MaybeScheduleCompaction 函数逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::MaybeScheduleCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="keyword">if</span> (background_compaction_scheduled_) &#123;</span><br><span class="line">    <span class="comment">// Already scheduled</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// DB is being deleted; no more background compactions</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// Already got an error; no more changes</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp; manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             !versions_-&gt;<span class="built_in">NeedsCompaction</span>()) &#123;</span><br><span class="line">    <span class="comment">// No work to be done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    background_compaction_scheduled_ = <span class="literal">true</span>;</span><br><span class="line">    env_-&gt;<span class="built_in">Schedule</span>(&amp;DBImpl::BGWork, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PosixEnv::Schedule<br>作为生产者</p><ol><li>如果background_work_queue_为空，唤醒background_work_cv_（消费线程会重新申请锁</li><li>将任务加入到background_work_queue_，线程保护<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PosixEnv::Schedule</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> (*background_work_function)(<span class="type">void</span>* background_work_arg),</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* background_work_arg)</span> </span>&#123;</span><br><span class="line">  background_work_mutex_.<span class="built_in">Lock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start the background thread, if we haven&#x27;t done so already.</span></span><br><span class="line">  <span class="keyword">if</span> (!started_background_thread_) &#123;</span><br><span class="line">    started_background_thread_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">background_thread</span><span class="params">(PosixEnv::BackgroundThreadEntryPoint, <span class="keyword">this</span>)</span></span>;</span><br><span class="line">    background_thread.<span class="built_in">detach</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the queue is empty, the background thread may be waiting for work.</span></span><br><span class="line">  <span class="keyword">if</span> (background_work_queue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    background_work_cv_.<span class="built_in">Signal</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  background_work_queue_.<span class="built_in">emplace</span>(background_work_function, background_work_arg);</span><br><span class="line">  background_work_mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  port::Mutex background_work_mutex_;</span><br><span class="line">  <span class="function">port::CondVar background_work_cv_ <span class="title">GUARDED_BY</span><span class="params">(background_work_mutex_)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> started_background_thread_ <span class="title">GUARDED_BY</span><span class="params">(background_work_mutex_)</span></span>;</span><br><span class="line">  <span class="function">std::queue&lt;BackgroundWorkItem&gt; background_work_queue_</span></span><br><span class="line"><span class="function">      <span class="title">GUARDED_BY</span><span class="params">(background_work_mutex_)</span></span>;</span><br></pre></td></tr></table></figure>GUARDED_BY 是一种在多线程编程中用于静态代码分析的注解（或宏），其核心作用是声明某个共享变量必须通过特定的锁（或其他同步机制）来保护，以避免数据竞争和并发安全问题。</li></ol><p>BackgroundWorkItem</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Stores the work item data in a Schedule() call.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Instances are constructed on the thread calling Schedule() and used on the</span></span><br><span class="line">  <span class="comment">// background thread.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// This structure is thread-safe beacuse it is immutable.</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">BackgroundWorkItem</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BackgroundWorkItem</span><span class="params">(<span class="type">void</span> (*function)(<span class="type">void</span>* arg), <span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function">        : function(function), arg(arg) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span> (*<span class="type">const</span> function)(<span class="type">void</span>*);</span><br><span class="line">    <span class="type">void</span>* <span class="type">const</span> arg;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PosixEnv::BackgroundThreadMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    background_work_mutex_.<span class="built_in">Lock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until there is work to be done.</span></span><br><span class="line">    <span class="keyword">while</span> (background_work_queue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      background_work_cv_.<span class="built_in">Wait</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(!background_work_queue_.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">auto</span> background_work_function = background_work_queue_.<span class="built_in">front</span>().function;</span><br><span class="line">    <span class="type">void</span>* background_work_arg = background_work_queue_.<span class="built_in">front</span>().arg;</span><br><span class="line">    background_work_queue_.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    background_work_mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="built_in">background_work_function</span>(background_work_arg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动，可以看到只有一个消费者线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PosixEnv::Schedule</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> (*background_work_function)(<span class="type">void</span>* background_work_arg),</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* background_work_arg)</span> </span>&#123;</span><br><span class="line">  background_work_mutex_.<span class="built_in">Lock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start the background thread, if we haven&#x27;t done so already.</span></span><br><span class="line">  <span class="keyword">if</span> (!started_background_thread_) &#123;</span><br><span class="line">    started_background_thread_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">background_thread</span><span class="params">(PosixEnv::BackgroundThreadEntryPoint, <span class="keyword">this</span>)</span></span>;</span><br><span class="line">    background_thread.<span class="built_in">detach</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="case-08，GetFromVersions"><a href="#case-08，GetFromVersions" class="headerlink" title="case 08，GetFromVersions"></a>case 08，GetFromVersions</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(DBTest, GetFromVersions) &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">Put</span>(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;v1&quot;</span>));</span><br><span class="line">    <span class="built_in">dbfull</span>()-&gt;<span class="built_in">TEST_CompactMemTable</span>();</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v1&quot;</span>, <span class="built_in">Get</span>(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">ChangeOptions</span>());  <span class="comment">// 会执行DestroyAndReopen();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dbfull()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function">DBImpl* <span class="title">dbfull</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;DBImpl*&gt;(db_); &#125;</span><br></pre></td></tr></table></figure><p>DBImpl::TEST_CompactMemTable()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::TEST_CompactMemTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// nullptr batch means just wait for earlier writes to be done</span></span><br><span class="line">  Status s = <span class="built_in">Write</span>(<span class="built_in">WriteOptions</span>(), <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// Wait until the compaction completes</span></span><br><span class="line">    <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (imm_ != <span class="literal">nullptr</span> &amp;&amp; bg_error_.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      background_work_finished_signal_.<span class="built_in">Wait</span>();  <span class="comment">// 主动释放锁并进入阻塞状态</span></span><br><span class="line">    <span class="comment">// CompactMemTable(); 执行完会调用</span></span><br><span class="line">    <span class="comment">// background_work_finished_signal_.SignalAll(); 唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      s = bg_error_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="GetSnapshot"><a href="#GetSnapshot" class="headerlink" title="GetSnapshot"></a>GetSnapshot</h4><p>db_-&gt;GetSnapshot();</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(DBTest, GetSnapshot) &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// Try with both a short key and a long key</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">      std::string key = (i == <span class="number">0</span>) ? std::<span class="built_in">string</span>(<span class="string">&quot;foo&quot;</span>) : std::<span class="built_in">string</span>(<span class="number">200</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">      <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">Put</span>(key, <span class="string">&quot;v1&quot;</span>));</span><br><span class="line">      <span class="type">const</span> Snapshot* s1 = db_-&gt;<span class="built_in">GetSnapshot</span>();</span><br><span class="line">      <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">Put</span>(key, <span class="string">&quot;v2&quot;</span>));</span><br><span class="line">      <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v2&quot;</span>, <span class="built_in">Get</span>(key));</span><br><span class="line">      <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v1&quot;</span>, <span class="built_in">Get</span>(key, s1));</span><br><span class="line">      <span class="built_in">dbfull</span>()-&gt;<span class="built_in">TEST_CompactMemTable</span>();</span><br><span class="line">      <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v2&quot;</span>, <span class="built_in">Get</span>(key));</span><br><span class="line">      <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;v1&quot;</span>, <span class="built_in">Get</span>(key, s1));</span><br><span class="line">      db_-&gt;<span class="built_in">ReleaseSnapshot</span>(s1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">ChangeOptions</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Snapshot* <span class="title">DBImpl::GetSnapshot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> snapshots_.<span class="built_in">New</span>(versions_-&gt;<span class="built_in">LastSequence</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Creates a SnapshotImpl and appends it to the end of the list.</span></span><br><span class="line">  <span class="function">SnapshotImpl* <span class="title">New</span><span class="params">(SequenceNumber sequence_number)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">empty</span>() || <span class="built_in">newest</span>()-&gt;sequence_number_ &lt;= sequence_number);</span><br><span class="line"></span><br><span class="line">    SnapshotImpl* snapshot = <span class="keyword">new</span> <span class="built_in">SnapshotImpl</span>(sequence_number);</span><br><span class="line"></span><br><span class="line">    snapshot-&gt;next_ = &amp;head_;</span><br><span class="line">    snapshot-&gt;prev_ = head_.prev_;</span><br><span class="line">    snapshot-&gt;prev_-&gt;next_ = snapshot;</span><br><span class="line">    snapshot-&gt;next_-&gt;prev_ = snapshot;</span><br><span class="line">    <span class="keyword">return</span> snapshot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="DeletionMarkers1"><a href="#DeletionMarkers1" class="headerlink" title="DeletionMarkers1"></a>DeletionMarkers1</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(DBTest, DeletionMarkers1) &#123;</span><br><span class="line">  <span class="built_in">Put</span>(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">  <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">dbfull</span>()-&gt;<span class="built_in">TEST_CompactMemTable</span>());</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> last = config::kMaxMemCompactLevel;</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="built_in">NumTableFilesAtLevel</span>(last), <span class="number">1</span>);  <span class="comment">// foo =&gt; v1 is now in last level</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Place a table at level last-1 to prevent merging with preceding mutation</span></span><br><span class="line">  <span class="built_in">Put</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;begin&quot;</span>);</span><br><span class="line">  <span class="built_in">Put</span>(<span class="string">&quot;z&quot;</span>, <span class="string">&quot;end&quot;</span>);</span><br><span class="line">  <span class="built_in">dbfull</span>()-&gt;<span class="built_in">TEST_CompactMemTable</span>();</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="built_in">NumTableFilesAtLevel</span>(last), <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="built_in">NumTableFilesAtLevel</span>(last - <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Delete</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">  <span class="built_in">Put</span>(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="built_in">AllEntriesFor</span>(<span class="string">&quot;foo&quot;</span>), <span class="string">&quot;[ v2, DEL, v1 ]&quot;</span>);</span><br><span class="line">  <span class="built_in">ASSERT_LEVELDB_OK</span>(<span class="built_in">dbfull</span>()-&gt;<span class="built_in">TEST_CompactMemTable</span>());  <span class="comment">// Moves to level last-2</span></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="built_in">AllEntriesFor</span>(<span class="string">&quot;foo&quot;</span>), <span class="string">&quot;[ v2, DEL, v1 ]&quot;</span>);</span><br><span class="line">  <span class="function">Slice <span class="title">z</span><span class="params">(<span class="string">&quot;z&quot;</span>)</span></span>;</span><br><span class="line">  <span class="built_in">dbfull</span>()-&gt;<span class="built_in">TEST_CompactRange</span>(last - <span class="number">2</span>, <span class="literal">nullptr</span>, &amp;z);</span><br><span class="line">  <span class="comment">// DEL eliminated, but v1 remains because we aren&#x27;t compacting that level</span></span><br><span class="line">  <span class="comment">// (DEL can be eliminated because v2 hides v1).</span></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="built_in">AllEntriesFor</span>(<span class="string">&quot;foo&quot;</span>), <span class="string">&quot;[ v2, v1 ]&quot;</span>);</span><br><span class="line">  <span class="built_in">dbfull</span>()-&gt;<span class="built_in">TEST_CompactRange</span>(last - <span class="number">1</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// Merging last-1 w/ last, so we are the base level for &quot;foo&quot;, so</span></span><br><span class="line">  <span class="comment">// DEL is removed.  (as is v1).</span></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="built_in">AllEntriesFor</span>(<span class="string">&quot;foo&quot;</span>), <span class="string">&quot;[ v2 ]&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Delete的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DB::Delete</span><span class="params">(<span class="type">const</span> WriteOptions&amp; opt, <span class="type">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  WriteBatch batch;</span><br><span class="line">  batch.<span class="built_in">Delete</span>(key);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Write</span>(opt, &amp;batch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatch::Delete</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  WriteBatchInternal::<span class="built_in">SetCount</span>(<span class="keyword">this</span>, WriteBatchInternal::<span class="built_in">Count</span>(<span class="keyword">this</span>) + <span class="number">1</span>);</span><br><span class="line">  rep_.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(kTypeDeletion));</span><br><span class="line">  <span class="built_in">PutLengthPrefixedSlice</span>(&amp;rep_, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AllEntriesFor</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">AllEntriesFor</span><span class="params">(<span class="type">const</span> Slice&amp; user_key)</span> </span>&#123;</span><br><span class="line">  Iterator* iter = <span class="built_in">dbfull</span>()-&gt;<span class="built_in">TEST_NewInternalIterator</span>();</span><br><span class="line">  <span class="function">InternalKey <span class="title">target</span><span class="params">(user_key, kMaxSequenceNumber, kTypeValue)</span></span>;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  iter-&gt;<span class="built_in">Seek</span>(target.<span class="built_in">Encode</span>());</span><br><span class="line">  std::string result;</span><br><span class="line">  <span class="keyword">if</span> (!iter-&gt;<span class="built_in">status</span>().<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    result = iter-&gt;<span class="built_in">status</span>().<span class="built_in">ToString</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = <span class="string">&quot;[ &quot;</span>;</span><br><span class="line">    <span class="type">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (iter-&gt;<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">      ParsedInternalKey ikey;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">ParseInternalKey</span>(iter-&gt;<span class="built_in">key</span>(), &amp;ikey)) &#123;</span><br><span class="line">        result += <span class="string">&quot;CORRUPTED&quot;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (last_options_.comparator-&gt;<span class="built_in">Compare</span>(ikey.user_key, user_key) != <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!first) &#123;</span><br><span class="line">          result += <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        first = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">switch</span> (ikey.type) &#123;</span><br><span class="line">          <span class="keyword">case</span> kTypeValue:</span><br><span class="line">            result += iter-&gt;<span class="built_in">value</span>().<span class="built_in">ToString</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> kTypeDeletion:</span><br><span class="line">            result += <span class="string">&quot;DEL&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      iter-&gt;<span class="built_in">Next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!first) &#123;</span><br><span class="line">      result += <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result += <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> iter;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Iterator* iter &#x3D; dbfull()-&gt;TEST_NewInternalIterator();</p><p>InternalKey target(user_key, kMaxSequenceNumber, kTypeValue);<br>&#x2F;&#x2F;<br>iter-&gt;Seek(target.Encode());</p><p>这里的target 封装了seq和type</p><p>Iterator::Seek</p><p>SSTable 文件由数据块和索引块组成。索引块存储了数据块的元信息，比如每个数据块的起始键和位置。当需要查找某个键时，首先通过索引块找到对应的数据块，然后在数据块内进行查找。TwoLevelIterator负责这种两级查找过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> <span class="title class_">Comparator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> SkipList&lt;Key, Comparator&gt;::Iterator::<span class="built_in">Seek</span>(<span class="type">const</span> Key&amp; target) &#123;</span><br><span class="line">  node_ = list_-&gt;<span class="built_in">FindGreaterOrEqual</span>(target, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 负责sst file的遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TwoLevelIterator::Seek</span><span class="params">(<span class="type">const</span> Slice&amp; target)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// seek索引块</span></span><br><span class="line">  index_iter_.<span class="built_in">Seek</span>(target);</span><br><span class="line">  <span class="built_in">InitDataBlock</span>();</span><br><span class="line">  <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span>) data_iter_.<span class="built_in">Seek</span>(target);</span><br><span class="line">  <span class="built_in">SkipEmptyDataBlocksForward</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MergingIterator</span> : <span class="keyword">public</span> Iterator &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Seek</span><span class="params">(<span class="type">const</span> Slice&amp; target)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 每个children是一个SkipList::Iterator或者TwoLevelIterator</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">      children_[i].<span class="built_in">Seek</span>(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FindSmallest</span>();</span><br><span class="line">    direction_ = kForward;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure that all children are positioned after key().</span></span><br><span class="line">    <span class="comment">// If we are moving in the forward direction, it is already</span></span><br><span class="line">    <span class="comment">// true for all of the non-current_ children since current_ is</span></span><br><span class="line">    <span class="comment">// the smallest child and key() == current_-&gt;key().  Otherwise,</span></span><br><span class="line">    <span class="comment">// we explicitly position the non-current_ children.</span></span><br><span class="line">    <span class="keyword">if</span> (direction_ != kForward) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">        IteratorWrapper* child = &amp;children_[i];</span><br><span class="line">        <span class="keyword">if</span> (child != current_) &#123;</span><br><span class="line">          child-&gt;<span class="built_in">Seek</span>(<span class="built_in">key</span>());</span><br><span class="line">          <span class="keyword">if</span> (child-&gt;<span class="built_in">Valid</span>() &amp;&amp;</span><br><span class="line">              comparator_-&gt;<span class="built_in">Compare</span>(<span class="built_in">key</span>(), child-&gt;<span class="built_in">key</span>()) == <span class="number">0</span>) &#123;</span><br><span class="line">            child-&gt;<span class="built_in">Next</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      direction_ = kForward;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current_-&gt;<span class="built_in">Next</span>();</span><br><span class="line">    <span class="built_in">FindSmallest</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Which direction is the iterator moving?</span></span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">Direction</span> &#123; kForward, kReverse &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">FindSmallest</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">FindLargest</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We might want to use a heap in case there are lots of children.</span></span><br><span class="line">  <span class="comment">// For now we use a simple array since we expect a very small number</span></span><br><span class="line">  <span class="comment">// of children in leveldb.</span></span><br><span class="line">  <span class="type">const</span> Comparator* comparator_;</span><br><span class="line">  IteratorWrapper* children_;</span><br><span class="line">  <span class="type">int</span> n_;</span><br><span class="line">  IteratorWrapper* current_;</span><br><span class="line">  Direction direction_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InternalKey</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::string rep_;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">InternalKey</span>() &#123;&#125;  <span class="comment">// Leave rep_ as empty to indicate it is invalid</span></span><br><span class="line">  <span class="built_in">InternalKey</span>(<span class="type">const</span> Slice&amp; user_key, SequenceNumber s, ValueType t) &#123;</span><br><span class="line">    <span class="built_in">AppendInternalKey</span>(&amp;rep_, <span class="built_in">ParsedInternalKey</span>(user_key, s, t));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>迭代器具体使用</p><p>详细线程模型和并发控制</p><p>模块依赖和编译依赖</p><p>性能分析</p>]]></content>
      
      
      <categories>
          
          <category> single-machine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> single-machine </tag>
            
            <tag> storage </tag>
            
            <tag> leveldb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储——分布式存储底座</title>
      <link href="/2025/01/07/%E5%AD%98%E5%82%A8%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%BA%95%E5%BA%A7/"/>
      <url>/2025/01/07/%E5%AD%98%E5%82%A8%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%BA%95%E5%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>分布式存储底座包括分布式文件系统和分布式一致性KV存储。对外满足的条件 1. 提供数据可靠性，底座之上不需要担心数据损坏 2. 提供数据可用性，节点崩溃不影响数据读写 3. 集群级接口，多机节点可访问</p><span id="more"></span><h3 id="HDFS-分布式文件系统"><a href="#HDFS-分布式文件系统" class="headerlink" title="HDFS 分布式文件系统"></a>HDFS 分布式文件系统</h3><p>Hadoop Distributed File System 分布式文件系统</p><p>由中心化节点namenode和多个datanode节点组成。namenode 维护文件目录结构，负责文件创建、打开、关闭、重命名等操作，不支持软链接&#x2F;硬链接。namenode维护了文件信息，datanode只有块信息不感知文件，块大小默认是128MB。</p><p>对于文件系统的修改，例如创建打开文件，namenode会持久化到Editlog。为加快重启后恢复，Editlog使用checkpoint，同时secondNamenode会尽量接近namenode，以便namenode崩溃重新选主后恢复。</p><p>namenode借助zookeeper保证可用性，zookeeper同时记录服务信息，例如正在运行的namenode和可用的datanode地址。</p><p>client 使用FileStream抽象访问文件，FileStream自动和namenode&#x2F;datanode交互。例如执行读操作时，FileStream自动从namenode获得文件包含的块和datanode信息，然后访问指定的datanode读对应的块。执行写操作时，FileStream从namenode拿到可写的块，然后向指定的datanode发写请求。如果使用三副本容错机制，写操作需要同时拿到三个位于不同datanode的可写的块，然后写三份等待返回。</p><p>三副本写有以下写策略</p><ol><li>客户端向三个datanode发三个写请求，等待三个写成功返回</li><li>客户端向三个datanode发三个写请求，两个返回就可认为成功，最后一个请求可以后台慢慢追赶写。也就是二三异步写。这种延迟最低。</li><li>客户端链式发请求，即先写第一个副本，成功后写第二个，再成功后写第三个</li></ol><p>为了保证数据完整性，数据在磁盘中存放和io链路都要进行crc校验。</p><h3 id="hdfs的缺陷"><a href="#hdfs的缺陷" class="headerlink" title="hdfs的缺陷"></a>hdfs的缺陷</h3><p>hdfs的主要问题是元数据不可扩展</p><ol><li>单点namenode，元数据无法横向扩展。读需要找namenode拿数据块的layout，写需要找namenode拿可写的数据库，单namenode无法支持高iops的读写和元数据</li><li>由于分布式系统存在飞着的请求，加上重试，可能导致数据安全风险。例如某客户端写完两副本，第三个副本挂了；该客户端重新申请个新的第三个副本，此时挂了的副本好了，飞着的请求被处理，导致写了两次第三个副本。</li></ol><p>问题1, 可以使用通过子树划分的分布式元数据解决，分布式文件系统一般不实现link文件，对于rename操作，分布式元数据情况下需要保证多节点原子性。可以将rename操作统一打到一个节点，该节点单线程执行任务实现原子性，rename操作一般延迟较其他元数据操作差。</p><p>问题2, 可以使用seal 机制处理，seal后的chunk不可写。当chunk数据写完需要切chunk，或某chunk写失败需要换chunk写，原来的chunk会seal掉，seal的chunk只读不写，可以保证问题2 飞着的请求在seal 的chunk无法写操作。</p><p><a href="https://www.cs.purdue.edu/homes/csjgwang/CloudNativeDB/AzureStorageSOSP11.pdf">Windows Azure Storage</a> 这篇论文介绍的是更现代的分布式文件系统，主要有以下特点</p><ol><li>服务分成Front-End (FE)、Partition、Stream三个部分。Front-End服务协议层接受请求，转发到指定的Partiton；Partiton存储逻辑数据；Stream真正存储数据，分成extent和block两层，extent大小1GB，block大小4M</li><li><strong>partition层提供的是支持事务的数据库表&#x2F;对象&#x2F;文件存储</strong>。partition由若干object组成，object是固定大小存储单位，partition内部object的操作是原子的，提供事务操作（即多个object操作提供原子性）。partition记录用户文件和stream存储位置的映射（Blob表）、文件属性表和目录表(entity表)，并且保证相同partition内的表支持事务操作。（分布式文件系统元数据主要有两种，一种维护layout布局信息，另一种维护文件目录信息，这两种元数据可以隔离防止干扰？）</li><li>partition层有一个partition manager(master)，维护partition和节点ip信息，master由Paxos Lock保证一致性（分布式文件系统中处理元数据，还应该有一个元元数据角色，保存系统自己的配置和元信息，元元数据实现paxos协议保证可靠性）</li><li>partition层的数据表是KV存储，类似LSM tree结构。partition按照key的range划分（相比一致性hash分片，Range Partitions更简单，能充分利用局部性）支持分裂。（需要考虑到分裂后的两个partition之间不提供事务和原子性保证了）</li><li><strong>stream层才是分布式文件系统层</strong>，它提供文件语义操作。stream层分为extent(1GB)和block(4MB)两层。stream只支持append-only写，且extent支持seal。seal后的extent只读。stream层有实现paxos协议的Stream Manager(master) 维护了文件系统namespace，block等布局信息（stream master应该能支持按子树划分，实现分布式元数据）</li></ol><p>append-only系统</p><p>Append-only System – Having an append-only system and sealing an extent upon failure have greatly simplified the replication protocol and handling of failure scenarios. <strong>In this model, the data is never overwritten once committed to a replica</strong>, and, upon failures, the extent is immediately sealed. This model allows the consistency to be enforced across all the replicas via their commit lengths</p><p>An append-based system comes with certain costs. <strong>An efficient and scalable garbage collection (GC) system is crucial to keep the<br>space overhead low</strong>, and GC comes at a cost of extra I&#x2F;O. In addition, the data layout on disk may not be the same as the virtual address space of the data abstraction stored, which led us to implement prefetching logic for streaming large data sets back<br>to the client. </p><p>append-only系统清理碎片：新建文件，将旧文件的非垃圾数据写到新文件，删除旧文件（旧文件除了最后一个chunk, 前面的chunk是seal的，GC时不用担心新增数据）</p><h3 id="zookeeper-和zab-一致性KV协议"><a href="#zookeeper-和zab-一致性KV协议" class="headerlink" title="zookeeper 和zab 一致性KV协议"></a>zookeeper 和zab 一致性KV协议</h3><p>zookeeper依赖ZAB（Zookeeper Atomic Broadcast）协议实现分布式数据一致性。<strong>zab协议通过两阶段提交和多数通过两个原则保证即使leader挂了，系统仍可具备数据可靠性和强一致性</strong>。zab选择了强一致性，牺牲了可用性，即leader选举过程中，zookeeper不可用。zab协议下，集群的节点有两种角色：leader和follower。</p><p>两阶段提交，leader将写请求广播到follower，写请求会携带一个自增的zxid，follower 接收到写请求，将写请求写到本地事务日志，成功后再向Leader 回一个ACK确认。leader收到多数确认后，认为事务已经提交，通知follower执行消息。zxid记录了事务日志的最新更新，leader的zxid肯定最大，同时任意时刻系统超过多数follower的zxid和leader一致。</p><p>当leader崩溃时,zxid可以保证选举上来的follower的zxid和崩溃的leader一致，也就是本地事务日志是最新的。如果选举上来的leader发现自己本地的zxid没有执行，有两种可能1. zxid是最新的，leader尚未来得及通知执行就崩溃了，这时候应该执行；2. zxid是未提交的，需要重新进行两阶段提交。不管怎样，<strong>新leader上来对自身的zxid广播一遍，如果具有最新zxid的节点过半数，则通知他们执行；如果未过半数，则重新广播一次提交。</strong></p><p><strong>两阶段提交是单点串行的</strong>，也就是一个写操作执行完之后下一个才能执行，这就导致zookeeper不能执行高iops的写操作。</p><p>读操作需要经由leader返回版本和leader一致的follower，再从该follower里读。</p><p>新leader选举成功后，epoch+1，同时广播给follower，follower更新自身的epochid和leader一致。</p><p>当集群启动，或leader崩溃时，zookeeper需要进行leader选主</p><ol><li>集群开始启动时，每个节点状态都是follower。follower自身会维护leader信息，集群中节点的数量，定期检查leader的存在。<strong>如果leader不存在，follower 将状态改为LOOKING</strong>，准备选举</li><li>节点携带(myid, zxid，epochid)向集群其他节点发选主请求（包括自己），只要同意的节点超过集群节点数量的1&#x2F;2，当前节点就会认为自己是leader。myid 是每个节点初始化配置的id，zxid是leader执行一次事务就会递增的id。当节点收到选主请求时，会先比较epochid，相等再比较zxid, zxid相等则比较myid，请求携带的id如果比自身大，就返回投票响应，否则拒绝投票。集群开始启动时，所有节点的zxid都为0，最终myid大的会被投票成leader</li><li>如果节点处于looking状态，收到投票请求，且发现对方id比自己大，节点会选择投票给对方id，并广播出去</li><li>如果一个节点收到选择自己作为leader的数量大于一半节点，会将自己作为leader，同时广播给集群其他节点</li><li>epochid和zxid小的不可能成为leader，借助两阶段提交，保证成为leader的节点必然具有所有的提交</li></ol><p>如果某个节点收到请求A，发现比自己id大投票给他，后来又收到请求B，发现比自己id大又投票给了B。会不会导致A，B同时被选为leader？</p><ol><li>什么时候出现？ 假设集群节点A、B、C、D，且四个节点zxid一致；leader挂了，节点C先发现，它向节点A、B、D发投票请求，A、B同意，D虽然反对，但不影响，C成了leader。后面节点D也发现leader挂了，于是向A、B、C发信息，A、B投票给了D，此时C已经成了leader，所以集群出现了两个leader？No，在C自认为成为leader后，需要广播到follower，follower会检查合法性，只有合法性过半数才能正式成为leader。所以如果A，B后来投票给了D，那么C的合法性检查会不通过；<strong>如果C合法性检查通过了，D再给A、B发选举请求，A、B将不予处理，C依然成为leader</strong>，C成为leader后将epoch更新通知D，D也会接受C成为leader。</li><li>因此只有当A，B节点检查到leader挂了，它才会进入looking状态，<strong>如果A、B检测到leader存活，其他节点对A、B发送请求选择，A、B将不予理会。</strong></li></ol><h3 id="raft-一致性KV协议"><a href="#raft-一致性KV协议" class="headerlink" title="raft 一致性KV协议"></a>raft 一致性KV协议</h3><p>raft 集群节点的角色有三种，leader, follower和candidate。其中candidate用于选举。</p><p>raft leader的写提交同样是zab的两阶段提交。因为<strong>两阶段提交能保证，leader挂了选上来的follower具有全部的已经提交的记录</strong> 。缺点是两阶段提交必须串行，不能高并发写</p><ol><li>leader issue AppendEntries RPC in parallel；leader wait for majority response</li><li>leader notify follower apply log</li></ol><p>raft 选举leader的协议和zab有所不同。当follower一定时间没有收到leader的心跳时，会进入选举状态</p><ol><li>raft节点维护一个term信息，当自己身份变为candidate时，会将term +1。</li><li>向所有节点发起 RequestVoteRPC 请求，请求包含（term，最后一条日志的任期号，最后一条日志的索引号<ol><li>节点收到RequestVoteRPC请求时，先比较term， 再比较最后一条日志任期号，最后比较最后一条日志索引号。这些是保证投票给的节点具有所有已提交的日志）</li></ol></li><li>等待rpc期间，如果收到其他节点声明自己是 Leader的请求<ol><li>该 Leader 的 term 号大于等于自己的 term 号，说明对方已经成为 Leader，则自己回退为 Follower。</li><li>该 Leader 的 term 号小于自己的 term 号，那么会拒绝该请求并让该节点更新 term。</li></ol></li></ol><p>raft 选举基于《只要选择出的节点具有所有已经提交的日志，选谁都行》的原则，没有zab的myid这项规则，比zab选举要快。zab等待rpc期间收到其他节点声明自己是leader的请求，由于Myid的原因可能也会否决。</p><p>raft 两阶段提交写操作时，如果某节点落后太多，会强制将该节点日志和leader日志拉齐；如果某节点有很多日志但是没有提交，这些没有被提交的日志会被需要提交的日志覆盖。</p><p><strong>如果不同节点日志中的两个条目有着相同的索引和任期号，则它们之间的所有条目都是完全一样的。</strong></p><h3 id="Paxos和multi-Paxos-一致性协议"><a href="#Paxos和multi-Paxos-一致性协议" class="headerlink" title="Paxos和multi Paxos 一致性协议"></a>Paxos和multi Paxos 一致性协议</h3><h4 id="Basic-Paxos"><a href="#Basic-Paxos" class="headerlink" title="Basic Paxos"></a>Basic Paxos</h4><p>paxos的角色：Proposer提案者，Acceptor 投票者，Learner学习者</p><p>准备阶段Prepare</p><ol><li>提案者向集群中的投票者发起提案编号为n的请求</li><li>投票者检查，如果发现自己之前的提案都小于n，则接受请求并承诺不会接受编号小于n的提案；否则拒绝提案</li></ol><p>如果准备阶段提案者接受到了半数以上通过，则继续批准阶段Accept</p><ol><li>提案者携带提案号n和提案值发给投票者</li><li>投票者确认提案编号不小于已承诺的最大编号，如果确认返回同意，否则拒绝<br>如果结果超半数同意，广播给集群所有的Proposer，Acceptor，Learner，Learner负责记录最终结果</li></ol><p>提议者可以同时也是决策者，提议者可以多个</p><p>basic paxos达成共识至少需要prepare和accept两次网络往返，高并发情况下可能导致活锁(多个提议者同时发起提案且一直重试，反复更新决策者上的提案编号，且任何一方都无法达到多数派决议来通过准备阶段)。因此，Paxos 算法主要用于理论研究，较少直接应用于工程实践。</p><h4 id="multi-Paxos"><a href="#multi-Paxos" class="headerlink" title="multi Paxos"></a>multi Paxos</h4><p>Multi-Paxos 通过选举出一个 Proposer 主节点，只有主节点可以发提案，避免多个Proposer同时发起提案反复影响。</p><p>集群中的若干Proposer 定期监测Proposer 主节点是否存在。当监测不存在时，向 Acceptors 发出选主 Proposer 申请。如果选主申请得到大多数Acceptors节点同意，该 Proposer 成为主节点。</p><p>TODO </p><h3 id="Tikv-和分布式KV存储"><a href="#Tikv-和分布式KV存储" class="headerlink" title="Tikv 和分布式KV存储"></a>Tikv 和分布式KV存储</h3><p>zab, raft, multi paxos这些协议提供服务自身的可用性保证。hdfs的datanode如果挂了，可以通过namenode找到数据块另外的可用节点，namenode挂了，可以通过zookeeper重新选主，但是zookeeper的leader挂了，这个只能zookeeper利用协议自己去保证。</p><p>tikv 的记录会写入三副本，三副本按照multi-paxos组织，位于不同的三个节点。三副本其中一个作为leader，如果其中一个副本挂了（包含副本的节点挂了），会自动选出新的leader副本。<strong>单paxos以及zab, raft写入都是串行的</strong>，也就是说不论集群有多大，写入都经过一个leader。<strong>multi-paxos的最大优势是提高并发，例如一个数据子表一个paxos，可以实现多个数据子表的并行写</strong>。同时paxos自身可实现三副本自身的可用性（不依赖外部namenode就可以在崩溃后找到新的替代节点），同时利用leader实现写操作的事务支持。使用multi-paxos的好处还有，十分方便扩缩容&#x2F;横向扩展，只需要扩一个follower进去, leader会自动将数据同步。</p><p>tikv 的设计来自google 的<a href="https://static.googleusercontent.com/media/research.google.com/en//archive/spanner-osdi2012.pdf">spanner</a></p><p>At every replica that is a leader, each spanserver also implements a transaction manager to support distributed transactions. The transaction manager is used to implement a participant leader; the other replicas in the group will be referred to as participant slaves.<br>(tidb的paxos不是server节点级别的，而是表切片级别的，表会按照固定大小划分成切片，每个切片是支持事务的单位)</p><p>kv和append-only文件系统的最大区别是，<strong>数据库的日志要求有序性，而append-only只要求原子性。</strong>数据库的操作包括增删改，因此日志必须严格按照用户的写入顺序执行，以便通过replay日志恢复状态。因此数据库需要递增id来让请求保序（类似tcp的seq）。而append-only系统只要求数据append写入就行了，不要求写入顺序，只要求写入的完整性。kv系统的版本是顺序性日志的id，append-only文件系统的版本是写成功后，chunk的最新位置（如果master记录的某chunk最新位置和server记录的不同，以master为准）。</p><p>另外的区别是，append写之前一般就要通知给master定版本(告知master自己这次要写多少，写完后chunk新长度是多少)，这样append写失败了master可以知道（可能导致数据丢失）。而<strong>kv leader自己不能决定版本</strong>，需要1&#x2F;2以上follower确认才能定，否则数据库认为写失败。原因在于数据节点的master 分布式元数据场景下实际是元数据的server，它本身依赖元数据master提供可用性。</p><p>分布式文件系统除了三副本之外，通常使用EC纠删码实现数据冗余，EC可以降低存储成本，但使用EC的<code>[offset, length]</code>区间一般要求至少是4K对齐的。</p><p>三副本+multi-paxos+leader写 的存储模型对kv存储有很大思考价值</p>]]></content>
      
      
      <categories>
          
          <category> base </category>
          
      </categories>
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程语言(6)—编译、运行和调试</title>
      <link href="/2025/01/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(6)%E2%80%94%E7%BC%96%E8%AF%91%E3%80%81%E8%BF%90%E8%A1%8C%E5%92%8C%E8%B0%83%E8%AF%95/"/>
      <url>/2025/01/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(6)%E2%80%94%E7%BC%96%E8%AF%91%E3%80%81%E8%BF%90%E8%A1%8C%E5%92%8C%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>写完了代码第一件事是编译，编译失败只能根据编译器通知修改代码；编译通过了第二件事是跑UT，UT不过需要进行调试。调试包括debug和release包的调试，线上进程的运行问题有时候也需要调试，调试的主要方式是调试工具和日志（包括print大法）。为了发现问题，有时候还需要添加报警日志。</p><p>提高代码的健壮性，编译器、静态检查和格式化工具、调试、单元测试、日志等是开发必不可少的</p><span id="more"></span> <h3 id="C语言和C"><a href="#C语言和C" class="headerlink" title="C语言和C++"></a>C语言和C++</h3><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>为什么需要编译？</p><ol><li>计算方面，汇编代码基本可以等同于机器码。汇编语言和机器码是一行一行指令执行，高级语言的会抽象出来if-else条件执行&#x2F;while循环执行和函数执行模块，编译需要把这些模块转化成一行一行的指令；不同cpu提供的指令和寄存器不同，因而编译器的目标指令也不同（其他硬件需要和cpu兼容，一般程序只需要操纵cpu就可以同时操纵内存、磁盘、网卡等硬件）；另外，由操作系统实现中断、上下文切换等计算单元（不需要用户程序实现），也需要编译器把它们打包到编译后的二进制文件中。</li><li>数据方面，汇编语言没有类型概念，需要手动指定寄存器和内存物理地址传输数据，数据交换一般是cpu字长对齐的（64位cpu8字节对齐）；高级语言使用类型来确定数据内存分配大小，使用变量维护某一块内存区域，需要编译器记录类型变量的地址，使用变量转化为从某寄存器或内存地址拿数据的指令，动态内存转化为执行从空闲内存拿内存的指令。</li></ol><p>编译把.cpp 转化为 .o文件。对于多.cpp文件或使用到动态&#x2F;静态库的文件（几乎所有.cpp都会使用到库文件，例如glibc），需要使用链接把多个.o文件链接成一个二进制文件。链接期间还会链接跨文件共享的外部变量&#x2F;全局变量。</p><p>C++ 20引入了模块，模块相当于融合了头文件和源文件（库），编译、依赖和隔离机制更加清晰，但广泛使用还需要一定距离。</p><p>C语言和C++一般公用编译器，常用的编译器有两个，gcc和clang&#x2F;llvm。常见的gcc编译指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">g++ -c file.cpp  # 只编译</span><br><span class="line">g++ file.cpp -o program  # 编译链接</span><br><span class="line">g++ file1.cpp file2.cpp -o program  # 多文件编译</span><br><span class="line"></span><br><span class="line">-O0  # 不进行优化（默认）。</span><br><span class="line">-O1  # 基础优化，平衡编译速度和运行效率。</span><br><span class="line">-O2  # 更高的优化级别，提高性能。</span><br><span class="line">-O3  # 最高优化级别，可能增加编译时间和可执行文件体积。</span><br><span class="line">-Os  # 优化以减小可执行文件的大小。</span><br><span class="line"></span><br><span class="line">-g  # 生成调试信息，用于调试器（如 gdb）。</span><br><span class="line">-ggdb  # 为 GNU 调试器生成更详细的调试信息。</span><br><span class="line"></span><br><span class="line">-std=c++11  # 使用 C++11 标准。</span><br><span class="line">-std=c++14  # 使用 C++14 标准。</span><br><span class="line">-std=c++17  # 使用 C++17 标准。</span><br><span class="line">-std=c++20  # 使用 C++20 标准。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">警告选项</span></span><br><span class="line">-Wall  # 启用大多数常见的警告。</span><br><span class="line">-Wextra  # 启用额外的警告。</span><br><span class="line">-Werror  # 将警告视为错误。</span><br><span class="line">-pedantic  # 强制严格遵循标准。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">链接选项</span></span><br><span class="line">-l  # 指定链接库。</span><br><span class="line">-L  # 指定库文件搜索路径。</span><br><span class="line">-I  # 指定头文件搜索路径。</span><br><span class="line">g++ file.cpp -o program -lm -L/usr/lib -I/usr/include</span><br><span class="line"></span><br><span class="line">g++ -S file.cpp -o file.s  # 生成汇编代码</span><br><span class="line"></span><br><span class="line">g++ -DDEBUG file.cpp -o program  # 定义宏</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成动态库</span> </span><br><span class="line">g++ -fPIC -c file1.cpp file2.cpp  # -fPIC 生成位置无关代码</span><br><span class="line">g++ -shared -o libmylib.so file1.o file2.o  # -shared 指定生成动态库。</span><br><span class="line">g++ main.cpp -L. -lmylib -o program</span><br></pre></td></tr></table></figure><p>makefile是GNU推出的编译工具，GNU Autotools使用 autogen.sh + configure + make经典编译流程</p><ol><li>.&#x2F;autogen.sh 生成 configure 脚本和 Makefile.in 模板。</li><li><code>./configure [options]</code> 配置编译选项</li><li>make 利用makefile编译代码<br>这一套流程比较原始，只推荐编译老项目，不建议在新项目使用</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">CC = g++  # 变量定义</span><br><span class="line">CFLAGS = -Wall -g</span><br><span class="line">OBJ = main.o utils.o</span><br><span class="line">TARGET = program</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">规则</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(TARGET): $(OBJ)</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(CC) $(CFLAGS) -o <span class="variable">$@</span> $^</span></span><br><span class="line"></span><br><span class="line">main.o: main.cpp utils.h</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(CC) $(CFLAGS) -c $&lt;</span></span><br><span class="line"></span><br><span class="line">utils.o: utils.cpp utils.h</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(CC) $(CFLAGS) -c $&lt;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">伪目标</span></span><br><span class="line">clean:</span><br><span class="line">rm -rf $(OBJ) $(TARGET)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$@</span> 当前目标的名字。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">$&lt; 第一个依赖文件。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">$^ 所有依赖文件。</span></span><br><span class="line"></span><br><span class="line">make  # 构建目标</span><br><span class="line">make clean # 清理构建文件</span><br></pre></td></tr></table></figure><p>现代的编译工具是cmake和bazel。</p><ol><li>CMake 是一个脚本，能自动生成 Makefile 或其他构建系统文件(如 Ninja 或 Visual Studio 项目文件)</li><li>google提供的bazel 除了是编译工具, 还可以作为包管理工具。bazel 一次编译好代码，不再使用make中间步骤</li></ol><h4 id="cmake-构建语法"><a href="#cmake-构建语法" class="headerlink" title="cmake 构建语法"></a>cmake 构建语法</h4><p>cmake构建过程一般是经典两步</p><ol><li>cmake -DCMAKE_BUILD_TYPE&#x3D;Debug .. </li><li>make</li></ol><p>基本命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.10)  # CMake 最低版本要求</span><br><span class="line"></span><br><span class="line">project(MyProject VERSION 1.0 LANGUAGES C CXX)  # 定义项目名称和语言</span><br><span class="line"></span><br><span class="line">add_executable(myapp main.cpp)  # add_executable 添加可执行文件</span><br><span class="line"></span><br><span class="line">add_library(mylibrary STATIC lib.cpp)  # add_library 添加库</span><br><span class="line"></span><br><span class="line">target_link_libraries(myapp mylibrary) # target_link_libraries 将库链接到目标</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">include_directories($</span><span class="language-bash">&#123;CMAKE_SOURCE_DIR&#125;/include)  <span class="comment"># include_directories为编译器添加头文件搜索路径。</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add_dependencies 控制目标之间的构建顺序，构建顺序</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add_dependencies(&lt;target&gt; &lt;depend1&gt; &lt;depend2&gt; ...)</span></span><br><span class="line"></span><br><span class="line">set(MY_VAR &quot;Hello&quot;)  # set 设置变量值</span><br><span class="line"></span><br><span class="line">message(STATUS &quot;This is a status message.&quot;)  # message 打印信息，支持不同的输出级别</span><br><span class="line">message(WARNING &quot;This is a warning message.&quot;)</span><br><span class="line">message(ERROR &quot;This is an error message.&quot;)</span><br><span class="line"></span><br><span class="line">if(MY_VAR STREQUAL &quot;Hello&quot;)  # if()判断条件</span><br><span class="line">  message(STATUS &quot;Hello&quot;)</span><br><span class="line">elseif(MY_VAR STREQUAL &quot;World&quot;)</span><br><span class="line">  message(STATUS &quot;World&quot;)</span><br><span class="line">else()</span><br><span class="line">  message(STATUS &quot;Something else&quot;)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">find_package(OpenGL REQUIRED)  # find_package 查找外部库或软件包</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">find_program 搜索指定的可执行程序，并将其路径存储到指定的变量中。HINTS优先查找的路径</span></span><br><span class="line">set(BUSTUB_CLANG_SEARCH_PATH &quot;/usr/local/bin&quot; &quot;/usr/bin&quot; &quot;/usr/local/opt/llvm/bin&quot;)</span><br><span class="line">find_program(CLANG_FORMAT_BIN</span><br><span class="line">        NAMES clang-format clang-format-14</span><br><span class="line">        HINTS $&#123;BUSTUB_CLANG_SEARCH_PATH&#125;)</span><br><span class="line"></span><br><span class="line">option(MY_FEATURE &quot;Enable MyFeature&quot; ON)  # option 定义布尔选项，通常用于启用或禁用功能</span><br><span class="line"></span><br><span class="line">install(TARGETS myapp DESTINATION bin)  # install 指定安装规则</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CMake 在父目录中执行 add_subdirectory() 时，CMake 会进入子目录 &lt;source_dir&gt;，并寻找子目录中的 CMakeLists.txt 文件</span></span><br><span class="line">add_subdirectory()</span><br><span class="line"></span><br><span class="line">CMAKE_SOURCE_DIR  # 项目源代码的根目录</span><br><span class="line">CMAKE_BINARY_DIR  # 构建目录</span><br><span class="line">CMAKE_CURRENT_SOURCE_DIR  # 当前 CMake 脚本所在目录。</span><br><span class="line">CMAKE_CURRENT_BINARY_DIR  # 当前 CMake 构建目录。</span><br><span class="line">CMAKE_CXX_COMPILER  # C++ 编译器。</span><br><span class="line">CMAKE_BUILD_TYPE  # 构建类型（如 Debug, Release）</span><br><span class="line"></span><br><span class="line">STREQUAL # STREQUAL 用于比较两个字符串是否相等，区分大小写</span><br><span class="line">EXISTS # 逻辑判断命令，用于检查某个文件或目录是否存在</span><br><span class="line"></span><br><span class="line">file</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file(&lt;operation&gt; &lt;arguments&gt;...)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file(READ <span class="string">&quot;&lt;file_path&gt;&quot;</span> &lt;variable_name&gt;) 读取文件内容，保存到变量</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file(TO_CMAKE_PATH) 将输入路径转换为 CMake 使用的标准路径格式</span></span><br><span class="line"></span><br><span class="line">enable_testing() # 启用 CTest 功能，CMake 脚本中使用 add_test() 来定义测试用例，并通过 ctest 命令执行测试。</span><br><span class="line"></span><br><span class="line">string() </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">string(&lt;COMMAND&gt; &lt;ARGUMENTS&gt;) 字符串处理函数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">string(CONCAT &lt;VAR&gt; &lt;STRING1&gt; &lt;STRING2&gt; ...)  将多个字符串连接成一个字符串，并将结果存储到变量</span></span><br><span class="line"></span><br><span class="line">add_custom_target # 运行命令，例如执行clang-tidy</span><br><span class="line">add_custom_target(format $&#123;BUSTUB_BUILD_SUPPORT_DIR&#125;/run_clang_format.py</span><br><span class="line">        $&#123;CLANG_FORMAT_BIN&#125;</span><br><span class="line">        $&#123;BUSTUB_BUILD_SUPPORT_DIR&#125;/clang_format_exclusions.txt</span><br><span class="line">        --source_dirs</span><br><span class="line">        $&#123;BUSTUB_FORMAT_DIRS&#125;</span><br><span class="line">        --fix</span><br><span class="line">        --quiet</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">gtest_discover_tests # gtest_discover_tests 是 CMake 中与gtest集成的测试自动发现和注册</span><br><span class="line"></span><br><span class="line">find_package(GTest REQUIRED)</span><br><span class="line"></span><br><span class="line">add_executable(my_test_target test_case1.cpp test_case2.cpp)  # 添加 Google Test 测试目标</span><br><span class="line">target_link_libraries(my_test_target GTest::GTest GTest::GMock)</span><br></pre></td></tr></table></figure><h4 id="bazel构建和包管理工具"><a href="#bazel构建和包管理工具" class="headerlink" title="bazel构建和包管理工具"></a>bazel构建和包管理工具</h4><p>Bazel 的构建过程通常由以下几个步骤组成：</p><ul><li>BUILD 文件：每个项目都有一个 <code>BUILD</code> 文件，定义了如何构建该项目。通过这个文件，Bazel 知道如何处理源代码、依赖项、编译步骤等。</li><li>目标（Target）：在 <code>BUILD</code> 文件中，你可以定义“目标”，例如编译一个库、一个可执行文件或一个测试。这些目标描述了项目的不同部分，Bazel 会根据目标来决定如何进行构建。</li><li>依赖关系：Bazel 会根据目标的依赖关系，构建出一个有向无环图（DAG），确保构建过程是有序的，并且只构建必要的部分。</li><li>增量构建：Bazel 会智能地检测哪些部分发生了变化，避免每次都从头开始构建。它通过文件哈希和时间戳来确定哪些目标需要重新构建。</li></ul><p>项目根目录下创建一个 <code>WORKSPACE</code> 文件，Bazel 会将其作为项目的工作空间标识。<br>src&#x2F;BUILD</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cc_binary</span>(</span><br><span class="line">    name = <span class="string">&quot;myapp&quot;</span>,</span><br><span class="line">    srcs = [<span class="string">&quot;main.cc&quot;</span>],</span><br><span class="line">    deps = [</span><br><span class="line">        <span class="string">&quot;:myheader&quot;</span>,  # 依赖其他目标（例如头文件或库）</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>src/main.cc</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, Bazel!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接执行bazel build &#x2F;&#x2F;src:myapp 编译</p><ol><li><code>//src:myapp</code>：表示从 <code>src</code> 目录中的 <code>BUILD</code> 文件中构建目标 <code>myapp</code>。</li><li><code>bazel build</code>：该命令会自动解析 <code>BUILD</code> 文件，并根据其中的规则来执行构建。</li></ol><p>目录结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/my-cpp-project</span><br><span class="line">  ├── BUILD            # Bazel 构建文件</span><br><span class="line">  ├── WORKSPACE        # Bazel 工作空间文件</span><br><span class="line">  ├── src/</span><br><span class="line">  │   ├── BUILD        # C++ 代码的 Bazel 构建文件</span><br><span class="line">  │   └── main.cc      # C++ 源文件</span><br><span class="line">  └── include/</span><br><span class="line">      └── myheader.h   # C++ 头文件</span><br></pre></td></tr></table></figure><p>目标匹配符</p><p>:当前包的所有规则<br>:all当前包的所有目标<br>…递归匹配所有子包</p><p>可以把bazel 和go mod对比</p><p>构建命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 构建单个目标</span><br><span class="line">bazel build //src/main:app</span><br><span class="line"></span><br><span class="line"># 构建当前目录下的所有目标</span><br><span class="line">bazel build :all</span><br><span class="line"></span><br><span class="line"># 构建包内的所有目标</span><br><span class="line">bazel build //src/main/...</span><br><span class="line"></span><br><span class="line"># 构建多个指定目标</span><br><span class="line">bazel build //src/main:app //tests:unit_tests</span><br><span class="line"></span><br><span class="line"># 构建整个工作区</span><br><span class="line">bazel build //...</span><br><span class="line"></span><br><span class="line"># 排除特定目标</span><br><span class="line">bazel build //... -- //experimental/...</span><br></pre></td></tr></table></figure><p>bazel的输出</p><p>目录名称用途<br>bazel-bin二进制文件（如 cc_binary）<br>bazel-genfiles生成的源代码（如协议缓冲区）<br>bazel-testlogs测试日志<br>bazel-out实际物理存储目录（被符号链接引用）</p><p>以googletest的bazel 为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"># Google Test including Google Mock</span><br><span class="line">cc_library(</span><br><span class="line">    name = &quot;gtest&quot;,</span><br><span class="line">    srcs = glob(</span><br><span class="line">        include = [</span><br><span class="line">            &quot;googletest/src/*.cc&quot;,</span><br><span class="line">            &quot;googletest/src/*.h&quot;,</span><br><span class="line">            &quot;googletest/include/gtest/**/*.h&quot;,</span><br><span class="line">            &quot;googlemock/src/*.cc&quot;,</span><br><span class="line">            &quot;googlemock/include/gmock/**/*.h&quot;,</span><br><span class="line">        ],</span><br><span class="line">        exclude = [</span><br><span class="line">            &quot;googletest/src/gtest-all.cc&quot;,</span><br><span class="line">            &quot;googletest/src/gtest_main.cc&quot;,</span><br><span class="line">            &quot;googlemock/src/gmock-all.cc&quot;,</span><br><span class="line">            &quot;googlemock/src/gmock_main.cc&quot;,</span><br><span class="line">        ],</span><br><span class="line">    ),</span><br><span class="line">    hdrs = glob([</span><br><span class="line">        &quot;googletest/include/gtest/*.h&quot;,</span><br><span class="line">        &quot;googlemock/include/gmock/*.h&quot;,</span><br><span class="line">    ]),</span><br><span class="line">    includes = [</span><br><span class="line">        &quot;googlemock&quot;,</span><br><span class="line">        &quot;googlemock/include&quot;,</span><br><span class="line">        &quot;googletest&quot;,</span><br><span class="line">        &quot;googletest/include&quot;,</span><br><span class="line">    ],</span><br><span class="line">    linkopts = select(&#123;</span><br><span class="line">        &quot;:qnx&quot;: [&quot;-lregex&quot;],</span><br><span class="line">        &quot;:openbsd&quot;: [</span><br><span class="line">            &quot;-lm&quot;,</span><br><span class="line">            &quot;-pthread&quot;,</span><br><span class="line">        ],</span><br><span class="line">        &quot;//conditions:default&quot;: [&quot;-pthread&quot;],</span><br><span class="line">    &#125;),</span><br><span class="line">    deps = select(&#123;</span><br><span class="line">        &quot;:has_absl&quot;: [</span><br><span class="line">            &quot;@abseil-cpp//absl/container:flat_hash_set&quot;,</span><br><span class="line">            &quot;@abseil-cpp//absl/debugging:failure_signal_handler&quot;,</span><br><span class="line">...</span><br><span class="line">        ],</span><br><span class="line">        &quot;//conditions:default&quot;: [],</span><br><span class="line">    &#125;) + select(&#123;</span><br><span class="line">        &quot;:fuchsia&quot;: [</span><br><span class="line">            &quot;@fuchsia_sdk//pkg/fdio&quot;,</span><br><span class="line">            &quot;@fuchsia_sdk//pkg/syslog&quot;,</span><br><span class="line">            &quot;@fuchsia_sdk//pkg/zx&quot;,</span><br><span class="line">        ],</span><br><span class="line">        &quot;//conditions:default&quot;: [],</span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cc_test(</span><br><span class="line">    name = &quot;gtest_samples&quot;,</span><br><span class="line">    size = &quot;small&quot;,</span><br><span class="line">    srcs = [</span><br><span class="line">        &quot;googletest/samples/sample1_unittest.cc&quot;,</span><br><span class="line">    ],</span><br><span class="line">    linkstatic = 0,</span><br><span class="line">    deps = [</span><br><span class="line">        &quot;gtest_sample_lib&quot;,</span><br><span class="line">        &quot;:gtest_main&quot;,</span><br><span class="line">    ],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>select</code> 函数根据特定条件（如是否启用 Abseil 库）选择不同的依赖项。</p><p>glob, 选中多个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glob(</span><br><span class="line">    include = [文件模式列表],</span><br><span class="line">    exclude = [排除模式列表],  # 可选</span><br><span class="line">    exclude_directories = 1,   # 默认排除目录（可选）</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>includes 命令的作用<br>编译当前包的.cpp文件时自动添加 <code>-I&lt;package_path&gt;/include</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">includes = [<span class="string">&quot;include&quot;</span>],      # 头文件搜索路径（相对于当前包）</span><br></pre></td></tr></table></figure><p>linkopts<br><code>linkopts</code> 用于指定 ​<strong>链接器选项</strong>​（Linker Flags），控制如何将目标文件、静态库或动态库链接成最终的可执行文件或共享库</p><p>MODULE.bazel 文件中的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bazel_dep(</span><br><span class="line">    name = <span class="string">&quot;abseil-cpp&quot;</span>,  <span class="comment"># 依赖名称</span></span><br><span class="line">    version = <span class="string">&quot;20250127.0&quot;</span>,  <span class="comment"># 版本号</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">bazel_dep(</span><br><span class="line">    name = <span class="string">&quot;platforms&quot;</span>,</span><br><span class="line">    version = <span class="string">&quot;0.0.10&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>通过 Bzlmod 直接从 Bazel 中央仓库（Bazel Central Registry, BCR）拉取依赖。</p><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>google 的gtest库是广泛使用的单元测试框架，本地mock可以使用gmock。</p><p>gmock只支持mock虚函数，这个比较坑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gmock/gmock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;data_service.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MockDataService</span> : <span class="keyword">public</span> DataService &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MOCK_METHOD</span>(<span class="type">int</span>, fetchData, (<span class="type">int</span> id), (<span class="type">const</span> <span class="keyword">override</span>));</span><br><span class="line">    <span class="built_in">MOCK_METHOD</span>(<span class="type">void</span>, saveData, (<span class="type">int</span> id, <span class="type">const</span> std::string&amp; data), (<span class="keyword">override</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// data_processor_test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;data_processor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;data_service_mock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> testing::Return;</span><br><span class="line"><span class="keyword">using</span> testing::_;</span><br><span class="line"><span class="keyword">using</span> testing::Throw;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(DataProcessorTest, ProcessHighValue) &#123;</span><br><span class="line">    MockDataService mock;</span><br><span class="line">    <span class="function">DataProcessor <span class="title">processor</span><span class="params">(&amp;mock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置期望：fetchData(42) 返回 200</span></span><br><span class="line">    <span class="built_in">EXPECT_CALL</span>(mock, <span class="built_in">fetchData</span>(<span class="number">42</span>))</span><br><span class="line">        .<span class="built_in">WillOnce</span>(<span class="built_in">Return</span>(<span class="number">200</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 期望 saveData 被调用一次，参数为 (42, &quot;high&quot;)</span></span><br><span class="line">    <span class="built_in">EXPECT_CALL</span>(mock, <span class="built_in">saveData</span>(<span class="number">42</span>, <span class="string">&quot;high&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用被测方法</span></span><br><span class="line">    <span class="type">int</span> result = processor.<span class="built_in">process</span>(<span class="number">42</span>);</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(result, <span class="number">400</span>); <span class="comment">// 200 * 2 = 400</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(DataProcessorTest, ProcessLowValue) &#123;</span><br><span class="line">    MockDataService mock;</span><br><span class="line">    <span class="function">DataProcessor <span class="title">processor</span><span class="params">(&amp;mock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置期望：fetchData(10) 返回 50</span></span><br><span class="line">    <span class="built_in">EXPECT_CALL</span>(mock, <span class="built_in">fetchData</span>(<span class="number">10</span>))</span><br><span class="line">        .<span class="built_in">WillOnce</span>(<span class="built_in">Return</span>(<span class="number">50</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 期望 saveData 被调用一次，参数为 (10, &quot;low&quot;)</span></span><br><span class="line">    <span class="built_in">EXPECT_CALL</span>(mock, <span class="built_in">saveData</span>(<span class="number">10</span>, <span class="string">&quot;low&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = processor.<span class="built_in">process</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(result, <span class="number">25</span>); <span class="comment">// 50 / 2 = 25</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>​**​ argv)</span> </span>&#123;</span><br><span class="line">    testing::<span class="built_in">InitGoogleMock</span>(&amp;argc, argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态检查和格式化"><a href="#静态检查和格式化" class="headerlink" title="静态检查和格式化"></a>静态检查和格式化</h4><p>Clang-Tidy 是一个基于 Clang 的 C++ 静态分析工具，用于执行代码检查、风格检测和代码优化。Clang-Tidy配置文件通常位于项目的根目录，名为 .clang-tidy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Checks:          &#x27;*, -clang-analyzer-*&#x27;</span><br><span class="line">WarningsAsErrors: &#x27;true&#x27;</span><br><span class="line">HeaderFilterRegex: &#x27;.*&#x27;</span><br><span class="line">FormatStyle:     file</span><br></pre></td></tr></table></figure><p>Clang-Format 用于格式化 C++ 代码，并且支持根据 .clang-format 配置文件自定义格式化规则。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clang-format -i &lt;your-file.cpp&gt;</span><br><span class="line"># 指定风格</span><br><span class="line">clang-format -i -style=google &lt;file&gt;</span><br></pre></td></tr></table></figure><p>Valgrind 内存动态检查工具，可以检查内存泄漏、内存泄漏，未初始化内存访问等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 检查内存泄漏</span><br><span class="line">valgrind --leak-check=full ./your_program</span><br></pre></td></tr></table></figure><h4 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h4><p>使用clangd实现自动补全，命令行安装<code>sudo apt-get install clangd-10</code></p><p>cmake启用CMAKE_EXPORT_COMPILE_COMMANDS，会在build目录生成compile_commands.json 文件</p><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>编码使用的printf 也是一种简单的日志调试，根据输出看预期是否正确。C++日志库也可以选择google的glog。</p><h4 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h4><p>gdb调试普通程序，需要对普通程序编译加-g选项，也就是debug编译。</p><p>gdb调试命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># 运行调试器</span><br><span class="line">run</span><br><span class="line">run arg1 arg2</span><br><span class="line"></span><br><span class="line"># 设置断点</span><br><span class="line">break main</span><br><span class="line">break 10</span><br><span class="line">break 10</span><br><span class="line">break 10 if x == 5  # 条件断点</span><br><span class="line"></span><br><span class="line"># 删除断点</span><br><span class="line">delete</span><br><span class="line">delete 1</span><br><span class="line"></span><br><span class="line"># 显示断点</span><br><span class="line">info breakpoints</span><br><span class="line">info breakpoint 1</span><br><span class="line"></span><br><span class="line"># 启用和关闭断点</span><br><span class="line">enable 2</span><br><span class="line">disable 2</span><br><span class="line"></span><br><span class="line"># 断点继续执行</span><br><span class="line">continue</span><br><span class="line"></span><br><span class="line"># 单步执行</span><br><span class="line">step  # 进入函数内部执行</span><br><span class="line">next  # 会跳过函数调用</span><br><span class="line">finish  # 运行直到当前函数执行结束</span><br><span class="line"></span><br><span class="line"># 查看线程堆栈</span><br><span class="line">backtrace</span><br><span class="line">frame 1  # 切换栈</span><br><span class="line">up  # 切换到当前栈帧的上一层，即父函数的栈帧</span><br><span class="line">down  # 切换到当前栈帧的下一层，即子函数的栈帧</span><br><span class="line"></span><br><span class="line"># 查看变量值</span><br><span class="line">print x</span><br><span class="line">print my_struct.field</span><br><span class="line">print my_array[2]</span><br><span class="line"></span><br><span class="line"># 修改变量值</span><br><span class="line">set variable x = 10</span><br><span class="line"></span><br><span class="line"># 查看指定内存地址内容</span><br><span class="line">x/4xw &amp;x</span><br></pre></td></tr></table></figure><p>gdb多线程调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 显示线程</span><br><span class="line">info threads</span><br><span class="line"></span><br><span class="line"># 切换线程</span><br><span class="line">thread 2</span><br><span class="line"></span><br><span class="line"># 查看线程栈</span><br><span class="line">backtrace</span><br><span class="line"></span><br><span class="line"># 打印所有线程堆栈</span><br><span class="line">thread apply all backtrace</span><br><span class="line"></span><br><span class="line"># 打印所有线程堆栈到文件</span><br><span class="line">set logging on</span><br><span class="line">set logging file &lt;filename&gt;  # 执行这两行命令，后面gdb会把结果输出到文件</span><br><span class="line">info threads</span><br><span class="line">thread apply all backtrace</span><br></pre></td></tr></table></figure><p>对于release 编译的调试，需要等进程运行产生core后，结合core对二进制文件进行调试。调试命令<code>gdb &lt;二进制文件&gt; &lt;core_file&gt;</code>，core文件和二进制文件必须对应，一般来说需要保证core是调试的二进制文件生成的。</p><p>配置linux系统生成core文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c</span><br><span class="line">ulimit -c unlimited</span><br><span class="line"># 设置将 core 文件保存在 /tmp/ 目录，并包括程序的名称 (%e) 和进程 ID (%p) 作为文件名。</span><br><span class="line">echo &quot;/tmp/core.%e.%p&quot; &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><p>core文件的调试只能查看进程崩溃时的状态，以下是主要使用的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 查看进程崩溃时的函数调用栈</span><br><span class="line">backtrace</span><br><span class="line">// 查看当前线程的栈帧和寄存器状态</span><br><span class="line">info locals</span><br><span class="line">info registers</span><br><span class="line"></span><br><span class="line"># 打印所有线程堆栈到文件</span><br><span class="line">set logging on</span><br><span class="line">set logging file &lt;filename&gt;  # 执行这两行命令，后面gdb会把结果输出到文件</span><br><span class="line">info threads</span><br><span class="line">thread apply all backtrace</span><br></pre></td></tr></table></figure><p>gdb 可以通过<code>gdb attach pid</code>附加到进程，执行命令后，gdb会附加到目标进程，并暂停目标进程的执行，不要在线上使用！</p><h4 id="性能排查工具"><a href="#性能排查工具" class="headerlink" title="性能排查工具"></a>性能排查工具</h4><p>性能排查tips</p><ol><li>首先看cpu和磁盘利用率（或者磁盘吞吐&#x2F;iops），是否到瓶颈。也就是硬件到瓶颈</li><li>如果1没有到，说明是软件栈瓶颈。需要看用户程序瓶颈还是内核。</li><li>可以使用perf 直接观察软件栈，可以打印火焰图，也可以perf top -p 查看线程情况</li><li>可以用strace 查看系统调用的延迟，判断内核是不是有瓶颈</li><li>如果程序里有链路 trace，可以直接通过 trace 看程序那部分耗时大</li><li>确认出问题的线程后，可以用 pstack 打印线程栈帧，看是否一直出现wait 相关的栈</li></ol><p>pstack 打印正在运行进程的堆栈信息，strace打印系统调用信息。多次执行pstack 可以看潜在的用户程序瓶颈（如有无wait调用栈），执行strace可以借助系统调用查看内核是否到瓶颈。</p><p>perf 是linux内核提供的强大性能排查工具。</p><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><h4 id="JAVA编译和运行"><a href="#JAVA编译和运行" class="headerlink" title="JAVA编译和运行"></a>JAVA编译和运行</h4><p>Java编译是将.java 文件转换为字节码（.class 文件），字节码并不是cpu可执行的汇编机器码，平台无关。编译使用java提供的编译器javac执行。</p><p>编译后，每个java文件都会产生一个.class文件，类似C++的.o文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 编译.java文件</span><br><span class="line">javac HelloWorld.java</span><br><span class="line">javac Class1.java Class2.java</span><br><span class="line">javac *.java</span><br><span class="line"></span><br><span class="line"># -classpath指定编译查找的类路径。</span><br><span class="line">javac -classpath /path/to/library.jar MyProgram.java</span><br><span class="line">javac -classpath /path/to/library1.jar:/path/to/library2.jar MyProgram.java</span><br><span class="line"></span><br><span class="line"># -d 指定编译输出.class 文件的目录</span><br><span class="line">javac -d bin MyProgram.java</span><br><span class="line"></span><br><span class="line"># -g添加调试信息</span><br><span class="line">javac -g MyProgram.java</span><br></pre></td></tr></table></figure><p>运行.class文件，只需要显示运行携带main方法的类，相关的类会自动被加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 不需要加.class后缀</span><br><span class="line">java HelloWorld</span><br></pre></td></tr></table></figure><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>jdb是java提供的调试工具, jdb比较反人类的是，它的命令没有简写，例如next不能写作n, cont不能写作c, 以及反人类的命令stop at MyProgram:10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># 开始运行</span><br><span class="line">run </span><br><span class="line"># 查看帮助信息</span><br><span class="line">help</span><br><span class="line"></span><br><span class="line"># 设置断点</span><br><span class="line">stop at MyProgram:10</span><br><span class="line">stop in MyProgram.myMethod</span><br><span class="line"></span><br><span class="line">Usage: stop at &lt;class&gt;:&lt;line_number&gt; or</span><br><span class="line">       stop in &lt;class&gt;.&lt;method_name&gt;[(argument_type,...)]</span><br><span class="line"></span><br><span class="line"># 查看断点（没错clear是查看断点）</span><br><span class="line">clear</span><br><span class="line"># 删除某个断点，不支持删除全部断点。</span><br><span class="line">clear MyProgram:10  </span><br><span class="line"></span><br><span class="line"># 断点继续运行</span><br><span class="line">cont</span><br><span class="line"></span><br><span class="line"># 单步执行</span><br><span class="line">next</span><br><span class="line">step</span><br><span class="line"></span><br><span class="line"># 返回到上层调用，类似gdb的finish</span><br><span class="line">step up</span><br><span class="line"></span><br><span class="line">list # 显示旁边代码</span><br><span class="line"></span><br><span class="line"># 查看变量</span><br><span class="line">print variableName</span><br><span class="line">print objectInstance.memberVariable</span><br><span class="line"></span><br><span class="line"># 查看线程信息</span><br><span class="line">thread  # 当前线程信息</span><br><span class="line">thread 1  # 1号线程信息</span><br><span class="line"># 暂停和恢复某线程的运行</span><br><span class="line">suspend [thread id(s)]</span><br><span class="line">resume [thread id(s)] </span><br><span class="line"></span><br><span class="line"># 查看线程的栈帧</span><br><span class="line">where  # 当前线程信息</span><br><span class="line">where 2</span><br><span class="line"></span><br><span class="line"># 查看class和method信息</span><br><span class="line">class &lt;className&gt;</span><br><span class="line">method &lt;&gt;</span><br></pre></td></tr></table></figure><p>调试正在运行的进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 列出正在运行的java进程</span><br><span class="line">jps -l</span><br><span class="line"></span><br><span class="line"># 连接正在运行的进程</span><br><span class="line">jdb -attach &lt;pid&gt;</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>JUnit 是最常用的 Java 单元测试框架，使用注解 @Test 来标记测试方法，以及 @Before 和 @After 来标记测试前后的初始化和清理方法。</p><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><h4 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 编译单个文件</span><br><span class="line">go build main.go</span><br><span class="line"></span><br><span class="line"># 编译整个包</span><br><span class="line">go build</span><br><span class="line"></span><br><span class="line"># 编译参数, -gcflags</span><br><span class="line">go build -gcflags &quot;-N&quot; main.go</span><br><span class="line"></span><br><span class="line">-N  # 禁用优化</span><br><span class="line">-l  # 禁用内联优化</span><br><span class="line">-l -N  # 禁用优化和内联</span><br><span class="line">-m  # 输出优化决策信息</span><br><span class="line">-d  # 增加调试信息</span><br></pre></td></tr></table></figure><h4 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h4><p>golang推荐使用Delve 进行调试，安装<code>go install github.com/go-delve/delve/cmd/dlv@latest</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># 调试单个文件</span><br><span class="line">dlv debug main.go</span><br><span class="line"># 调试某个目录</span><br><span class="line">dlv debug</span><br><span class="line"></span><br><span class="line"># 设置断点</span><br><span class="line">break b</span><br><span class="line">b main.go:10</span><br><span class="line"># 显示已经设置的断点</span><br><span class="line">breakpoints (alias: bp)</span><br><span class="line"></span><br><span class="line"># 栈帧移动</span><br><span class="line">down ------------------------ Move the current frame down.</span><br><span class="line">up -------------------------- Move the current frame up.</span><br><span class="line"></span><br><span class="line"># 继续运行直到下一个断点</span><br><span class="line">continue c</span><br><span class="line"></span><br><span class="line"># 单步执行</span><br><span class="line">next  n# 单步执行，跳过函数调用</span><br><span class="line">step  s# 单步进入函数内部</span><br><span class="line"></span><br><span class="line"># 打印变量值</span><br><span class="line">print p</span><br><span class="line">p x</span><br><span class="line"></span><br><span class="line"># 显示当前代码行及上下文</span><br><span class="line">list 或 ls</span><br><span class="line"></span><br><span class="line">goroutine ------------------- Shows or changes current goroutine</span><br><span class="line">goroutines# 查看当前所有 Goroutines</span><br><span class="line"># 查看goroutine堆栈</span><br><span class="line">stack &lt;goroutine_id&gt;</span><br><span class="line"></span><br><span class="line">threads显示所有线程信息</span><br><span class="line">thread (alias: tr) ---------- Switch to the specified thread.</span><br></pre></td></tr></table></figure><h4 id="静态代码检查"><a href="#静态代码检查" class="headerlink" title="静态代码检查"></a>静态代码检查</h4><p>gopls，通常会随 Go 扩展自动安装。可以和vscode结合配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 静态检查</span><br><span class="line">gopls check &lt;path-to-your-directory-or-file&gt;</span><br><span class="line"># 格式化代码</span><br><span class="line">gopls format &lt;path-to-your-file&gt;</span><br><span class="line"># 代码补全</span><br><span class="line">gopls completion &lt;path-to-your-file&gt;:&lt;line&gt;:&lt;column&gt;</span><br><span class="line"></span><br><span class="line"># 跳转到函数定义</span><br><span class="line">gopls definition &lt;path-to-your-file&gt;:&lt;line&gt;:&lt;column&gt;</span><br><span class="line"># 跳转到引用</span><br><span class="line">gopls references &lt;path-to-your-file&gt;:&lt;line&gt;:&lt;column&gt;</span><br></pre></td></tr></table></figure><h4 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h4><p>Go 自带的测试框架（testing 包）支持单元测试和性能测试。测试文件以 _test.go 结尾, 测试函数必须以 Test 开头，后面跟随测试的函数名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 运行测试</span><br><span class="line">go test</span><br><span class="line">go test -run TestAdd  # 只运行特定的测试函数</span><br><span class="line">go test -cover  # 查看覆盖率</span><br><span class="line"></span><br><span class="line"># 调试测试</span><br><span class="line">dlv test</span><br><span class="line"></span><br><span class="line"># 调试单个测试</span><br><span class="line">dlv test -- -test.run TestFunctionName</span><br></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><h4 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h4><p>Python 会将源代码编译为一种字节码（Bytecode），存储为 .pyc 文件（位于 <code>__pycache__</code> 文件夹）。字节码会被 Python 虚拟机（PVM，Python Virtual Machine）翻译为底层的机器指令执行。</p><p>相比java通常把字节码打包成jar，后续由jvm执行; python一般直接保留源代码，python虚拟机直接执行源代码。python编译过程也不会进行类型检查，编译器优化行为少。</p><p>python语法比较灵活，表达式函数可以在全局执行，执行实现先于main模块。</p><h4 id="调试-2"><a href="#调试-2" class="headerlink" title="调试"></a>调试</h4><p>python -m pdb your_program.py 启用pdb调试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">单步运行</span></span><br><span class="line">n next  # n</span><br><span class="line">s step  # 进入当前行中的函数调用，逐步执行</span><br><span class="line">c continue  # 继续执行程序，直到下一个断点</span><br><span class="line">r return  # 运行到当前函数完毕</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清理断点</span></span><br><span class="line">clear</span><br><span class="line">clear filename:lineno  # 删除某行所有断点</span><br><span class="line">clear number  # 删除编号断点</span><br><span class="line"></span><br><span class="line">enable bpnumber # 启动和关闭断点</span><br><span class="line">disable bpnumber </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印变量值或表达式</span></span><br><span class="line">p &lt;expression&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出当前行附近的代码</span></span><br><span class="line">l (list)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置断点</span></span><br><span class="line">b  break # 显示已经设置的断点</span><br><span class="line">b &lt;line_number&gt;</span><br><span class="line">b 12</span><br><span class="line">b add</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示当前的调用栈</span></span><br><span class="line">w (where) </span><br><span class="line">up  # 切换到调用栈的上一层（即父函数）</span><br><span class="line">down  # 切换到调用栈的下一层（即子函数）</span><br><span class="line"></span><br><span class="line">&lt;expression&gt;  # 执行表达式，可以修改变量</span><br><span class="line">a = 10</span><br></pre></td></tr></table></figure><h4 id="静态检查"><a href="#静态检查" class="headerlink" title="静态检查"></a>静态检查</h4><p>pylint 工具检查代码，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pylint &lt;your-python-file.py&gt;</span><br><span class="line">pylint &lt;your-project-folder&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成pylint的静态检查规则</span></span><br><span class="line">pylint --generate-rcfile &gt; .pylintrc</span><br></pre></td></tr></table></figure><p>pylint不支持自动格式化，Black可以用来做python自动化代码格式化工具</p><h4 id="单元测试-2"><a href="#单元测试-2" class="headerlink" title="单元测试"></a>单元测试</h4><p>unittest 库，导入待测试的模块，对需要测试的模块进行单元测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">import</span> math_utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestMathUtils</span>(unittest.TestCase):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_add</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 测试 add 函数</span></span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(math_utils.add(<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>)</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(math_utils.add(-<span class="number">1</span>, <span class="number">1</span>), <span class="number">0</span>)</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(math_utils.add(<span class="number">0</span>, <span class="number">0</span>), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_subtract</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 测试 subtract 函数</span></span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(math_utils.subtract(<span class="number">10</span>, <span class="number">5</span>), <span class="number">5</span>)</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(math_utils.subtract(<span class="number">0</span>, <span class="number">1</span>), -<span class="number">1</span>)</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(math_utils.subtract(<span class="number">100</span>, <span class="number">50</span>), <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><h4 id="日志-1"><a href="#日志-1" class="headerlink" title="日志"></a>日志</h4><p>配置日志处理器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建日志器</span></span><br><span class="line">logger = logging.getLogger(<span class="string">&quot;my_logger&quot;</span>)</span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建控制台处理器</span></span><br><span class="line">console_handler = logging.StreamHandler()</span><br><span class="line">console_handler.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件处理器</span></span><br><span class="line">file_handler = logging.FileHandler(<span class="string">&quot;app.log&quot;</span>)</span><br><span class="line">file_handler.setLevel(logging.WARNING)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义日志格式</span></span><br><span class="line">formatter = logging.Formatter(<span class="string">&quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;</span>)</span><br><span class="line">console_handler.setFormatter(formatter)</span><br><span class="line">file_handler.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加处理器到日志器</span></span><br><span class="line">logger.addHandler(console_handler)</span><br><span class="line">logger.addHandler(file_handler)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试日志</span></span><br><span class="line">logger.debug(<span class="string">&quot;这是一条调试日志&quot;</span>)</span><br><span class="line">logger.info(<span class="string">&quot;这是一条一般信息日志&quot;</span>)</span><br><span class="line">logger.warning(<span class="string">&quot;这是一条警告日志&quot;</span>)</span><br><span class="line">logger.error(<span class="string">&quot;这是一条错误日志&quot;</span>)</span><br><span class="line">logger.critical(<span class="string">&quot;这是一条严重错误日志&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> base </category>
          
      </categories>
      
      
        <tags>
            
            <tag> language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程语言(5)—文件IO和网络库</title>
      <link href="/2024/12/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(5)%E2%80%94%E6%96%87%E4%BB%B6IO%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%93/"/>
      <url>/2024/12/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(5)%E2%80%94%E6%96%87%E4%BB%B6IO%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>linux系统的文件接口是十分重要的抽象, 也就是“一切都是文件”。借助文件IO，用户程序可以读写磁盘设备、网络设备、甚至管道、内存等。</p><span id="more"></span><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><p>首先介绍linux 系统调用提供的文件io</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开文件, 返回文件描述符。文件描述符是进程持有打开文件指针序列的索引, 通过文件描述符进程可以访问进程文件结构， 进程文件结构记录文件的Inode，以及进程当前读写文件的偏移等信息</span></span><br><span class="line"><span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> bytes = <span class="built_in">read</span>(fd, buf, <span class="built_in">sizeof</span>(buf))  <span class="comment">// 从文件描述符读取数据到buf</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> bytes = <span class="built_in">write</span>(fd, buf, <span class="built_in">sizeof</span>(buf))  <span class="comment">// 将buf写入到文件描述符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> offset = <span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_END);  <span class="comment">// 调整文件读写偏移量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存映射文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;data.bin&quot;</span>, O_RDWR);</span><br><span class="line"><span class="type">void</span>* addr = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, file_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 直接操作 addr 指针读写文件</span></span><br><span class="line"><span class="built_in">munmap</span>(addr, file_size);</span><br></pre></td></tr></table></figure><p>C语言的文件IO位于stdio.h库，stdio默认启用用户态缓冲区（可通过 setvbuf 调整），可以减少系统调用次数，提升小文件效率。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IO_FILE</span> FILE;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_IO_FILE</span> &#123;</span><br><span class="line">  <span class="type">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span></span>;  <span class="comment">// 打开文件, 获得文件句柄</span></span><br><span class="line"><span class="comment">// mode·</span></span><br><span class="line"><span class="comment">// &quot;r&quot;：以只读方式打开文件，文件必须存在。</span></span><br><span class="line"><span class="comment">// &quot;w&quot;：以只写方式打开文件，如果文件已存在，会清空文件内容；如果文件不存在，会创建新文件。</span></span><br><span class="line"><span class="comment">// &quot;a&quot;：以追加模式打开文件，数据写入到文件末尾，文件不存在时会创建。</span></span><br><span class="line"><span class="comment">// &quot;r+&quot;：以读写模式打开文件，文件必须存在。</span></span><br><span class="line"><span class="comment">// &quot;w+&quot;：以读写模式打开文件，文件不存在时会创建，已存在时会清空文件内容。</span></span><br><span class="line"><span class="comment">// &quot;a+&quot;：以读写模式打开文件，数据写入文件末尾，文件不存在时会创建。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span>;  <span class="comment">// 关闭文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fgetc</span><span class="params">(FILE *stream)</span>  <span class="comment">// 读取文件, 从文件中读取一个字符。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fgets</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> num, FILE *stream)</span>  <span class="comment">// 从文件中读取一行，最多读取 num-1 个字符。</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从文件中读取多个ptr对象（如结构体、数组等），每个对象大小为 size，读取 count 个对象。</span></span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *stream)</span></span>;</span><br><span class="line"><span class="type">int</span> numbers[<span class="number">5</span>];</span><br><span class="line"><span class="type">size_t</span> n = <span class="built_in">fread</span>(numbers, <span class="built_in">sizeof</span>(<span class="type">int</span>), <span class="number">5</span>, file);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fputc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>  <span class="comment">// 将字符 c 写入文件流</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, FILE *stream)</span>  <span class="comment">// 将字符串 str 写入文件，自动加上字符串的结束符 \0</span></span></span><br><span class="line"><span class="function"><span class="comment">// 写入多个对象到文件，每个对象大小为 size，写入 count 个对象。</span></span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *stream)</span></span>;</span><br><span class="line"><span class="type">int</span> numbers[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">size_t</span> n = <span class="built_in">fwrite</span>(numbers, <span class="built_in">sizeof</span>(<span class="type">int</span>), <span class="number">5</span>, file);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件定位</span></span><br><span class="line"><span class="comment">// 设置文件指针的位置。offset 是偏移量，whence 是参考位置。</span></span><br><span class="line"><span class="comment">// SEEK_SET：从文件开头开始偏移。</span></span><br><span class="line"><span class="comment">// SEEK_CUR：从当前位置开始偏移</span></span><br><span class="line"><span class="comment">// SEEK_END：从文件末尾开始偏移</span></span><br><span class="line"><span class="built_in">fseek</span>(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)：</span><br><span class="line"></span><br><span class="line"><span class="built_in">ftell</span>(FILE *stream)  <span class="comment">// 获取当前文件指针的位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">feof</span><span class="params">(FILE *stream)</span></span>;  <span class="comment">// 检查文件是否已读到末尾</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准输入输出</span></span><br><span class="line"><span class="comment">// %d：输出10进制整数; %f：输出浮点数; %s：输出字符串; %c：输出字符;%x：输出十六进制整数。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a); </span><br><span class="line"></span><br><span class="line"><span class="built_in">getchar</span>()  <span class="comment">// 从标准输入读取一个字符。</span></span><br><span class="line"><span class="built_in">putchar</span>() <span class="comment">// 将一个字符输出到标准输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;  <span class="comment">// 从文件中按指定的格式读取数据，并将读取的数据存储到变量。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>; <span class="comment">// fprintf() 向文件中写入格式化的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sprintf() 将格式化的数据写入字符串。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="built_in">sprintf</span>(buffer, <span class="string">&quot;Number: %d, Pi: %.2f&quot;</span>, num, pi);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sscanf() 函数用于从字符串中按指定格式读取数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>linu网络socket系统调用</p><ol><li>服务端，绑定（bind）到指定端口。监听（listen）端口，等待客户端连接。接受（accept）客户端的连接请求。进行数据通信（send，recv, read, write），关闭 Socket（close）。</li><li>客户端，创建 Socket。连接（connect）到服务器端。发送和接收数据。关闭 Socket。</li></ol><p>三次握手之前, 服务端和客户端分别阻塞在accept和connect，三次握手建立连接后, 向下执行。三次握手过程</p><ol><li>客户端发送SYN报文（SYN&#x3D;1，序列号seq&#x3D;x）, 客户端进入 SYN_SENT 状态</li><li>服务器回复SYN-ACK报文（SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，序列号seq&#x3D;y）, 服务器进入 SYN_RCVD 状态。客户端请求加入到SYN队列, 由net.ipv4.tcp_max_syn_backlog控制</li><li>客户端发送ACK报文（ACK&#x3D;1，确认号ack&#x3D;y+1，序列号seq&#x3D;x+1）。客户端进入 ESTABLISHED 状态。服务器收到后也进入 ESTABLISHED 状态。请求进入ESTABLISHED队列，大小由net.core.somaxconn控制。<br>使用三次握手, 服务端可以控制连接的流控，例如服务端能力不足时，可以通过减缓发送SYN-ACK的频率，减少连接创建。同时双方都可以确定对方接受和发送连接正常。</li></ol><p>close()函数, 释放套接字文件描述符（File Descriptor），减少其引用计数。当引用计数归零时，触发 TCP 连接的关闭流程（发送 FIN 包，进入四次挥手阶段），主动关闭双向连接。TCP四次回收关闭</p><ol><li>主动方发送FIN报文（FIN&#x3D;1，序列号seq&#x3D;u）, 主动方从 ESTABLISHED 进入 FIN_WAIT_1 状态。此时不再发送数据，但可接收数据</li><li>被动方回复ACK报文（ACK&#x3D;1，确认号ack&#x3D;u+1，序列号seq&#x3D;v）, 被动方进入 CLOSE_WAIT 状态，主动方收到后进入 FIN_WAIT_2 状态。此时被动方还可以发送数据</li><li>被动方数据发送完毕后，发送FIN报文（FIN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;u+1，序列号seq&#x3D;w），被动方进入 LAST_ACK 状态。</li><li>主动方发送ACK报文（ACK&#x3D;1，确认号ack&#x3D;w+1，序列号seq&#x3D;u+1）, 主动方进入 TIME_WAIT 状态，等待 ​​2MSL​​（最长报文段寿命，MSL在 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_fin_timeout配置, 默认60s）后关闭。被动方收到后进入 CLOSED 状态。</li></ol><p>shutdown()，主动关闭套接字的 ​​单向或双向​​ 通信通道，立即触发 TCP 协议栈的关闭流程, 不影响文件描述符。shutdown支持允许半关闭，即只关闭一端网络</p><ol><li>shutdown(SHUT_WR), 关闭发送端, 触发两次挥手。主动方发送 FIN → 进入 FIN_WAIT_1, 被动方回复 ACK → 主动方进入 FIN_WAIT_2，被动方进入 CLOSE_WAIT。被动方需调用 close() 或 shutdown() 关闭连接，才会发送 FIN，触发完整四次挥手。若被动方不关闭，主动方会停留在 FIN_WAIT_2，直到内核超时（默认约 60 秒）</li><li>shutdown(SHUT_RD)，关闭接收端, 丢弃接收缓冲区的数据，不再读取新数据。​不发送任何报文​​，因此不会触发挥手流程。对方可能继续发送数据，但会被本地内核丢弃（无 RST 或 ACK 回应）。</li><li>shutdown(SHUT_RDWR), 触发完整四次挥手。</li></ol><p>服务端大量TIME_WAIT链接，在高并发短连接的TCP服务器上，服务器处理完请求后往往选择立刻主动正常关闭连接。或者当 connection 头部取值被设置为 close 时，基本都由「服务端」发起主动关闭连接。</p><ol><li>处理办法，在HTTP 请求的头部，connection 设置为 keep-alive，保持存活一段时间：现在的浏览器，一般都这么设置</li><li>缩短timewait时间为1MSL</li><li>如果是客户端主动关闭导致的TIMEWAIT（例如爬虫程序访问完请求立刻关闭连接），那可能导致客户端端口耗尽，可以开启net.ipv4.tcp_tw_reuse允许客户端新建连接复用timewait的链接。通过net.ipv4.ip_local_port_range扩大客户端使用端口的范围。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// how的取值</span></span><br><span class="line"><span class="comment">// SHUT_RD关闭接收端，丢弃未读数据。</span></span><br><span class="line"><span class="comment">// SHUT_WR关闭发送端，发送 FIN 包。</span></span><br><span class="line"><span class="comment">// SHUT_RDWR同时关闭读和写。</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建socket</span></span><br><span class="line"><span class="comment">// domain：指定协议族，常用的有：</span></span><br><span class="line"><span class="comment">// AF_INET：IPv4协议。</span></span><br><span class="line"><span class="comment">// AF_INET6：IPv6协议。</span></span><br><span class="line"><span class="comment">// AF_UNIX：Unix 域协议，用于同一机器上的进程间通信。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// type：指定套接字类型，常见的有：</span></span><br><span class="line"><span class="comment">// SOCK_STREAM：面向连接的流式套接字，通常用于 TCP。</span></span><br><span class="line"><span class="comment">// SOCK_DGRAM：数据报套接字，通常用于 UDP。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// protocol：指定协议，通常为 0，表示由操作系统自动选择合适的协议。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind() 用于将套接字与本地IP 地址和端口号绑定。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 绑定到任意IP地址</span></span><br><span class="line">server_addr.sin_port = <span class="built_in">htons</span>(PORT);        <span class="comment">// 设置端口号</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;Bind failed&quot;</span>);</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// backlog：等待连接队列的最大长度，表示操作系统在拒绝新连接之前，最多允许排队的连接请求数。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// accept() 用于接受一个传入的连接请求。该函数会阻塞，直到有客户端连接。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// connect() 用于客户端请求与服务器建立连接</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从socket fd获得数据</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"><span class="comment">// 向socket fd发送数据</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭一个打开的套接字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">// shutdown() 可用于关闭连接的一部分（如读或写）</span></span><br><span class="line"><span class="comment">// how：关闭方式，可能的值有：SHUT_RD：关闭读取。SHUT_WR：关闭写入。SHUT_RDWR：关闭读取和写入。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>C++ 文件IO库, 主要是</p><ol><li>ifstream：用于从文件中读取数据。</li><li>ofstream：用于向文件中写入数据。</li><li>fstream：用于同时从文件中读取和写入数据。</li><li>iostream：用于输入输出流。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可用文件流类的构造函数或者 open() 方法来打开文件。mode可以选择</span></span><br><span class="line"><span class="comment">// ios::in：以读取模式打开文件（默认）。</span></span><br><span class="line"><span class="comment">// ios::out：以写入模式打开文件。</span></span><br><span class="line"><span class="comment">// ios::app：以追加模式打开文件（写入内容会被追加到文件末尾）。</span></span><br><span class="line"><span class="comment">// ios::binary：以二进制模式打开文件。</span></span><br><span class="line"><span class="comment">// ios::trunc：如果文件已经存在，截断文件为零长度</span></span><br><span class="line"><span class="function">std::ofstream <span class="title">outfile</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>, std::ios::out | std::ios::trunc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查文件流状态</span></span><br><span class="line"><span class="built_in">is_open</span>()  <span class="comment">// 检查文件是否成功打开。</span></span><br><span class="line"><span class="built_in">eof</span>()  <span class="comment">// 检查是否已经到达文件末尾。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件指针定位</span></span><br><span class="line"><span class="built_in">seekg</span>(offset, direction)  <span class="comment">// 设置读取位置。</span></span><br><span class="line"><span class="built_in">seekp</span>(offset, direction)  <span class="comment">// 设置写入位置。</span></span><br><span class="line"><span class="built_in">tellg</span>()  <span class="comment">// 返回当前读取位置。</span></span><br><span class="line"><span class="built_in">tellp</span>()  <span class="comment">// 返回当前写入位置</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!infile) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open file.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(infile, line)) &#123;</span><br><span class="line">        std::cout &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    infile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line">fout &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">3.14</span>;  <span class="comment">// 涉及类型转换和格式化</span></span><br></pre></td></tr></table></figure></li></ol><p>C++ 的 I&#x2F;O 流（如 &lt;&lt; 和 &gt;&gt; 运算符）需要处理数据类型转换、格式化和错误检查，导致多次虚函数调用和条件判断。每次 I&#x2F;O 操作会检查流的状态（如 fail()、eof()），增加分支判断。一般要避免使用（包括cout和cin）</p><p>优化C++流的方案</p><ol><li>使用二进制模式​, 避免文本解析开销。std::ofstream fout(“data.bin”, std::ios::binary);</li><li>关闭与 C 标准库的同步，提升流操作速度。<code>std::ios::sync_with_stdio(false); // 关闭与 stdio 的同步</code></li></ol><p>不建议使用C++的流，除了C语言的stdio，C++常用的流还有protobuf。protobuf 支持ZeroCopy流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/io/zero_copy_stream_impl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 ZeroCopyOutputStream（如写入文件）</span></span><br><span class="line"><span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;data.bin&quot;</span>, O_WRONLY);</span><br><span class="line">google::protobuf::<span class="function">io::FileOutputStream <span class="title">file_stream</span><span class="params">(fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接序列化到文件流，无中间拷贝</span></span><br><span class="line">MyMessage msg;</span><br><span class="line">msg.<span class="built_in">set_bytes_data</span>(<span class="string">&quot;large_data&quot;</span>); <span class="comment">// 假设是大块数据</span></span><br><span class="line">msg.<span class="built_in">SerializeToZeroCopyStream</span>(&amp;file_stream);</span><br></pre></td></tr></table></figure><p>自定义高效流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedMemoryInputStream</span> : <span class="keyword">public</span> google::protobuf::io::ZeroCopyInputStream &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SharedMemoryInputStream</span>(<span class="type">void</span>* shared_mem, <span class="type">int</span> size) </span><br><span class="line">        : <span class="built_in">ptr_</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(shared_mem)), <span class="built_in">size_</span>(size), <span class="built_in">position_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Next</span><span class="params">(<span class="type">const</span> <span class="type">void</span>** data, <span class="type">int</span>* size)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position_ &gt;= size_) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        *data = ptr_ + position_;</span><br><span class="line">        *size = size_ - position_;</span><br><span class="line">        position_ = size_;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BackUp</span><span class="params">(<span class="type">int</span> count)</span> <span class="keyword">override</span> </span>&#123; position_ -= count; &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Skip</span><span class="params">(<span class="type">int</span> count)</span> <span class="keyword">override</span> </span>&#123; position_ += count; <span class="keyword">return</span> position_ &lt;= size_; &#125;</span><br><span class="line">    <span class="function">int64 <span class="title">ByteCount</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> position_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span>* ptr_;</span><br><span class="line">    <span class="type">int</span> size_;</span><br><span class="line">    <span class="type">int</span> position_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义流解析数据</span></span><br><span class="line"><span class="type">void</span>* shared_mem = ...; <span class="comment">// 共享内存地址</span></span><br><span class="line"><span class="type">int</span> mem_size = ...;</span><br><span class="line"><span class="function">SharedMemoryInputStream <span class="title">stream</span><span class="params">(shared_mem, mem_size)</span></span>;</span><br><span class="line">MyMessage msg;</span><br><span class="line">msg.<span class="built_in">ParseFromZeroCopyStream</span>(&amp;stream);</span><br></pre></td></tr></table></figure><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><h4 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h4><p>JAVA文件流分为两种主要类型：字节流和字符流。</p><ol><li>字节流用于处理所有二进制文件</li><li>字符流则专门用于处理字符&#x2F;文本文件</li></ol><p>字节流FileInputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制图片（字节流）</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.jpg&quot;</span>);</span><br><span class="line">     <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.jpg&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line">    <span class="type">int</span> bytesRead;</span><br><span class="line">    <span class="keyword">while</span> ((bytesRead = in.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        out.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符流FileReader，会自动将字节按编码转换为字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取文本文件（字符流）</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;input.txt&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">     <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(reader)) &#123;</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓冲流, 提供了一个缓冲区，可以减少对硬盘的读取次数，从而提高性能。</p><p>RandomAccessFile，支持随机访问文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomAccessFileExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>)) &#123;</span><br><span class="line">            file.writeUTF(<span class="string">&quot;Hello, World!&quot;</span>);  <span class="comment">// 写入字符串</span></span><br><span class="line">            file.seek(<span class="number">0</span>);  <span class="comment">// 将文件指针移动到文件开头</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> file.readUTF();  <span class="comment">// 读取字符串</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Read from file: &quot;</span> + data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h4><p>System.out 是 Java 中标准输出流，是 PrintStream 类型的对象</p><p>System.in 是 Java 中标准输入流, 是 InputStream 类型的对象，读取的是byte数据。</p><p>对于字符数据，通常会使用 Scanner 或 BufferedReader 类接收输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScannerInput</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;Enter your name:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.nextLine();  <span class="comment">// 读取一行字符串</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Enter your age:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + name + <span class="string">&quot;, Age: &quot;</span> + age);</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 格式化输出</span></span><br><span class="line">System.out.printf(String format, Object... args);</span><br></pre></td></tr></table></figure><h4 id="网络库"><a href="#网络库" class="headerlink" title="网络库"></a>网络库</h4><p>JAVA NIO（New Input&#x2F;Output）是Java提供的高性能、非阻塞I&#x2F;O框架，位于java.nio 包, 适用于高并发网络编程。</p><ol><li>Buffer（缓冲区）​​临时存储数据，所有读写操作均通过缓冲区完成。</li><li>Channel（通道）​​连接数据源与缓冲区，支持双向读写。包括FileChannel：文件I&#x2F;O, ServerSocketChannel：TCP服务端</li><li>Selector（选择器）​​单线程监听多个通道事件（如连接、读、写）。</li></ol><p>JAVA Netty​​ 是一个高性能、异步事件驱动的网络应用框架， 基于 Java NIO（Non-blocking I&#x2F;O）设计</p><ol><li>基于 Reactor 模型，通过多路复用（Selector）实现非阻塞 I&#x2F;O。</li><li>内置 HTTP&#x2F;1.x、HTTP&#x2F;2、WebSocket、TCP&#x2F;UDP、gRPC 等协议支持。</li><li>零拷贝和内存优化</li></ol><p>核心抽象</p><ol><li>Channel​​ 网络连接的抽象，代表一个开放的 Socket 连接。</li><li>​​EventLoop​​：事件循环，处理 I&#x2F;O 操作和事件（如连接、读写）。​​EventLoopGroup​​：管理一组 EventLoop，通常分为 BossGroup（接收连接）和 WorkerGroup（处理 I&#x2F;O）。</li><li>​​Pipeline​​：处理链，由多个 ChannelHandler 组成，负责处理入站（Inbound）和出站（Outbound）事件。</li><li>​Handler​​：业务逻辑单元，如编解码、日志、业务处理。</li><li>ByteBuf, Netty 的字节容器，支持堆内&#x2F;堆外内存、内存池化。</li></ol><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><h4 id="文件IO-1"><a href="#文件IO-1" class="headerlink" title="文件IO"></a>文件IO</h4><p>golang中，io包定义了 I&#x2F;O 操作的抽象接口（Reader、Writer、io.Closer）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 随机访问</span></span><br><span class="line"><span class="keyword">type</span> Seeker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Seek(offset <span class="type">int64</span>, whence <span class="type">int</span>) (<span class="type">int64</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件 I&#x2F;O 操作主要通过 os、io 和 bufio 包实现</p><ol><li>os包，直接与操作系统交互，提供最底层的文件描述符（*os.File）操作。方法Open、Create、Close、Stat、Chmod、Truncate等。每次读写都是系统调用。</li><li>bufio包，是io包接口的一种实现，提供了缓冲区，可以减少系统调用次数，提高性能。缓冲读取（bufio.Reader、Scanner）。缓冲写入（bufio.Writer）。</li></ol><p>实现io包的抽象接口</p><ol><li>os.File， 直接与操作系统交互，提供最底层的文件描述符（*os.File）操作。方法Open、Create、Close、Stat、Chmod、Truncate等。每次读写都是系统调用。</li><li>net.Conn, 提供了网络IO的Read(b []byte) (n int, err error)等接口, net.TCPConn、net.UDPConn 等具体实现</li><li>bufio，提供了缓冲io，一般需要os.File或net.Conn的构造</li></ol><p>tcp实现的Read, Write接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/net/net.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span></span> Read(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用 netFD（网络文件描述符）的 Read 方法</span></span><br><span class="line">    n, err := c.fd.Read(b)</span><br><span class="line">    <span class="keyword">return</span> n, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/poll/fd_unix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span></span> Read(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n, err := syscall.Read(fd.Sysfd, p)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 处理 EAGAIN（非阻塞模式下无数据）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n, err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>os.File和bufio</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用file构造bufio.Reader,形成带缓冲的读取</span></span><br><span class="line">file, _ := os.Open(<span class="string">&quot;data.txt&quot;</span>)</span><br><span class="line">reader := bufio.NewReader(file)         <span class="comment">// 默认 4096 字节缓冲</span></span><br><span class="line"><span class="comment">// 或自定义缓冲区大小</span></span><br><span class="line">reader = bufio.NewReaderSize(file, <span class="number">8192</span>) <span class="comment">// 8KB 缓冲</span></span><br><span class="line"><span class="comment">// 用file构造bufio.Writer,形成带缓冲的写入</span></span><br><span class="line">file, _ := os.Create(<span class="string">&quot;output.txt&quot;</span>)</span><br><span class="line">writer := bufio.NewWriter(file)</span><br></pre></td></tr></table></figure><p>打开文件, os.Open, os.OpenFile</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(<span class="string">&quot;data.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close() <span class="comment">// 确保文件关闭</span></span><br><span class="line"></span><br><span class="line">file, err := os.Create(<span class="string">&quot;output.txt&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">file, err := os.OpenFile(<span class="string">&quot;log.txt&quot;</span>, os.O_APPEND|os.O_WRONLY, <span class="number">0644</span>)</span><br></pre></td></tr></table></figure><p>读取文件,  os.ReadFile, bufio.NewScanner(file), file.Read(buffer)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os.ReadFile读取全部内容</span></span><br><span class="line">data, err := os.ReadFile(<span class="string">&quot;data.txt&quot;</span>) <span class="comment">// Go 1.16+</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="type">string</span>(data))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用bufio 包装file逐行读取</span></span><br><span class="line">file, _ := os.Open(<span class="string">&quot;data.txt&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">scanner := bufio.NewScanner(file)</span><br><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">    line := scanner.Text()</span><br><span class="line">    fmt.Println(line)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用file.Read分块读取</span></span><br><span class="line">file, _ := os.Open(<span class="string">&quot;data.txt&quot;</span>)</span><br><span class="line">buffer := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">4096</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    n, err := file.Read(buffer)</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    process(buffer[:n])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写入文件os.WriteFile, file.WriteString, writer.WriteString</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入字节到文件</span></span><br><span class="line">data := []<span class="type">byte</span>(<span class="string">&quot;Hello, Go!\n&quot;</span>)</span><br><span class="line">err := os.WriteFile(<span class="string">&quot;output.txt&quot;</span>, data, <span class="number">0644</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加写入字符串到文件</span></span><br><span class="line">file, _ := os.OpenFile(<span class="string">&quot;log.txt&quot;</span>, os.O_APPEND|os.O_WRONLY, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">_, err := file.WriteString(<span class="string">&quot;New log entry\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓冲写入</span></span><br><span class="line">writer := bufio.NewWriter(file)</span><br><span class="line">_, err := writer.WriteString(<span class="string">&quot;Buffered data\n&quot;</span>)</span><br><span class="line">writer.Flush() <span class="comment">// 确保数据写入磁盘</span></span><br></pre></td></tr></table></figure><p>序列化数据到文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user := User&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;</span><br><span class="line">data, _ := json.Marshal(user)</span><br><span class="line">os.WriteFile(<span class="string">&quot;user.json&quot;</span>, data, <span class="number">0644</span>)</span><br></pre></td></tr></table></figure><p>golang fmt格式化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数</span></span><br><span class="line">%v值的默认格式表示</span><br><span class="line">%+v带字段名的结构体表示</span><br><span class="line"></span><br><span class="line">%c对应 Unicode 码点的字符</span><br><span class="line">%d十进制表示</span><br><span class="line">%x十六进制（小写字母）</span><br><span class="line">%X十六进制（大写字母）</span><br><span class="line"></span><br><span class="line">%s字符串</span><br><span class="line">%.nf: 指定小数点后 n 位</span><br><span class="line">%m.nf 设置宽度和小数位数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;My name is %s and I am %d years old.\n&quot;</span>, name, age)  <span class="comment">// 格式化输出</span></span><br><span class="line">fmt.Fprint(os.Stdout, <span class="string">&quot;Hello, world!&quot;</span>)  <span class="comment">// 将格式化的输出写入到指定的 io.Writer</span></span><br><span class="line">fmt.Fprintf(file, <span class="string">&quot;Hello, file!&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Scanf(<span class="string">&quot;%s %d&quot;</span>, &amp;name, &amp;age)  <span class="comment">// fmt.Scanf() 格式化输入</span></span><br><span class="line">fmt.Scanln(&amp;name)</span><br><span class="line"></span><br><span class="line">result := fmt.Sprintf(<span class="string">&quot;Name: %s, Age: %d&quot;</span>, name, age)  <span class="comment">// 字符串格式化，返回新字符串</span></span><br><span class="line">fmt.Sscanf(input, <span class="string">&quot;%s %d&quot;</span>, &amp;name, &amp;age)</span><br></pre></td></tr></table></figure><h4 id="网络库-1"><a href="#网络库-1" class="headerlink" title="网络库"></a>网络库</h4><p>Go 语言的 net 包是标准库中用于网络编程的核心模块，提供了简洁高效的 API 支持 TCP&#x2F;IP、UDP、HTTP 等协议。net&#x2F;http和net&#x2F;rpc分别支持http和rpc协议。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 连接到 TCP 服务器</span></span><br><span class="line">conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error dialing:&quot;</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向服务器发送数据</span></span><br><span class="line">_, err = conn.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello, Server!&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error sending message:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取服务器响应</span></span><br><span class="line">buffer := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">n, err := conn.Read(buffer)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error reading response:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印接收到的响应</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Received: %s\n&quot;</span>, <span class="type">string</span>(buffer[:n]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 在本地启动一个 TCP 服务器，监听端口 8080</span></span><br><span class="line">listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error starting server:&quot;</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listen.Close()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Server started, waiting for connections...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受客户端连接</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := listen.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error accepting connection:&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取客户端消息</span></span><br><span class="line">buffer := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">n, err := conn.Read(buffer)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error reading from connection:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出接收到的消息</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Received: %s\n&quot;</span>, <span class="type">string</span>(buffer[:n]))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向客户端发送响应</span></span><br><span class="line">_, err = conn.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello, Client!&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error sending response:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="flag-命令行解析"><a href="#flag-命令行解析" class="headerlink" title="flag 命令行解析"></a>flag 命令行解析</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义命令行参数</span></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> isAdmin <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 flag 包解析命令行标志</span></span><br><span class="line">flag.StringVar(&amp;name, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Guest&quot;</span>, <span class="string">&quot;Your name&quot;</span>)</span><br><span class="line">flag.IntVar(&amp;age, <span class="string">&quot;age&quot;</span>, <span class="number">18</span>, <span class="string">&quot;Your age&quot;</span>)</span><br><span class="line">flag.BoolVar(&amp;isAdmin, <span class="string">&quot;admin&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;Is admin?&quot;</span>)</span><br><span class="line"></span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;Name: %s\n&quot;</span>, name)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Age: %d\n&quot;</span>, age)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Is Admin: %v\n&quot;</span>, isAdmin)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行, go run main.go -name=John -age=30 -admin=true</span></span><br></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><h4 id="文件IO-2"><a href="#文件IO-2" class="headerlink" title="文件IO"></a>文件IO</h4><p>python 提供open, file, read, write, close 等原生操作文件的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line"><span class="comment"># &#x27;r&#x27;：只读模式，文件必须存在。</span></span><br><span class="line"><span class="comment"># &#x27;w&#x27;：写入模式，若文件已存在则覆盖，不存在则创建。</span></span><br><span class="line"><span class="comment"># &#x27;a&#x27;：追加模式，在文件末尾追加内容，若文件不存在，则创建。</span></span><br><span class="line"><span class="comment"># &#x27;b&#x27;：二进制模式（如读取或写入图片、音频等）</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;filename&#x27;</span>, mode=<span class="string">&#x27;r&#x27;</span>, buffering=-<span class="number">1</span>, encoding=<span class="literal">None</span>, errors=<span class="literal">None</span>, newline=<span class="literal">None</span>, closefd=<span class="literal">True</span>, opener=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    content = file.read()  <span class="comment"># 读取全部内容</span></span><br><span class="line">    <span class="built_in">print</span>(content)</span><br><span class="line">    </span><br><span class="line">    file.seek(<span class="number">0</span>)  <span class="comment"># 文件指针移动到开头</span></span><br><span class="line">    first_10_chars = file.read(<span class="number">10</span>)  <span class="comment"># 读取前10个字符</span></span><br><span class="line">    <span class="built_in">print</span>(first_10_chars)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(file.tell())  <span class="comment"># 输出文件指针当前位置</span></span><br><span class="line"></span><br><span class="line">    file.write(<span class="string">&quot;Hello, World!\n&quot;</span>)  <span class="comment"># 写入内容</span></span><br><span class="line"></span><br><span class="line">    lines = [<span class="string">&#x27;Line 1\n&#x27;</span>, <span class="string">&#x27;Line 2\n&#x27;</span>, <span class="string">&#x27;Line 3\n&#x27;</span>]</span><br><span class="line">    file.writelines(lines)  <span class="comment"># 写入多行</span></span><br><span class="line">    file.flush()  <span class="comment"># 立即写入数据</span></span><br></pre></td></tr></table></figure><p>python的os 模块提供文件元数据操做的方法，如remove, stat, rename, remove, mkdir</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">os.remove(<span class="string">&#x27;example.txt&#x27;</span>)  <span class="comment"># 删除文件</span></span><br><span class="line"><span class="comment"># 获取文件状态信息</span></span><br><span class="line">stat_info = os.stat(<span class="string">&#x27;example.txt&#x27;</span>)</span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">os.mkdir(<span class="string">&#x27;new_directory&#x27;</span>)</span><br></pre></td></tr></table></figure><p>print() 函数用于标准输出, 支持格式化输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Alice&quot;</span></span><br><span class="line">age = <span class="number">25</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;My name is <span class="subst">&#123;name&#125;</span>, and I am <span class="subst">&#123;age&#125;</span> years old.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is &#123;&#125;, and I am &#123;&#125; years old.&quot;</span>.<span class="built_in">format</span>(name, age))</span><br></pre></td></tr></table></figure><p>input()用于标准输入， input读到的类型都是字符串, 需要转换为对应类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;Enter your name: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter your age: &quot;</span>))</span><br></pre></td></tr></table></figure><h4 id="argparse-命令行参数解析"><a href="#argparse-命令行参数解析" class="headerlink" title="argparse 命令行参数解析"></a>argparse 命令行参数解析</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 ArgumentParser 对象</span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&quot;A simple command-line tool&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加参数</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;name&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot;Your name&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;age&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&quot;Your age&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--admin&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&quot;Are you an admin?&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析命令行参数</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Name: <span class="subst">&#123;args.name&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Age: <span class="subst">&#123;args.age&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Admin: <span class="subst">&#123;args.admin&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="json-序列化"><a href="#json-序列化" class="headerlink" title="json 序列化"></a>json 序列化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="string">&quot;city&quot;</span>: <span class="string">&quot;New York&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件并写入 JSON 数据</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">    json.dump(data, json_file, indent=<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 从文件中读取 JSON 数据</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">    data = json.load(json_file)</span><br><span class="line"><span class="comment"># 对象编码</span></span><br><span class="line">json_string = json.dumps(data, indent=<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 对象解码</span></span><br><span class="line">data = json.loads(json_string)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> base </category>
          
      </categories>
      
      
        <tags>
            
            <tag> language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程语言——静态变量和静态函数</title>
      <link href="/2024/12/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0/"/>
      <url>/2024/12/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>简谈编程语言中的静态变量和函数</p><span id="more"></span><h3 id="C-的静态变量-函数"><a href="#C-的静态变量-函数" class="headerlink" title="C++的静态变量&#x2F;函数"></a>C++的静态变量&#x2F;函数</h3><p>C++中，静态变量生命周期贯穿程序，在程序开始运行时分配内存并初始化，程序结束运行时释放内存。</p><ol><li>在继承结构中，如果子类未定义同名静态变量，父类和子类引用相同的静态变量，父类和子类静态变量地址一样；如果子类定义了同名的静态变量，那么父类和子类具有独立的静态变量。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count; <span class="comment">// 静态变量声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::count = <span class="number">0</span>; <span class="comment">// 静态变量定义和初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">// 派生类可以访问静态变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base::count = <span class="number">5</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Base::count: &quot;</span> &lt;&lt; Base::count &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Derived::count: &quot;</span> &lt;&lt; Derived::count &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Base::count address: &quot;</span> &lt;&lt; &amp;Base::count &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Derived::count address: &quot;</span> &lt;&lt; &amp;Derived::count &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Base::count: <span class="number">5</span></span><br><span class="line">Derived::count: <span class="number">5</span></span><br><span class="line">Base::count address: <span class="number">0x55a3f58cf154</span></span><br><span class="line">Derived::count address: <span class="number">0x55a3f58cf154</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>全局静态变量在.cpp文件级别声明，只在定义它的文件中可见，其他.cpp无法通过extern声名引用。除了静态变量，C++全局变量的生命周期也和程序相同，全局变量可以被其他.cpp文件引用，链接时会使相关.cpp文件引用相同的全局变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> global_var = <span class="number">10</span>; <span class="comment">// 文件级静态变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Global variable: &quot;</span> &lt;&lt; global_var &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// extern int global_var; // 错误，无法访问 file1.cpp 的静态变量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// display(); // 如果 display 定义在 file1.cpp，可以调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>C++静态函数和上面的静态变量类似，</p><ol><li>如果子类未定义同名静态函数，父类和子类引用相同的静态函数，父类和子类静态变量地址一样；如果子类定义了同名的静态函数，那么父类和子类具有独立的静态函数。</li><li>全局静态函数在.cpp文件级别声明，只在定义它的文件中可见，其他.cpp无法通过extern声名引用。C++全局函数的生命周期也和程序相同，全局函数可以被其他.cpp文件引用，链接时会使相关.cpp文件引用相同的全局变量。</li></ol></li></ol><p>静态变量&#x2F;函数的符号未被导出，其他文件无法直接引用它。这是静态函数的设计初衷，用来实现模块化和封装。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base static function&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 派生类继承了 Base 的静态函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过基类调用</span></span><br><span class="line">    Base::<span class="built_in">display</span>(); <span class="comment">// 输出：Base static function</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Base::display address: &quot;</span> &lt;&lt;<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;Base::display) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过派生类调用</span></span><br><span class="line">    Derived::<span class="built_in">display</span>(); <span class="comment">// 输出：Base static function</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Derived::display address: &quot;</span> &lt;&lt;<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;Derived::display) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 通过派生类的对象调用</span></span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">display</span>(); <span class="comment">// 输出：Base static function</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Base <span class="type">static</span> function</span><br><span class="line">Base::display address: <span class="number">0x55a1967b42bf</span></span><br><span class="line">Base <span class="type">static</span> function</span><br><span class="line">Derived::display address: <span class="number">0x55a1967b42bf</span></span><br><span class="line">Base <span class="type">static</span> function</span><br></pre></td></tr></table></figure><ol start="4"><li>C++静态函数不能配置成虚函数virtual, const和volatile<ol><li>static函数目的是编译时绑定，而virtual函数要求运行时绑定，二者不可兼容。虚函数表里也不会记录static函数</li><li>const 类成员函数表示该函数不能被修改类成员变量，static函数不属于对象，本质通过类名调用，不能配置成const函数</li><li>静态变量可以被const, volatile修饰</li></ol></li></ol><h3 id="JAVA的静态变量和函数"><a href="#JAVA的静态变量和函数" class="headerlink" title="JAVA的静态变量和函数"></a>JAVA的静态变量和函数</h3><p>JAVA 静态变量和函数的逻辑和C++类似，不一样的使JAVA的类加载机制。JAVA除了静态变量和静态函数的概念，还有静态代码块的概念。<strong>类加载时，会初始化静态变量和执行静态代码块内容</strong>。</p><p>但不是每个类都会被加载，有两种加载类的条件</p><ol><li>主动使用类时，如：创建类实例（new操作）。调用类的静态方法。访问类的静态字段。使用Class.forName()加载类。</li><li>子类初始化时，父类会被初始化。</li></ol><p>C++不需要加载类，因为编译完C++代码就没有类的信息了，更不用说加载类。</p><p>通过子类引用父类的静态字段： 只会初始化父类，而不会初始化子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent initialized.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child initialized.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Child.value); <span class="comment">// 只输出 Parent initialized.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Parent initialized.</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure><p><strong>常量在编译期已确定，不会触发类加载。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Example initialized.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONSTANT</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Example.CONSTANT); <span class="comment">// 不会触发类加载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure><p>JAVA类函数默认所有实例方法都是虚函数，支持多态，final、static、private方法除外。但静态函数不支持多态。</p><h3 id="Golang-的全局函数-变量"><a href="#Golang-的全局函数-变量" class="headerlink" title="Golang 的全局函数&#x2F;变量"></a>Golang 的全局函数&#x2F;变量</h3><p>Go语言中，没有像C&#x2F;C++或Java中明确的“静态变量”概念。</p><p>全局变量在Go中可以用于实现类似静态变量的功能。全局变量, 作用域为整个包。如下函数中，它的值在每次调用 increment 函数后都会保留。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter <span class="type">int</span> <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    counter++</span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(increment()) </span><br><span class="line">    fmt.Println(increment()) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>Go的标准库提供了 sync.Once，可以确保某段代码只执行一次（类似静态初始化）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"><span class="keyword">var</span> config <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initConfig</span><span class="params">()</span></span> &#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Initializing config...&quot;</span>)</span><br><span class="line">        config = <span class="string">&quot;LoadedConfig&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    initConfig()</span><br><span class="line">    fmt.Println(config)</span><br><span class="line"></span><br><span class="line">    initConfig() <span class="comment">// 不会再初始化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Initializing config...</span><br><span class="line">LoadedConfig</span><br></pre></td></tr></table></figure><p>组合对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌入结构体</span></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">Person   <span class="comment">// 匿名字段（嵌入字段）</span></span><br><span class="line">Position <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">per := Person&#123;Name: <span class="string">&quot;Alice&quot;</span>, Age: <span class="number">20</span>&#125;</span><br><span class="line">emp := Employee&#123;</span><br><span class="line">Person:   per,</span><br><span class="line">Position: <span class="string">&quot;Developer&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(emp.Name)</span><br><span class="line">fmt.Println(emp.Age)</span><br><span class="line">fmt.Println(emp.Position)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Alice</span><br><span class="line"><span class="number">20</span></span><br><span class="line">Developer</span><br></pre></td></tr></table></figure><h3 id="Python的类函数和静态函数"><a href="#Python的类函数和静态函数" class="headerlink" title="Python的类函数和静态函数"></a>Python的类函数和静态函数</h3><p>Python 没有对变量的静态修饰，只有对函数的classmethod和staticmethod修饰</p><p>类函数的第一个参数是 cls，表示调用该方法的类本身，而不是实例。类函数可以访问类的属性和方法，不能直接操作实例属性。类函数通过类名调用</p><p>Python在类内部直接定义的变量是类变量，比如下面的static_var，self定义的变量是实例变量。前者可以通过cls访问。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    static_var = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        MyClass.static_var += <span class="number">1</span>  <span class="comment"># 每次创建实例时修改类变量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_static_var</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">return</span> cls.static_var</span><br><span class="line"></span><br><span class="line">a = MyClass()</span><br><span class="line">b = MyClass()</span><br><span class="line"><span class="built_in">print</span>(MyClass.static_var)  <span class="comment"># 输出: 2</span></span><br><span class="line"><span class="built_in">print</span>(a.get_static_var())  <span class="comment"># 输出: 2</span></span><br></pre></td></tr></table></figure><p>静态方法不需要传递 self 或 cls 参数。不能访问类或实例的属性，只能执行独立的功能。同样通过类名调用。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">static_method</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This is a static method.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用</span></span><br><span class="line">MyClass.static_method()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> base </category>
          
      </categories>
      
      
        <tags>
            
            <tag> language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储——缓存简谈</title>
      <link href="/2024/12/22/%E5%AD%98%E5%82%A8%E2%80%94%E7%BC%93%E5%AD%98%E7%AE%80%E8%B0%88/"/>
      <url>/2024/12/22/%E5%AD%98%E5%82%A8%E2%80%94%E7%BC%93%E5%AD%98%E7%AE%80%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<p>缓存存放的是临时数据，相比主存，缓存往往速度更快，容量更小。</p><p>缓存往往是多级的，由内而外，cpu cache -&gt; 内存 -&gt; ssd -&gt; hdd（单机） -&gt; 服务器&#x2F;多节点&#x2F;oss&#x2F;nas等</p><p>缓存需要淘汰，因此缓存往往由链表组成，根据LRU算法淘汰</p><p><strong>只要有缓存就会有一致性问题</strong></p><span id="more"></span><h3 id="写缓存"><a href="#写缓存" class="headerlink" title="写缓存"></a>写缓存</h3><p>写缓存有两种策略，write back和write through。</p><p>write back情况下，缓存不会立刻更新到主存，这让write back是单对象的行为。如果是多对象操作缓存，write back必然存在缓存不可见问题。例如page cache，一个进程的写入对另一个进程可能不可见。</p><p><strong>一般选择的写缓存策略是write through</strong> ，相当于没有写缓存。或者选择一写，即写操作转发给一个节点执行，过程通过lease协调，避免写冲突和减少复杂性</p><h3 id="读缓存"><a href="#读缓存" class="headerlink" title="读缓存"></a>读缓存</h3><p>为了一致性，读写一般使用同一个缓存。<strong>读缓存需要考虑的就是缓存失效问题。</strong> 读缓存需要处理，如果写操作导致大量客户端读缓存失效，产生的缓存穿透问题。</p><p>nfs3 close-and-open一致性表示，文件close后，写缓存刷到后台，文件open后，本地读缓存全部失效，需要从后台重新拿。此外，nfs3通过ctime表示缓存有效性，每次读操作nfs3 都会向后台执行getattr，如果ctime和缓存一致，则直接读本地，否则读后台。</p><p>在有lease功能后，lease 的版本id，起到ctime的作用。数据写入服务端会lease++，客户端每次读操作会从后台获取lease，如果lease 和本地一致，则直接读本地，否则本地读缓存失效，读后台。</p><p>缓存在生效前需要先预热，也就是预读</p><ol><li>读缓存需要发挥提高读性能的作用</li><li>缓存失效避免大规模请求打到后端</li><li>缓存预读、更新上的优化</li></ol><h3 id="缓存的更新"><a href="#缓存的更新" class="headerlink" title="缓存的更新"></a>缓存的更新</h3><p>缓存本质是KV map，需要加锁维护。缓存可能遇到大量请求同时更新，更新时的加锁可能严重影响性能。</p><p>缓存更新有两种</p><ol><li>缓存key存在，value失效了需要更新，这种不需要加锁，很快速</li><li>缓存key被淘汰了&#x2F;不存在，需要插入，这种更新需要加锁，比较重</li></ol><p>缓存还可以根据状态更新，典型的是cpu cacheline的MSI协议（Modified, Shared和Invalid）。这个要求每个cache line能感知到其他cache line发生写操作，同时能通知其他cache line写内存。例如cpu1能感知到cpu2发生了写cache操作，于是更新自己状态为unvalid，并让cpu2 刷到内存。java的valitale 关键字就是通过让cpu将对变量的修改直接刷内存</p><p>使用范围很小。 </p><h3 id="缓存穿透，缓存雪崩"><a href="#缓存穿透，缓存雪崩" class="headerlink" title="缓存穿透，缓存雪崩"></a>缓存穿透，缓存雪崩</h3><p>读缓存场景，如果数据被写入会导致所有客户端读缓存失效，瞬时压力可能给到服务器。</p><p>如果只是写操作导致的缓存失效，则缓存穿透也可以理解<br>如果是过期引起的缓存失效，使用LRU同时防止缓存大规模同时过期</p><p>主存前面可以加队列和流控来缓解压力，架构设计上<strong>一定要避免缓存失效大量请求打到后端服务器</strong>。</p><p>流控可以考虑权重公平流控，后台统计每个client的请求数量，当总数量达到阈值，通过权重计算得到每个client的能放进去的请求数量（最小值和最大值，也不能没请求）</p><h3 id="4k对齐"><a href="#4k对齐" class="headerlink" title="4k对齐"></a>4k对齐</h3><p>IO场景的缓存多是对齐的，例如page cache是4K对齐</p><p>write through策略，每笔写入都会写到后台，即使不是4K写。<br>客户端读缓存也设置成4K对齐的，使page cache可以命中</p><p>自定义fuse客户最好自行管理缓存</p><h3 id="文件元数据缓存"><a href="#文件元数据缓存" class="headerlink" title="文件元数据缓存"></a>文件元数据缓存</h3><p>主要的元数据缓存</p><ol><li>inode缓存，缓存inode 元数据，atime, ctime, mtime, link, mode, size等信息，这个缓存会经常更新</li><li>inode 数据缓存，</li><li>dentry缓存，缓存目录项存的文件名，方便readdir，文件创建删除时需要更新</li></ol><p>ganesha 元数据缓存，<br>genasha每个目录项会缓存目录中子文件name-&gt;filehandle映射，目的是方便lookup。如果lookup某个name缓存未命中， 会持有目录写锁 访问后台，拿到（name, filehandle)后释放目录写锁。<br>这样的原因是不给后台太多压力，防止多个请求同时打向后台（加了写锁只有一个lookup请求能打到后台），问题是产生了lookup串行化影响性能。</p><p>缓存应该有预读的功能，即缓存失效后尽量从后台拿到局部性多的数据。</p>]]></content>
      
      
      <categories>
          
          <category> base </category>
          
      </categories>
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统——并发简谈</title>
      <link href="/2024/12/20/%E7%B3%BB%E7%BB%9F%E2%80%94%E5%B9%B6%E5%8F%91%E7%AE%80%E8%B0%88/"/>
      <url>/2024/12/20/%E7%B3%BB%E7%BB%9F%E2%80%94%E5%B9%B6%E5%8F%91%E7%AE%80%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<p>并发可分成并发对象和并发协调两部分。并发对象可以是进程、线程、协程、以及多机并发。并发协调包括锁（进程锁、线程锁、协程锁、分布式锁），信号，信号量，条件变量，通信队列等。</p><p>并发编程的三个特点是<strong>原子性、有序性、可见性</strong>。<strong>原子性要求写操作要么执行完要么不执行，不能中途执行一半被干扰，并发编程中需要保证所有操作都是原子的</strong>；完全要求顺序的程序无法并发，因此并发编程的特点是原子性+部分有序。<strong>可见性是针对并发读共享变量</strong>，如果并发对象之间读共享变量，就要维护共享变量的可见性，一个并发对象修改另一个并发对象可以看到。（如果只有并发写，只要考虑原子性和顺序性，不需要可见性）</p><span id="more"></span><h2 id="并发对象"><a href="#并发对象" class="headerlink" title="并发对象"></a>并发对象</h2><p>传统（或者普遍）的程序执行是串行顺序的，<strong>如果把互不依赖的逻辑由单个串行改成多个并行，就产生了并发。</strong></p><p>常见的并发场景</p><ol><li>网络访问，例如http请求、mysql连接池，创建多个链接发送接收数据，链接之间互不影响</li><li>文件IO，多个线程写不同文件，线程之间互不影响。如果多线程写相同文件，线程间可能相互影响，需要对并发进行优化</li><li>为了利用多核能力，程序创建多进程&#x2F;线程，并行计算</li><li>生产者消费者模型（任务队列模型），多线程从任务队列拿任务处理，任务之间互不影响</li></ol><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>多线程需要处理数据更新的竞争问题，例如向数据库更新一个key，可能遇到不同线程尝试更新到不同值。即使不考虑顺序性，但由于更新key无法保证原子性，还是需要加锁维护。一个解决办法是，将key的操作绑定到线程池指定线程，也就是说，对于key的更新只交给一个固定的线程做。又比如文件系统，如果保证每个文件始终由固定的线程处理，那文件的每个io操作就天然具备了原子性。</p><p><strong>数据密集型应用中，执行流的耗时主要来自IO和网络</strong>。如果我们让固定的线程处理某文件的io，该线程大部分时间都会在睡眠等待数据落盘和磁盘取数据。办法是在单线程之上进行多协程调度，一旦出现IO等待，自动切换协程。这样<strong>理想情况下，线程一直执行计算和内存操作。</strong> 单线程的最高QPS就是1&#x2F;（一次计算和内存的耗时）。</p><p>虽然golang 实现了协程自动调度，让程序员像使用线程一样方便的使用协程（golang协程使用上和线程没有区别）。但协程的手动调度还是必要存在的。<strong>手动调度的好处是，对需要原子性的操作，保证执行完且执行期间不会协程切换。</strong>例如更新数据表期间，协程不会切走（切走其他协程就可能修改该数据-&gt;就需要加锁）</p><p>协程避免回调地狱。调用一次await，函数会自动放弃的执行权，执行权交由另外随机的协程。协程避免回调地狱前提是多个函数是可以异步调用的，如果必须等待回调函数返回才能执行下一个回调，那只能用线性回调。</p><p>单线程多协程模型是并发同时减少锁争抢的有效模型，例如作为中央服务的服务端，可以用单线程处理某个client&#x2F;session独占请求和数据，从而提供了原子性，不用对client&#x2F;session独占的请求&#x2F;数据加锁。</p><p>协程的编程模型</p><ol><li>将逻辑分为处理层、IO层、回调层。每层维护一个线程池，对于相同client请求，每层由固定的线程执行。处理层线程只处理非IO逻辑，最后把IO放到IO层；IO层协程其实是负责监听IO完成，完成后交给回调层处理回调函数。相同client请求由于每层都由固定的线程处理，不用加锁。同时单线程利用协程实现并发处理client的大量请求</li><li>采用async&#x2F;await编程模型，利用同步的编程手法实现类似1的单线程多协程并发，但不用配置大量的回调函数</li></ol><p>await 后面跟无线程阻塞的异步函数，当协程执行到await时，会把当前协程注册事件到协程调度器（或把当前协程作为作为切换后协程的回调函数）。当await异步函数执行完毕，会通知给协程调度器，然后转而继续执行。</p><p>理想情况下，只有协程会阻塞，线程会一直执行处理请求的工作。线程不会进入操作系统的等待队列，从而大大提高cpu的使用率。协程模型中往往一个cpu创建一个线程就足够。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs/promises&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">readFiles</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> data1 = <span class="keyword">await</span> fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file1.txt&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> data2 = <span class="keyword">await</span> fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file2.txt&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> data3 = <span class="keyword">await</span> fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file3.txt&#x27;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data1.<span class="title function_">toString</span>(), data2.<span class="title function_">toString</span>(), data3.<span class="title function_">toString</span>());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">readFiles</span>();</span><br></pre></td></tr></table></figure><h3 id="多链接并发"><a href="#多链接并发" class="headerlink" title="多链接并发"></a>多链接并发</h3><p>一个客户端创建多个链接，并发访问服务端数据。多链接请求比单链接好。</p><h2 id="并发协调"><a href="#并发协调" class="headerlink" title="并发协调"></a>并发协调</h2><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁，可以抽象成两点</p><ol><li><strong>锁作用是对并发场景下共享资源竞争的保护。</strong></li><li><strong>获取锁也就是某并发对象获得对某资源的操作权</strong></li></ol><p>凡是某资源可能被多个对象操作，就要考虑使用锁来保护</p><p>线程锁，对多个线程操作共享资源的保护;<br>进程锁，对多个进程操作共享资源的保护;<br>分布式锁，叫机器锁容易理解，对多个机器操作共享资源的保护</p><p>单机文件系统，文件锁是一种进程锁; 多机共享文件系统，文件锁是一种分布式锁</p><p>lease也可以看做一种锁，获取lease 也是获取某对象的操作权</p><h4 id="死锁和处理"><a href="#死锁和处理" class="headerlink" title="死锁和处理"></a>死锁和处理</h4><p>持有锁就要考虑死锁，<strong>死锁产生的原因是申请释放锁顺序不一致</strong></p><ol><li><strong>如果对象不会发生，持有锁的情况申请锁，则不会有死锁</strong></li><li>对于锁序列A, B, C, D，如果多个对象有统一的加锁顺序，例如遵循加锁A释放、加锁B释放、加锁C释放，<strong>不会有环形加锁的逻辑，则不会产生死锁</strong>。类似是是文件系统树lookup pathwalk的顺序</li><li><strong>多对象加锁顺序不一致才会产生死锁</strong><ol><li>文件系统rename，hardlink 路径不是从根节点的pathwalk，可能会产生死锁。如rename需要对目录加写锁（原因是需要删除源目录文件，创建新目录文件，需要先对两个目录加锁，由于加锁顺序可以是A-&gt;B，B-&gt;A，会发生死锁），linux为了处理rename死锁，规定每个文件系统内每次只能进行一个 rename 操作。<ol><li>hardlink需要对源文件加元数据锁，新hardlink文件的目录加写锁，linux处理hardlink死锁问题，规定link 的对象不能是目录</li></ol></li></ol></li></ol><p>文件系统加锁原理</p><ol><li>写文件需加文件写锁，更新文件元数据加文件元数据写锁</li><li>创建文件和删除文件需加目录写锁</li><li>read, getattr, setattr需要对元数据加锁，因为需要更新元数据</li><li><strong>rename锁最重，需要对源和目的文件的目录加锁</strong></li></ol><p>lease也是一种锁，lease场景是多个机器试图操作同一服务器资源（例如多客户端试图操作共享资源</p><ol><li>lease由服务器管理，<strong>如果服务器运行正常，服务器可以撤销某客户端的lease锁</strong>，从而结束客户端的死锁状态</li><li>如果服务器崩溃，客户端可能处于死锁等待，这时候<strong>需要客户端设置超时，主动退避重试来避免死锁</strong></li><li>对于文件系统，通常情况下获取lease按照顺序，rename同样可能触发死锁，分析同上‘</li></ol><p>可以看到死锁的两种处理办法</p><ol><li>避免死锁，例如保证某操作全局唯一，采用单线程、无锁编程</li><li>处理死锁，超时主动&#x2F;被动释放锁，退避重试</li></ol><h4 id="顺序性"><a href="#顺序性" class="headerlink" title="顺序性"></a>顺序性</h4><p>有时候还要求，从客户端无阻塞发出两个请求A-&gt;B，处理时也要按照A-&gt;B的顺序处理</p><p>常见的是在请求附加clientid和seqid，标注请求的顺序。</p><ol><li>服务端对某clientid，严格按照seqid顺序处理，这样强顺序会损害性能</li><li>客户端维护若干slot，slot内按照seqid顺序地址，将可以并发的请求通过多个slot并发发送。服务端对每个slotid 的请求顺序处理，slot外部不保证顺序</li><li>更宽松的，对于请求序列A,B,C，A请求失败了可以处理B请求，但B如果执行完了，不能再执行A。<br>，<br>例如操作write(‘a’) -&gt; read-&gt;write(‘a’)(重试) -&gt; write(‘abc’)，如果遵循3，结果是read(‘’), write(‘abc’)，如果执行了重试，结果则是write(‘aabc’)。</li></ol><h4 id="版本序列应对一写多读场景锁"><a href="#版本序列应对一写多读场景锁" class="headerlink" title="版本序列应对一写多读场景锁"></a>版本序列应对一写多读场景锁</h4><p>版本序列是读写锁优化的有效手段</p><p>版本是一种缓存，可以是内存的ring。在有人持有写锁期间，可以利用版本读还未写入的数据，当写锁执行完毕，则更新版本。写操作是一种事务提交，这意味着，事务未提交成功之前，状态未改变，等同于没有事务。</p><h4 id="乐观锁应对多写场景锁"><a href="#乐观锁应对多写场景锁" class="headerlink" title="乐观锁应对多写场景锁"></a>乐观锁应对多写场景锁</h4><ol><li>将原数据读到一个副本</li><li>对副本执行写操作，同时获得版本号&#x2F;时间戳</li><li>原子提交，再次版本号&#x2F;时间戳，如果一致，则提交；如果有问题，则重试1</li></ol><p>原子提交也可以换成简单操作，乐观锁的写不能太重，否则可能写期间被更新。</p><h4 id="互斥锁的实现"><a href="#互斥锁的实现" class="headerlink" title="互斥锁的实现"></a>互斥锁的实现</h4><p>spinlock，</p><ol><li>spinlock 主要是保护多cpu操作对象的安全，可以是cpu共享的硬件变量，为了防止死锁，加spinlock需要屏蔽当前cpu的中断</li></ol><p>mutex，存放在内存的共享变量，维护多线程的安全</p><p>中心化数据库&#x2F;redis，zookeeper&#x2F;etcd等中心化kv，实现分布式锁</p><h4 id="客户端锁和服务端锁"><a href="#客户端锁和服务端锁" class="headerlink" title="客户端锁和服务端锁"></a>客户端锁和服务端锁</h4><p>熟悉的线程锁，进程锁是一种客户锁。在用户程序中加锁防止多线程并发修改共享变量。——如果操作系统保证每个对象只能被一个线程访问，也就是加服务端锁，就不需要客户端加锁了，当然由于性能不可能实现。</p><p>分布式锁保护共享变量可以在客户端层面实现，利用保证同一时刻只有一个客户端访问共享变量，则服务端不需要额外加锁。如果允许多客户端同时访问共享变量，服务端分布式锁的实现会异常复杂。</p><p><strong>lease也是通过客户端锁减轻服务端加锁的问题</strong>。分布式锁的损耗很大（ms级），如果经常访问的操作需要加分布式锁，会严重影响服务的性能。</p><p>库存，订单数量修改 加分布式锁的思路是将大量操作封装成事务，追求吞吐量。延迟要求高的操作应该避免服务加分布式锁，而是限制访问的客户端。</p><p><strong>分布式元数据的另一种实现是自行实现raft&#x2F;poixs协议直接保证元数据集群的一致性，同时提供高性能KV存储</strong>，该方法性能比申请加分布式锁高。</p><p>gpfs 可以控制client和server，采用client 锁和服务锁结合的形式。例如写目录文件&#x2F;rename，gpfs要求某时刻只能有一个client执行操作。但修改文件元数据应该可以允许多client操作。</p>]]></content>
      
      
      <categories>
          
          <category> base </category>
          
      </categories>
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程语言(4)—函数和并发编程</title>
      <link href="/2024/12/14/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(4)%E2%80%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/12/14/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(4)%E2%80%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>并发编程是提高程序处理能力的重要手段，也是编程语言必备的能力。并发的对象是函数，函数作为任务被多个并发计算对象执行。</p><p>并发的单位可以是进程、线程和协程（用户态线程），并发需要保证的三个特点：原子性、顺序性和可见性。</p><ol><li>原子性表示操作要么全部成功，要么全部失败，执行中不能被中断。原子性通常使用锁（包括悲观锁、乐观锁）保证。</li><li>顺序性表示任务执行的顺序与任务提交时的顺序一致。顺序性通常使用队列（先进先出）保证，常见的是是生产者-消费队列保证顺序性，例如golang的channel。好的顺序设计，可以保证每个阶段只有少量线程执行，减少锁的使用。减少共享内存的使用，多用顺序性的信号通知，减少锁争抢。在分布式系统中，面对ABA问题，还会对操作和共享内存增加版本号来保证顺序性。</li><li>可见性表示对共享内存的修改对其他线程可见。常见的是使用内存屏障（memory barrier）保证可见性，内存屏障是CPU提供的一种同步机制，保证CPU执行到内存屏障之前的指令都执行完成，再执行内存屏障之后的指令。C++原子类的内存序就是在保证可见性。</li></ol><span id="more"></span><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><h4 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h4><p>C语言中的多线程编程一般使用pthread库, pthread（POSIX线程）库是用于在类Unix系统中实现多线程编程的API实现了posix标准的线程接口。</p><p>pthread支持的接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 线程创建，线程创建后立即执行，函数用void函数指针类型void *(*start_routine) (void *) 传参</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span></span>; <span class="comment">// 使当前线程退出，并返回一个状态。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span></span>;  <span class="comment">// 主线程等待子线程执行完毕。</span></span><br><span class="line"><span class="function"><span class="type">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="type">void</span>)</span></span>;  <span class="comment">// 返回当前线程的Id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化互斥锁, attr通常为NULL</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>; <span class="comment">// 申请互斥锁. 返回错误码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>; <span class="comment">// 释放互斥锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;  <span class="comment">// 销毁互斥锁, 互斥锁释放内存前需手动销毁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化条件变量, attr通常为NULL</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">// 阻塞当前线程，等待条件变量通知。线程唤醒后立即尝试申请锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;  <span class="comment">// 唤醒一个等待条件变量的线程。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;  <span class="comment">// 唤醒所有等待条件变量的线程。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;  <span class="comment">// 销毁条件变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化线程属性对象</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">// 设置线程PTHREAD_CREATE_DETACHED（分离线程）或 PTHREAD_CREATE_JOINABLE（可等待的线程）。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span></span>;  <span class="comment">// 销毁线程等待对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置cpu亲和力, 将线程绑定到指定的 CPU 核心上。</span></span><br><span class="line"><span class="comment">// cpu_set_t 是一个位图类型，每一位表示一个 CPU 核心。可以用CPU_SET(cpu, cpuset)将指定的 CPU 核心（cpu）添加到 cpuset 中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setaffinity_np</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">size_t</span> cpusetsize, <span class="type">const</span> <span class="type">cpu_set_t</span> *cpuset)</span></span>;</span><br><span class="line"><span class="comment">// 获取cpu亲和性</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_getaffinity_np</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">size_t</span> cpusetsize, <span class="type">cpu_set_t</span> *cpuset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程的调度策略和优先级</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setschedparam</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">int</span> policy, <span class="type">const</span> <span class="keyword">struct</span> sched_param *param)</span></span>;</span><br><span class="line"><span class="comment">// 获取线程的调度策略和优先级。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_getschedparam</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">int</span> *policy, <span class="keyword">struct</span> sched_param *param)</span></span>;</span><br></pre></td></tr></table></figure><p><code>int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);</code> 需要传入锁, 表示条件变量等待函数需要先获取锁, 发现条件不满足, 才释放锁进入等待状态。这说明条件变量的设计目的是减少申请锁的冲突, 将不符合条件的线程进入等待，而不是让所有线程都竞争锁。（事实上锁竞争的线程也是忙等待，一般线程没有抢到锁会先执行一段时间的自旋等待，如果还没有抢到锁则进入锁等待队列, 释放锁的线程会唤醒处于锁等待状态的线程）</p><p>如果要单纯的等待-通知, 不用使用锁，可以使用信号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/signalfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sigset_t</span> mask;</span><br><span class="line"><span class="built_in">sigaddset</span>(&amp;mask, SIGUSR1);</span><br><span class="line"><span class="type">int</span> sfd = <span class="built_in">signalfd</span>(<span class="number">-1</span>, &amp;mask, SFD_NONBLOCK);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程等待信号</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">signalfd_siginfo</span> info;</span><br><span class="line"><span class="built_in">read</span>(sfd, &amp;info, <span class="built_in">sizeof</span>(info)); <span class="comment">// 阻塞直到收到信号</span></span><br></pre></td></tr></table></figure><p>pthread利用锁、条件变量和数组模拟的环形缓冲区实现生产者消费者模型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 10  <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义缓冲区和相关变量</span></span><br><span class="line"><span class="type">int</span> buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">int</span> in = <span class="number">0</span>;  <span class="comment">// 指向缓冲区的生产者插入位置</span></span><br><span class="line"><span class="type">int</span> out = <span class="number">0</span>; <span class="comment">// 指向缓冲区的消费者取出位置</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;  <span class="comment">// 互斥锁</span></span><br><span class="line"><span class="type">pthread_cond_t</span> empty;   <span class="comment">// 条件变量，表示缓冲区非空</span></span><br><span class="line"><span class="type">pthread_cond_t</span> full;    <span class="comment">// 条件变量，表示缓冲区非满</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">producer</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        item = <span class="built_in">rand</span>() % <span class="number">100</span>;  <span class="comment">// 生成一个随机项</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);  <span class="comment">// 加锁，访问共享缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果缓冲区满了，等待消费者消费</span></span><br><span class="line">        <span class="keyword">while</span> ((in + <span class="number">1</span>) % BUFFER_SIZE == out) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;empty, &amp;mutex);  <span class="comment">// 等待缓冲区有空位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将项放入缓冲区</span></span><br><span class="line">        buffer[in] = item;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Producer produced: %d\n&quot;</span>, item);</span><br><span class="line">        in = (in + <span class="number">1</span>) % BUFFER_SIZE;  <span class="comment">// 更新生产者插入位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒消费者线程</span></span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;full);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);  <span class="comment">// 解锁</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);  <span class="comment">// 模拟生产的时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">consumer</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);  <span class="comment">// 加锁，访问共享缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果缓冲区为空，等待生产者生产</span></span><br><span class="line">        <span class="keyword">while</span> (in == out) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;full, &amp;mutex);  <span class="comment">// 等待缓冲区有数据</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从缓冲区取出项</span></span><br><span class="line">        item = buffer[out];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Consumer consumed: %d\n&quot;</span>, item);</span><br><span class="line">        out = (out + <span class="number">1</span>) % BUFFER_SIZE;  <span class="comment">// 更新消费者取出位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒生产者线程</span></span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;empty);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);  <span class="comment">// 解锁</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);  <span class="comment">// 模拟消费的时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> producer_thread, consumer_thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁和条件变量</span></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;empty, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;full, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建生产者和消费者线程</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;producer_thread, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;consumer_thread, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(producer_thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(consumer_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁和条件变量</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;empty);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;full);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Producer produced: <span class="number">83</span></span><br><span class="line">Consumer consumed: <span class="number">83</span></span><br><span class="line">Producer produced: <span class="number">86</span></span><br><span class="line">Consumer consumed: <span class="number">86</span></span><br><span class="line">Producer produced: <span class="number">77</span></span><br><span class="line">Producer produced: <span class="number">15</span></span><br><span class="line">Consumer consumed: <span class="number">77</span></span><br><span class="line">Producer produced: <span class="number">93</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>线程cpu绑核，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_function</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> mask;</span><br><span class="line">    <span class="type">pthread_t</span> thread = <span class="built_in">pthread_self</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程的 CPU 亲和性</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">pthread_getaffinity_np</span>(thread, <span class="built_in">sizeof</span>(<span class="type">cpu_set_t</span>), &amp;mask);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pthread_getaffinity_np&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出当前线程可以运行的 CPU 核心</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CPU_SETSIZE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CPU_ISSET</span>(i, &amp;mask)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Thread can run on CPU core: %d\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpuset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;thread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程绑定到 CPU 核心 0 和 1</span></span><br><span class="line">    <span class="built_in">CPU_ZERO</span>(&amp;cpuset);</span><br><span class="line">    <span class="built_in">CPU_SET</span>(<span class="number">0</span>, &amp;cpuset);  <span class="comment">// 允许线程在 CPU 核心 0 上运行</span></span><br><span class="line">    <span class="built_in">CPU_SET</span>(<span class="number">1</span>, &amp;cpuset);  <span class="comment">// 允许线程在 CPU 核心 1 上运行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程的 CPU 亲和性</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">pthread_setaffinity_np</span>(thread, <span class="built_in">sizeof</span>(<span class="type">cpu_set_t</span>), &amp;cpuset);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pthread_setaffinity_np&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Thread can run on CPU core: <span class="number">0</span></span><br><span class="line">Thread can run on CPU core: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>线程调度策略, </p><ol><li>SCHED_FIFO：先来先服务(First-In-First-Out)实时调度, </li><li>SCHED_RR：轮转调度（Round-Robin）实时调度，</li><li>SCHED_OTHER默认的操作系统决定调度线程<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_function</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread running\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sched_param</span> param;</span><br><span class="line">    <span class="type">int</span> policy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;thread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置调度策略为 SCHED_FIFO，并设置优先级为 10</span></span><br><span class="line">    param.sched_priority = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">pthread_setschedparam</span>(thread, SCHED_FIFO, &amp;param);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并输出当前线程的调度策略和优先级</span></span><br><span class="line">    <span class="built_in">pthread_getschedparam</span>(thread, &amp;policy, &amp;param);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread policy: %d, Priority: %d\n&quot;</span>, policy, param.sched_priority);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(thread, <span class="literal">NULL</span>);  <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Thread policy: <span class="number">1</span>, Priority: <span class="number">10</span></span><br><span class="line">Thread running</span><br></pre></td></tr></table></figure></li></ol><h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p>编程语言的赋值一般是原子的，但算术操作不是原子的（需要访存、操作、写回三个操作）。c语言可以直接使用gcc提供的内建原子操作函数, 原子函数在操作函数会加内存屏障，保证常见操作的原子性、可见性。</p><ol><li>__sync_fetch_and_add, 原子地将一个值加到目标变量，返回旧值。</li><li>__sync_fetch_and_sub：原子地目标变量减去一个值，返回旧值。</li><li>__sync_lock_test_and_set：原子地设置一个值，返回旧值。</li></ol><p>原子函数的实现原理</p><ol><li>默认包含一个 ​​完整的顺序一致性屏障（Full Memory Barrier）​​，确保操作前的所有内存访问（读&#x2F;写）在原子操作前完成:操作后的所有内存访问（读&#x2F;写）在原子操作后开始。也就是是原子操作时可以读到最新的旧值, 原子操作后设置的新值其他线程可见</li><li>硬件支持，在 x86&#x2F;x64 架构中，原子操作通常有对应的硬件指令，例如 xchg（Exchange）指令（带 lock 前缀），确保操作的原子性。</li></ol><p>虽然赋值操作是原子的，但C和C++没有java volatile 关键字保证可见性, 因此赋值操作还是要用原子操作__sync_lock_test_and_set。java的volatile关键字可以保证赋值操作的可见性，无须加锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;  <span class="comment">// 用于计数的共享变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">increment</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        __sync_fetch_and_add(&amp;counter, <span class="number">1</span>);  <span class="comment">// 原子地增加 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 10 个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>, increment, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Counter value: %d\n&quot;</span>, counter);  <span class="comment">// 输出最终值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出10000</span></span><br></pre></td></tr></table></figure><p>GCC 4.7+ 引入了更灵活的 __atomic 系列函数，允许显式控制内存顺序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __atomic 版本（可指定内存顺序）</span></span><br><span class="line">type __atomic_exchange_n(type *ptr, type value, <span class="type">int</span> memorder);</span><br></pre></td></tr></table></figure><p>__thread, 是gcc提供的线程局部存储，每个线程操作自己的变量副本，互不影响。</p><ol><li>只能用于全局和静态变量</li><li>​静态初始化​​：变量必须在编译时初始化，且只能为 ​​简单数据类型​​（如 int、float、指针），不支持动态初始化或复杂类型（如结构体、动态数组）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __thread <span class="type">int</span> thread_local_var;  <span class="comment">// 必须为 static 或全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread <span class="type">unsigned</span> <span class="type">long</span> task_count;  <span class="comment">// 线程私有计数器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    task_count++;  <span class="comment">// 无锁操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><h4 id="C-11的并发类"><a href="#C-11的并发类" class="headerlink" title="C++11的并发类"></a>C++11的并发类</h4><p>C++11 提供的并发类主要包括</p><ol><li>std::thread线程, 创建立即执行, 提供join(), detach(), get_id()等方。头文件<code>#include &lt;thread&gt;</code></li><li>std::mutex互斥锁, 提供lock(), unlock(), try_lock(), <code>std::lock_guard&lt;std::mutex&gt;</code>, <code>std::unique_lock&lt;std::mutex&gt;</code>。头文件<code>#include &lt;mutex&gt;</code></li><li>std::condition_variable 条件变量，提供wait(), notify_one(), notify_all()等方法, 头文件<code>#include &lt;condition_variable&gt;</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::thread(Func&amp;&amp; f, Args&amp;&amp;... args)：创建一个线程并开始执行传入的函数 构造函数</span></span><br><span class="line"><span class="comment">// std::thread::join()：等待线程执行完毕。</span></span><br><span class="line"><span class="comment">// std::thread::detach()：将线程与主线程分离。</span></span><br><span class="line"><span class="comment">// std::thread::get_id()， 返回线程id</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_thread_id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::thread::id this_id = std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; this_id &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(print_thread_id)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Main thread ID: <span class="number">140509241898816</span></span><br><span class="line">Thread ID: <span class="number">140509241894656</span></span><br></pre></td></tr></table></figure></li></ol><p>线程同步</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::mutex::lock()</span></span><br><span class="line"><span class="comment">// std::mutex::unlock()</span></span><br><span class="line"><span class="comment">// std::mutex::try_lock()：尝试锁定互斥量</span></span><br><span class="line"><span class="comment">// std::lock_guard&lt;std::mutex&gt; guard(mtx); 自动加锁和释放锁</span></span><br><span class="line"><span class="comment">// std::unique_lock&lt;std::mutex&gt; lck(mtx); 可手动释放锁，若未手动释放则自动释放锁</span></span><br><span class="line"><span class="comment">// std::condition_variable::wait() 阻塞当前线程</span></span><br><span class="line"><span class="comment">// std::condition_variable::notify_one()：通知一个等待的线程。</span></span><br><span class="line"><span class="comment">// std::condition_variable::notify_all()：通知所有等待的线程。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;              <span class="comment">// 共享缓冲区</span></span><br><span class="line">std::mutex mtx;                      <span class="comment">// 互斥锁，保护缓冲区</span></span><br><span class="line">std::condition_variable cv;          <span class="comment">// 条件变量，通知生产者或消费者</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_BUFFER_SIZE = <span class="number">5</span>;       <span class="comment">// 缓冲区最大大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));  <span class="comment">// 模拟生产耗时</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果缓冲区已满，生产者等待</span></span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>() &lt; MAX_BUFFER_SIZE; &#125;);</span><br><span class="line">        buffer.<span class="built_in">push</span>(i);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">150</span>));  <span class="comment">// 模拟消费耗时</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果缓冲区为空，消费者等待</span></span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> !buffer.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">        <span class="type">int</span> item = buffer.<span class="built_in">front</span>();</span><br><span class="line">        buffer.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建生产者和消费者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">producer_thread</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer_thread</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程执行完毕</span></span><br><span class="line">    producer_thread.<span class="built_in">join</span>();</span><br><span class="line">    consumer_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Produced: <span class="number">0</span></span><br><span class="line">Consumed: <span class="number">0</span></span><br><span class="line">Produced: <span class="number">1</span></span><br><span class="line">Consumed: <span class="number">1</span></span><br><span class="line">Produced: <span class="number">2</span></span><br><span class="line">Produced: <span class="number">3</span></span><br><span class="line">Consumed: <span class="number">2</span></span><br><span class="line">Produced: <span class="number">4</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>异步任务</p><ol><li>std::promise和std::future。允诺（Promise）对象，用于在线程中存储一个值或异常，供其他线程通过 future 获取。未来（Future）对象，用于从 promise 中异步获取结果。提供阻塞或非阻塞方式访问数据。头文件<code>#include &lt;future&gt;</code></li><li>std::future和std::async, std::aync 直接传入函数, 返回一个future。该future可以通过get()获取函数返回值。std::async会自动创建异步执行任务</li></ol><p>std::future和std::promise联用，用于线程间传递数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    p.<span class="built_in">set_value</span>(<span class="number">42</span>);  <span class="comment">// 设置 promise 的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 promise 和 future 对象</span></span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; p;   <span class="comment">// 可以存储一个变量</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f = p.<span class="built_in">get_future</span>();  <span class="comment">// 可以从promise中获取存储的变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(set_value, std::ref(p))</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Doing some work in the main thread...\n&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 promise 设置的结果，调用 get() 会阻塞直到线程设置值</span></span><br><span class="line">    <span class="type">int</span> result = f.<span class="built_in">get</span>();  <span class="comment">// 阻塞，直到获取结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The result from promise is: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Doing some work in the main thread...</span><br><span class="line">The result from promise is: <span class="number">42</span></span><br></pre></td></tr></table></figure><p>std::future和std::async联用，获取异步任务执行完成后的返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate_square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::async 启动异步任务，返回一个 std::future 对象</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(std::launch::async, calculate_square, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Doing other work in main thread...\n&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取异步任务的结果，调用 get() 会阻塞，直到结果计算完成</span></span><br><span class="line">    <span class="type">int</span> square = result.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The square of 5 is: &quot;</span> &lt;&lt; square &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在并发处理上，C++20 提供了协程和std::jthread。​jthread​​兼容 std::thread 接口​​和方法，提供了​自动 Join​​：在析构时自动调用 join()，避免未回收线程导致程序终止（传统 std::thread 析构时若未 join() 或 detach() 会触发 std::terminate）。</p><p>C++20 还引入了std::latch, 用于等待线程完成(这种特性加入的也太晚了)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;latch&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::latch <span class="title">completion_latch</span><span class="params">(<span class="number">3</span>)</span></span>;  <span class="comment">// 初始计数器为3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> worker = [&amp;](<span class="type">int</span> id) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; started\n&quot;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        completion_latch.<span class="built_in">count_down</span>();  <span class="comment">// 完成任务，计数器减1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::jthread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(worker, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    completion_latch.<span class="built_in">wait</span>();  <span class="comment">// 主线程等待所有子线程完成</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;All workers completed!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++17 中引入的 std::scoped_lock, 可以一次性锁住多个互斥量，避免死锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 锁定 mtx</span></span><br><span class="line">    <span class="comment">// 操作共享资源...</span></span><br><span class="line">&#125; <span class="comment">// 自动解锁 mtx</span></span><br><span class="line"></span><br><span class="line">std::mutex mtx1, mtx2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx1, mtx2)</span></span>; <span class="comment">// 同时锁定 mtx1 和 mtx2</span></span><br><span class="line">    <span class="comment">// 操作共享资源...</span></span><br><span class="line">&#125; <span class="comment">// 自动解锁 mtx2 和 mtx1（逆序）</span></span><br></pre></td></tr></table></figure><h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><p><code>std::unique_ptr&lt;T&gt;</code>，创建对象时使用，具有对象的所有权。</p><p><code>std::shared_ptr&lt;T&gt;</code>，共享所有权, 使用引用计数维护对象生命周期, 在所有权不明确或对象析构时刻不明确时使用, 尽量使用unique_ptr</p><p><code>std::weak_ptr&lt;T&gt;</code>，弱指针，不维护对象生命周期。当对象处于观察者状态时使用，可通过尝试lock()函数判断对象是否存在，如果存在则访问。当对象A 持有对象B的shared_ptr，同时B又想持有对象A的shared_ptr时，为了避免循环引用，B应当持有A的weak_ptr 。</p><h4 id="C-线程局部变量"><a href="#C-线程局部变量" class="headerlink" title="C++线程局部变量"></a>C++线程局部变量</h4><p>thread_local 是 C++11 引入的关键字, 相比__thread, 前者只能修饰​​简单数据类型​​（如 int、float、指针），thread_local可用于局部变量、全局变量、类成员变量等。性能上两者均接近普通全局变量，无显著差异。</p><p>线程局部变量没有数据竞争，其他线程对变量的修改也不会影响当前线程的变量值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> thread_local_var = <span class="number">0</span>;  <span class="comment">// 声明线程局部变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_function</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    thread_local_var++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld: thread_local_var = %d\n&quot;</span>, (<span class="type">long</span>)arg, thread_local_var);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建多个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>, thread_function, (<span class="type">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Thread <span class="number">0</span>: thread_local_var = <span class="number">1</span></span><br><span class="line">Thread <span class="number">1</span>: thread_local_var = <span class="number">1</span></span><br><span class="line">Thread <span class="number">2</span>: thread_local_var = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> MyClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; <span class="comment">/* 构造函数 */</span> &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; <span class="comment">/* 析构函数 */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">thread_local</span> MyClass obj;  <span class="comment">// 合法，每个线程独立构造/析构</span></span><br></pre></td></tr></table></figure><h4 id="C-11-的原子类"><a href="#C-11-的原子类" class="headerlink" title="C++11 的原子类"></a>C++11 的原子类</h4><p>std::atomic提供了线程安全的原子操作。std::atomic 是一个模板类，支持不同的数据类型（如整数、指针）。常用的方法</p><ol><li>load() 读取原子变量的值。</li><li>store(x) 写入值到原子变量</li><li>fetch_add(x) 和 fetch_sub(x) 原子加减法操作，返回旧值</li><li>exchange(x) 将原子对象的值替换为给定值，并返回旧值</li><li>compare_exchange_weak(expected, desired) 和 compare_exchange_strong(expected, desired) 执行原子比较并交换（CAS，Compare and Swap）操作。expected是当前期望的值，desired是期望修改后的值。返回true表示更新成功，false表示未更新</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> expected = counter.<span class="built_in">load</span>();</span><br><span class="line">        <span class="keyword">while</span> (!counter.<span class="built_in">compare_exchange_strong</span>(expected, expected + <span class="number">1</span>)) &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">yield</span>();  <span class="comment">// 如果失败，线程主动让出 CPU</span></span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; incremented counter to &quot;</span> &lt;&lt; counter.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter value: &quot;</span> &lt;&lt; counter.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Thread <span class="number">1</span> incremented counter to <span class="number">2</span></span><br><span class="line">Thread <span class="number">1</span> incremented counter to <span class="number">3</span></span><br><span class="line">Thread <span class="number">1</span> incremented counter to <span class="number">4</span></span><br><span class="line">Thread <span class="number">1</span> incremented counter to <span class="number">5</span></span><br><span class="line">Thread <span class="number">1</span> incremented counter to <span class="number">6</span></span><br><span class="line">Thread <span class="number">1</span> incremented counter to <span class="number">7</span></span><br></pre></td></tr></table></figure><h4 id="内存序和可见性"><a href="#内存序和可见性" class="headerlink" title="内存序和可见性"></a>内存序和可见性</h4><p>内存序是为了保证多线程在<strong>多核CPU的可见性</strong>，是一种内存屏障。作用和JAVA的volatile类似。</p><ol><li>memory_order_seq_cst 是默认的内存顺序，相当于JAVA的volatile，对原子类的修改操作会立刻刷到内存。</li><li>memory_order_acquire和load连用，memory_order_release和store连用。这个保证，如果某线程执行了store+memory_order_release的操作，在其他线程执行load+memory_order_acquire时，前面的store操作是可见的</li></ol><p>由于C++没有类似java 的volatile关键字（C++的volatile 只是避免编译层的优化的重排序, 只有底层比较hack的代码告知编译期不要优化我hack的代码时才会用到, C++ 编程很少遇到），因此一旦涉及多线程共享变量，要么加锁，要么上原子类（一般不会手动使用内存屏障）。</p><ol><li><p>memory_order_relaxed：不保证任何顺序，只提供原子性，一般不会使用</p></li><li><p>memory_order_consume：保证在该原子操作之后的所有依赖操作的顺序, 这个类似memory_order_acquire, 比 memory_order_acquire 更轻量，但适用范围更窄, 只保证依赖原子类的顺序。<br>以下常用</p></li><li><p>memory_order_acquire：保证acquire之后的操作实际也在该操作后执行,不会重排序到操作之前，常修饰load操作</p></li><li><p>memory_order_release：保证release之前的所有操作在该操作前执行,不会重排序到操作之后，常修饰store操作<br>store+memory_order_release 和load+memory_order_acquire 保证写之后读之前是有序的。写-读是一个pair。release-acquire之间不是原子类的操作, 也会保证有序性。</p></li><li><p>memory_order_acq_rel：同时具备获取和释放语义,用来修饰load+store操作,如fetch_add</p></li><li><p>memory_order_seq_cst：保证严格的顺序一致性，即原子类变量多线程并发执行和单线程循环执行顺序完全一致, 原子类默认内存序</p></li></ol><p>内存序本身不提供“线程必须等待其他线程写了数据，才可以读”这样的同步语义，需要使用一个load循环，直到load数据。它能保证的是，只要某个线程store了数据，其他线程立刻可以load到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data.<span class="built_in">store</span>(<span class="number">42</span>, std::memory_order_relaxed);  <span class="comment">// 写入数据</span></span><br><span class="line">    ready.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);  <span class="comment">// 通知消费者</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!ready.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;  <span class="comment">// 等待生产者通知</span></span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>();  <span class="comment">// cpu从当前线程切走, 但线程不会进入等待队列，后面还可能被cpu调度</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Consumer read data: &quot;</span> &lt;&lt; data.<span class="built_in">load</span>(std::memory_order_relaxed) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-的lambda表达式和函数类型"><a href="#C-的lambda表达式和函数类型" class="headerlink" title="C++的lambda表达式和函数类型"></a>C++的lambda表达式和函数类型</h4><p>Lambda 是一种匿名闭包对象，​​每个 Lambda 表达式的类型都是唯一的闭包类型​​，无法显式声明，但可以通过 auto 或 decltype 推导。</p><p><code>std::function&lt;ReturnType(Args...)&gt;</code>可用来存储可调用对象，如函数对象，lambda表达式等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加不同类型的可调用对象</span></span><br><span class="line">    tasks.<span class="built_in">push_back</span>([]&#123; std::cout &lt;&lt; <span class="string">&quot;Task 1&quot;</span>; &#125;);   <span class="comment">// Lambda</span></span><br><span class="line">    tasks.<span class="built_in">push_back</span>(&amp;some_function);                 <span class="comment">// 函数指针</span></span><br><span class="line">    tasks.<span class="built_in">push_back</span>(Functor&#123;&#125;);                      <span class="comment">// 仿函数, 实现operator()的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; task : tasks) &#123;</span><br><span class="line">        <span class="built_in">task</span>();  <span class="comment">// 统一调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>C++异常处理基于三个关键字：try、catch、throw。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">double</span> result = <span class="built_in">divide</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::runtime_error&amp; e) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="built_in">catch</span> (...) &#123; <span class="comment">// 捕获所有异常</span></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Unknown error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常处理的缺陷</p><ol><li><p>栈展开Stack Unwinding，抛出异常时，<strong>编译器需生成回溯调用栈，逐个退出函数作用域的逻辑</strong>，调用局部对象的析构函数，直到找到匹配的 catch 块。</p></li><li><p>编译器需为每个 try 块生成额外的元数据（如异常表），增加二进制文件体积。</p></li><li><p>异常改变了代码的显式执行路径，错误处理逻辑分散在 catch 块中，而非就近处理。</p></li><li><p>C++推荐使用错误码来进行错误处理，无额外性能开销；错误处理需要保证资源释放</p></li><li><p>如果调用的函数可能抛出异常，那么调用者需要捕获，防止程序崩溃。</p></li></ol><p>C++ noexcept关键字指定函数不抛异常，编译器可能为 noexcept 函数生成更精简的代码（无需准备栈展开逻辑）。析构函数和移动构造&#x2F;赋值函数默认是noexcept函数。若 noexcept 函数意外抛异常，程序直接终止。</p><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><h4 id="JAVA-并发类"><a href="#JAVA-并发类" class="headerlink" title="JAVA 并发类"></a>JAVA 并发类</h4><p>Thread类，继承 Thread 类并重写其 run() 方法，实现多线程。JAVA原生支持, 不需要import 库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread is running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 Runnable 接口并重写 run() 方法, 实现多线程。不需要import 库</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Runnable thread is running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Callable和FutureTask接口，与 Runnable 类似，但可以返回结果和抛出异常。需要import java.util.concurrent.Callable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;  <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Result: &quot;</span> + futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池类, Executor 和 ExecutorService。C++标准库里没有线程池类, 需要引用第三方库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        executor.execute(() -&gt; System.out.println(<span class="string">&quot;Task 1&quot;</span>));</span><br><span class="line">        executor.execute(() -&gt; System.out.println(<span class="string">&quot;Task 2&quot;</span>));</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Task <span class="number">1</span></span><br><span class="line">Task <span class="number">2</span></span><br></pre></td></tr></table></figure><p>CountDownLatch, latch计数器，用于等待其他线程完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; finished task&quot;</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line"></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;All tasks finished&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal，线程内部变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            threadLocal.set(threadLocal.get() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; value: &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized 锁, Java 内置的关键字，可用于方法或代码块, 用于线程同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步方法,整个方法需要互斥执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is executing&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同步对象，整个this对象需要互斥执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is executing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) counter.increment();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) counter.increment();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + counter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>java提供volatile关键字保证变量的可见性, volatile关键字实现<strong>如果某线程只对变量进行赋值或读取操作，操作时不需要加锁</strong>。对于volatile使用场景, C++一般要使用原子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopTask</span><span class="params">()</span> &#123;</span><br><span class="line">        running = <span class="literal">false</span>; <span class="comment">// 设置为线程终止标志, 其他线程修改后立即可见, 不需要加锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="comment">// 执行任务...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;                    <span class="comment">// 第一次检查无锁, 使用volatile保证第一次检查时的可见性</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;            <span class="comment">// 第二次检查</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();    <span class="comment">// volatile禁止重排序</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程安全数据结构"><a href="#线程安全数据结构" class="headerlink" title="线程安全数据结构"></a>线程安全数据结构</h4><p>JAVA提供了一些并发安全的数据结构，位于java.util.concurrent包中。C++标准库不提供线程安全结构, 需要第三方库。</p><ol><li>ConcurrentHashMap<br>线程安全的哈希表实现，支持高效的并发读写。它将内部数据分割为多个段，每个段一个锁，可以减少锁竞争。</li><li>CopyOnWriteArrayList<br>线程安全的 List 实现</li><li>BlockingQueue<br>线程安全的队列接口，通常用于生产者-消费者模型。</li></ol><p>java.util中的HashMap，ArrayList，LinkedList等都是非并发安全的</p><h4 id="JAVA多线程和虚拟机"><a href="#JAVA多线程和虚拟机" class="headerlink" title="JAVA多线程和虚拟机"></a>JAVA多线程和虚拟机</h4><p>相比C&#x2F;C++ 多线程通过pthread直接在linux操作系统中起进程，JAVA的多线程需要经过JAVA虚拟机这一层。</p><p>java虚拟机维护了JavaThread结构，JVM是C++实现的。所以JavaThread是C++定义的类。JavaThread维护了线程的状态，一个指针指向java.lang.Thread创建的对象(oop)，另一个指针指向对应的操作系统创建的OSThread</p><p>java线程模型的实现取决于jvm虚拟机，只要jvm愿意，可以选择类似go使用协程来实现线程。但以市场占有率最大的HotSpot虚拟机举例，一个java线程都是直接映射到操作系统的原生线程来实现的，所有的线程调度都是由操作系统完成的。</p><h4 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h4><p>volatile 关键字可以实现变量的可见性，但不提供原子性。 JAVA常见的原子类有 AtomicInteger、AtomicLong、AtomicBoolean、AtomicReference</p><p>.set()设置值, .get()获取值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">        atomicInt.set(<span class="number">10</span>);          <span class="comment">// 设置值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Value: &quot;</span> + atomicInt.get());        <span class="comment">// 获取值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Incremented: &quot;</span> + atomicInt.incrementAndGet());    <span class="comment">// 增加并获取</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> atomicInt.compareAndSet(<span class="number">15</span>, <span class="number">100</span>);          <span class="comment">// 比较并设置</span></span><br><span class="line">        System.out.println(<span class="string">&quot;CAS Success: &quot;</span> + success + <span class="string">&quot;, New Value: &quot;</span> + atomicInt.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Value: <span class="number">10</span></span><br><span class="line">Incremented: <span class="number">11</span></span><br><span class="line">CAS Success: <span class="literal">false</span>, New Value: <span class="number">11</span></span><br></pre></td></tr></table></figure><h4 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h4><p>java 的推荐使用异常处理，因此函数调用者需要通过try-catch-finally结构来捕获异常，防止程序崩溃。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;文件未找到: &quot;</span> + e.getMessage());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论是否发生异常，都会执行的代码（如资源释放）</span></span><br><span class="line">    <span class="keyword">if</span> (file != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java 函数可以加throws关键字，声明该方法可能抛出的 ​​受检异常（Checked Exceptions）​​，函数调用者必须处理异常，否则编译器报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException, IOException &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line">    <span class="comment">// 其他操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><h4 id="并发实现"><a href="#并发实现" class="headerlink" title="并发实现"></a>并发实现</h4><p>Golang 在语言层面使用协程实现并发，Go内置协程调度器，能自动在协程阻塞时将协程挂起。Golang的线程是无阻塞的，这意味Golang线程不能使用线程阻塞的系统调用。</p><p>GMP调度器, Go调度器基于 ​​G（Goroutine）、M（Machine）、P（Processor）​​ 三者的协作：</p><ol><li>​G（Goroutine）​​：轻量级协程，初始栈仅2KB（可动态扩缩），创建和切换成本极低。</li><li>​​M（Machine）​​：对应操作系统的线程（OS Thread），负责实际执行代码。</li><li>P（Processor）​​：逻辑处理器（调度器），管理一组本地队列（存储待运行的Goroutines）。P的数量默认等于CPU核心数（可通过GOMAXPROCS调整）。</li></ol><p>Goroutine 的创建与执行​</p><ol><li>每个协程（G）由Go运行时创建，并被分配到某个P的本地队列。</li><li>M需要绑定一个P才能执行Goroutines。</li><li>当P的本地队列为空时，会从全局队列或其他P的队列中​​窃取Goroutines​​（Work Stealing）。</li></ol><p>Golang的线程不会执行任何阻塞的系统调用, 当协程阻塞时，协程主动让出执行权，M会释放绑定的P，P转去服务其他M。系统调用完成后，G尝试获取新的P继续执行（若无可用P，则G进入全局队列）。</p><p>Go运行时有专门的​​网络轮询器（NetPoller）​​，将阻塞的G挂起，待IO就绪后唤醒，避免占用M。</p><p>一个Go程序可轻松创建数十万个Goroutines，而同等规模的OS线程会耗尽资源。M的数量由调度器动态管理（通常远少于Goroutines的数量），避免频繁创建&#x2F;销毁OS线程。</p><p>golang提供sync.WaitGroup等待协程运行完, 相当于latch。golang的无缓冲channel 可以用来实现阻塞-等待，有缓冲channel可以用来当任务队列。golang利用channel可以实现顺序性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>, wg sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">item := rand.Intn(<span class="number">100</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;Produced:&quot;</span>, item)</span><br><span class="line">ch &lt;- item              <span class="comment">// 发送数据到channel</span></span><br><span class="line">time.Sleep(time.Second) <span class="comment">// 模拟生产过程的延迟</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">int</span>, wg sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> item := <span class="keyword">range</span> ch &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Consumed:&quot;</span>, item)</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">// 模拟消费过程的延迟</span></span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="comment">// 创建一个缓冲区大小为 5 的channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动多个消费者</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> consumer(ch, wg)</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动一个生产者</span></span><br><span class="line"><span class="keyword">go</span> producer(ch, wg)</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主程序运行一段时间后退出</span></span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Produced: <span class="number">63</span></span><br><span class="line">Consumed: <span class="number">63</span></span><br><span class="line">Produced: <span class="number">47</span></span><br><span class="line">Consumed: <span class="number">47</span></span><br><span class="line">Produced: <span class="number">47</span></span><br><span class="line">Consumed: <span class="number">47</span></span><br><span class="line">Produced: <span class="number">99</span></span><br><span class="line">Consumed: <span class="number">99</span></span><br><span class="line">Produced: <span class="number">51</span></span><br><span class="line">Consumed: <span class="number">51</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>for range语句可以用来遍历channel的数组，直到channel被close。select 语句可以等待接收多个channel的数据，只要有一个channel写入了数据，select就会执行处理函数并退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch &lt;- <span class="number">42</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg := &lt;-ch:</span><br><span class="line">fmt.Println(<span class="string">&quot;Received:&quot;</span>, msg)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second): <span class="comment">// 1秒后超时, select执行fmt.Println(&quot;Timeout!&quot;)</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Timeout!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Received: <span class="number">42</span></span><br></pre></td></tr></table></figure><p>sync.Mutex，互斥锁。sync.RWMutex 读写锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">counter <span class="type">int</span></span><br><span class="line">mu      sync.Mutex <span class="comment">// 创建一个互斥锁</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加计数器的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">counter++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动多个 goroutine 来增加计数器</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">increment()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待所有 goroutine 执行完毕</span></span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Final counter:&quot;</span>, counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">data   <span class="type">int</span></span><br><span class="line">rwMutex sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">rwMutex.RLock()</span><br><span class="line"><span class="keyword">defer</span> rwMutex.RUnlock()</span><br><span class="line"><span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(value <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">rwMutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> rwMutex.Unlock()</span><br><span class="line">data = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动多个读 goroutine</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Printf(<span class="string">&quot;Reader %d: data = %d\n&quot;</span>, i, read())</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动一个写 goroutine</span></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">write(<span class="number">42</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;Writer: data updated&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">wg.Wait() <span class="comment">// 等待所有 goroutine 完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync.Once 确保函数只执行一次，无论是多次调用还是多线程多次执行。可用来实现单例模式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 单例对象的字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    instance *Singleton</span><br><span class="line">    once     sync.Once</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        instance = &amp;Singleton&#123;</span><br><span class="line">            <span class="comment">// 初始化字段</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync.Cond 条件变量，执行条件变量wait前需要持有锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func</span> (b *Buffer) <span class="built_in">Produce</span>(item <span class="type">int</span>) &#123;</span><br><span class="line">b.lock.<span class="built_in">Lock</span>()</span><br><span class="line">defer b.lock.<span class="built_in">Unlock</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">for</span> <span class="title">len</span><span class="params">(b.data)</span> </span>== bufferSize &#123;</span><br><span class="line">b.cond.<span class="built_in">Wait</span>()</span><br><span class="line">&#125;</span><br><span class="line">b.data = <span class="built_in">append</span>(b.data, item)</span><br><span class="line">fmt.<span class="built_in">Println</span>(<span class="string">&quot;Produced:&quot;</span>, item)</span><br><span class="line"></span><br><span class="line">b.cond.<span class="built_in">Signal</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原子操作-1"><a href="#原子操作-1" class="headerlink" title="原子操作"></a>原子操作</h4><p>sync&#x2F;atomic 包提供了多种原子操作函数，</p><ol><li>AddInt32, <code>func AddInt32(addr *int32, delta int32) (new int32)</code>原子地将一个 int32 值加上一个指定的值。返回操作后的 ​​新值​​</li><li>CompareAndSwapInt32, <code>func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</code> 原子地比较并交换 int32 值。如果当前值等于预期值，则将其更改为新值。返回是否更改</li><li>LoadInt32, <code>func LoadInt32(addr *int32) (val int32)</code> 原子地读取一个 int32 值。</li><li>StoreInt32, <code>func StoreInt32(addr *int32, val int32)</code> 原子地写入一个 int32 值。</li></ol><p>例子, 无锁计数器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter <span class="type">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">    atomic.AddInt64(&amp;counter, <span class="number">1</span>) <span class="comment">// 无需关心返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> atomic.LoadInt64(&amp;counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自旋锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lock <span class="type">int32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acquireLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> !atomic.CompareAndSwapInt32(&amp;lock, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 自旋等待</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">releaseLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    atomic.StoreInt32(&amp;lock, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Context-协程生命周期管理"><a href="#Context-协程生命周期管理" class="headerlink" title="Context 协程生命周期管理"></a>Context 协程生命周期管理</h4><p>channel用来协程间通信，而Context主要用来管理协程的生命周期。</p><h4 id="异常处理-2"><a href="#异常处理-2" class="headerlink" title="异常处理"></a>异常处理</h4><p>panic用来抛出异常，recover用来捕获异常。<br>panic，</p><ol><li>运行时错误自动触发​​：例如数组越界、空指针解引用等。</li><li>​主动调用 <code>panic(v)</code>​​：开发者可手动抛出任意类型的值（通常是 <code>error</code> 或 <code>string</code>）。</li></ol><p>行为</p><ol><li>立即​​终止当前函数​​的执行。</li><li>​逐层向上回溯调用栈​​，执行每个函数的 <code>defer</code> 语句。</li><li>若未被 <code>recover</code> 捕获，最终​<strong>​程序崩溃​</strong>​并打印堆栈信息。</li></ol><p>recover：捕获异常​​</p><ol><li>​必须在 defer 函数中调用​​：recover 仅在 defer 上下文中生效。</li><li>​仅在发生 panic 后生效​​：若无 panic，recover 返回 nil。</li></ol><p>Go 的设计者觉得 <code>try/catch</code> 机制的使用太泛滥了，而且<strong>从底层向更高的层级抛异常太耗费资源</strong>。他们给 Go 设计的机制也可以“捕捉”异常，但是更轻量，并且只应该作为（处理错误的）最后的手段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">riskyOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;something went wrong!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">safeOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">defer <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != nil &#123;</span><br><span class="line">fmt.<span class="built_in">Println</span>(<span class="string">&quot;Recovered from panic:&quot;</span>, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">riskyOperation</span>() <span class="comment">// 触发 panic</span></span><br><span class="line">fmt.<span class="built_in">Println</span>(<span class="string">&quot;This line will NOT be executed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="built_in">main</span>() &#123;</span><br><span class="line"><span class="built_in">safeOperation</span>()</span><br><span class="line">fmt.<span class="built_in">Println</span>(<span class="string">&quot;Program continues normally&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Recovered from panic: something went wrong!</span><br><span class="line">Program continues normally</span><br></pre></td></tr></table></figure><p>golang推荐使用error错误码来处理错误，产生错误的函数会返回两个变量，一个值和一个错误码；如果后者是 <code>nil</code> 就是成功，非 <code>nil</code> 就是发生了错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> value, err := pack1.Func1(param1); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Error %s in pack1.Func1 with parameter %v&quot;</span>, err.Error(), param1)</span><br><span class="line"><span class="keyword">return</span>    <span class="comment">// or: return err</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Process(value)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义错误码</span></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code    <span class="type">int</span></span><br><span class="line">    Message <span class="type">string</span></span><br><span class="line">    Details <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;code=%d, msg=%s&quot;</span>, e.Code, e.Message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProcessRequest</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyError&#123;</span><br><span class="line">        Code:    <span class="number">400</span>,</span><br><span class="line">        Message: <span class="string">&quot;invalid request&quot;</span>,</span><br><span class="line">        Details: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;field&quot;</span>: <span class="string">&quot;username&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><h4 id="多线程和多进程"><a href="#多线程和多进程" class="headerlink" title="多线程和多进程"></a>多线程和多进程</h4><p>Python 的 Cpython有一个全局解释器锁（GIL）。这意味着在任何时刻，只有一个线程可以执行 Python 字节码。这简化了python的多线程管理，GIL​​单条字节码指令是原子操作​​。向x &#x3D; 42, shared_list.append(item) 是线程安全的。但这让Python的多线程只能利用到单核。</p><p>虽然Python可以使用多进程，但多进程之间是独立的地址空间，难以访问共享变量，使用比较难受。因此threading 多线程模块是python常用的并发模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_numbers</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程</span></span><br><span class="line">thread1 = threading.Thread(target=print_numbers)</span><br><span class="line">thread2 = threading.Thread(target=print_numbers)</span><br><span class="line"><span class="comment"># 创建进程</span></span><br><span class="line">process1 = multiprocessing.Process(target=print_numbers)</span><br><span class="line">process2 = multiprocessing.Process(target=print_numbers)</span><br><span class="line"></span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line">process1.start()</span><br><span class="line">process2.start()</span><br><span class="line"></span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line">process1.join()</span><br><span class="line">process2.join()</span><br></pre></td></tr></table></figure><p>线程锁和条件变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.value = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">increment</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="variable language_">self</span>.lock:  <span class="comment"># 自动加锁/解锁</span></span><br><span class="line">            <span class="variable language_">self</span>.value += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cond = threading.Condition()</span><br><span class="line">shared_data = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>():</span><br><span class="line">    <span class="keyword">with</span> cond:  <span class="comment"># 自动加锁</span></span><br><span class="line">        shared_data.append(<span class="number">42</span>)</span><br><span class="line">        cond.notify()  <span class="comment"># 通知消费者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>():</span><br><span class="line">    <span class="keyword">with</span> cond:  <span class="comment"># 自动加锁</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> shared_data:</span><br><span class="line">            cond.wait()  <span class="comment"># 自动释放锁并等待，唤醒后重新加锁</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Received:&quot;</span>, shared_data.pop())</span><br></pre></td></tr></table></figure><p>线程池，concurrent.futures.ThreadPoolExecutor</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_square</span>(<span class="params">number</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Square of <span class="subst">&#123;number&#125;</span> is <span class="subst">&#123;number * number&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个线程池，最多允许 5 个线程同时执行</span></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="comment"># 提交任务给线程池</span></span><br><span class="line">    executor.submit(print_square, <span class="number">2</span>)</span><br><span class="line">    executor.submit(print_square, <span class="number">3</span>)</span><br><span class="line">    executor.submit(print_square, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h4 id="生成器和协程"><a href="#生成器和协程" class="headerlink" title="生成器和协程"></a>生成器和协程</h4><p>生成器。python生成器是一种无栈协程，可以实现手动切换执行流。普通函数可以 yield 语句返回生成器，普通函数执行到yield后会转向执行接收yield返回值的函数，当再执行next()，线程回到原先的函数继续执行。</p><p>使用next() 和 send() 方法可以控制生成器的执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">simple_gen</span>():</span><br><span class="line">    value = <span class="keyword">yield</span> <span class="string">&quot;Ready&quot;</span>  <span class="comment"># 初始返回值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Received:&quot;</span>, value)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;End&quot;</span></span><br><span class="line"></span><br><span class="line">gen = simple_gen()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 第一次执行生成器，收到&quot;Ready&quot;</span></span><br><span class="line"><span class="built_in">print</span>(gen.send(<span class="number">42</span>))  <span class="comment"># 执行流再次切换到simple_gen，simple_gen执行到&quot;End</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Ready</span><br><span class="line">(<span class="string">&#x27;Received:&#x27;</span>, <span class="number">42</span>)</span><br><span class="line">End</span><br></pre></td></tr></table></figure><p>asyncio 是python3提供的无栈协程模块，内部实现了事件循环。</p><ol><li>async 用于定义协程函数，await 用于暂停协程并等待另一个协程完成。async定义的协程函数中不能调用可能导致线程阻塞或者等待的函数，包括阻塞读写、线程锁、sleep等。</li><li>await 后面跟的是io耗时的操作，表示把线程从当前协程切换走；同时await会注册事件通知，当耗时的操作执行完时，调度器会回来再执行当前协程</li></ol><p>await 同时维护了执行的先后顺序，对于async函数A await aysnc函数B，则必须等待B执行完函数A才会继续执行。这个执行逻辑避免了回调地狱，即<strong>对于回调函数链路A-&gt;B-&gt;C，可以直接在A里面写await B, B里面写 await C</strong>，代码更加简洁易懂</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task_1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Task 1 starts&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Task 1 ends&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task_2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Task 2 starts&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> task_1()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Task 2 ends&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并发执行两个任务</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(task_1(), task_2())  <span class="comment"># 需等待所有task执行完</span></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Task <span class="number">1</span> starts</span><br><span class="line">Task <span class="number">2</span> starts</span><br><span class="line">Task <span class="number">1</span> starts</span><br><span class="line">Task <span class="number">1</span> ends</span><br><span class="line">Task <span class="number">1</span> ends</span><br><span class="line">Task <span class="number">2</span> ends</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> base </category>
          
      </categories>
      
      
        <tags>
            
            <tag> language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程语言(3)—数据结构和算法</title>
      <link href="/2024/12/10/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(3)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2024/12/10/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(3)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>数据结构(容器)库和算法库是最基础的库之一。字符串是人类语言的记录，是计算机处理的主要对象。</p><span id="more"></span><h3 id="C和C"><a href="#C和C" class="headerlink" title="C和C++"></a>C和C++</h3><p>由于C语言不提供数据结构和算法库，这里专指C++的STL stand template library。</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>std::array，静态数组，编译时确定数组长度，数组创建在栈。相当于C语言的<code>int[2] = &#123;1,2&#125;</code></p><p>std::vector，动态数组，可动态扩展大小。当 size() 即将超过 capacity() 时，vector 会自动分配更大的内存空间（一般是翻倍），并将原有元素​​移动或复制​​到新空间。<br>因此std::vector会有迭代器失效的问题，需要及时重新获取迭代器。</p><p>数组随机访问和更新效率高，为O(1)，但随机插入删除低。适合大量访问少量插入删除的场景。vector建议使用.at(x)索引元素，具有边界检查，如果越界会抛出异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出：1 2 3 4 5 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; vec[<span class="number">2</span>] &lt;&lt; std::endl;  <span class="comment">// 访问元素 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::list 是双向链表，能高效插入或删除元素，但随机访问效率低。适合维护不需要大量随机访问和更新的结构（即不需要用vector的都建议上链表）。例如队列，环形buffer等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; lst = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    lst.<span class="built_in">push_back</span>(<span class="number">6</span>);  <span class="comment">// 在末尾插入元素</span></span><br><span class="line">    lst.<span class="built_in">push_front</span>(<span class="number">0</span>); <span class="comment">// 在头部插入元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : lst) &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出：0 1 2 3 4 5 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::deque 是双端队列，使用链接起来的若干内存块构成。deque的头部和尾部可以进行高效的插入和删除操作，同时也提供随机访问接口，但随机访问比vector慢。deque实现复杂，实际应该少用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; deq = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    deq.<span class="built_in">push_back</span>(<span class="number">6</span>);   <span class="comment">// 在尾部添加元素</span></span><br><span class="line">    deq.<span class="built_in">push_front</span>(<span class="number">0</span>);  <span class="comment">// 在头部添加元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : deq) &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出：0 1 2 3 4 5 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::stack​​是可以传入底层容器的配接器，默认底层容器是std::deque，但可以指定底层容器为std::vector。同样std::queue也是个配接器，默认底层容器是std::deque，但可以指定底层容器为std::list。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;T&gt; s;                   <span class="comment">// 默认使用 deque</span></span><br><span class="line">std::stack&lt;T, std::vector&lt;T&gt;&gt; s;    <span class="comment">// 显式指定 vector 作为底层容器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::stack&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">s<span class="number">1.</span><span class="built_in">push</span>(<span class="number">1</span>);                     <span class="comment">// 压栈</span></span><br><span class="line"><span class="type">int</span> top = s<span class="number">1.</span><span class="built_in">top</span>();             <span class="comment">// 访问栈顶（1）</span></span><br><span class="line">s<span class="number">1.</span><span class="built_in">pop</span>();                       <span class="comment">// 弹栈</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 list 作为底层容器</span></span><br><span class="line">std::queue&lt;<span class="type">int</span>, std::list&lt;<span class="type">int</span>&gt;&gt; q2;</span><br><span class="line">q<span class="number">2.</span><span class="built_in">push</span>(<span class="number">2</span>);                     <span class="comment">// 入队</span></span><br><span class="line">q<span class="number">2.</span><span class="built_in">pop</span>();                       <span class="comment">// 出队</span></span><br></pre></td></tr></table></figure><p>std::set 是一个​​有序关联容器​​，基于红黑树（平衡二叉搜索树）实现，元素会自动排序且不允许重复，CRUD复杂度都是O(logn)。unordered_set 是一个不排序的集合，基于哈希表实现, 复杂度为O(1)，但会面临哈希碰撞和rehash的问题。</p><p>std::set 创建需要传入comparator (operator &lt;，即<code>Less&lt;T&gt;</code>升序排列)。而std::unordered_set需要提供hash function和operator&#x3D;&#x3D;。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按字符串长度排序</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LengthCompare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string&amp; a, <span class="type">const</span> std::string&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">length</span>() &lt; b.<span class="built_in">length</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">std::set&lt;std::string, LengthCompare&gt; s;</span><br><span class="line"><span class="keyword">auto</span> comp = [](<span class="type">const</span> std::string&amp; a, <span class="type">const</span> std::string&amp; b) &#123; <span class="keyword">return</span> a &lt; b; &#125;</span><br><span class="line"><span class="function">std::set&lt;T, <span class="title">decltype</span><span class="params">(comp)</span>&gt; <span class="title">my_set</span><span class="params">(comp)</span></span>;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="string">&quot;banana&quot;</span>); <span class="comment">// &quot;apple&quot;（长度 5）排在 &quot;banana&quot;（长度 6）之前</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PersonHash</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">hash</span>&lt;std::string&gt;()(p.name) ^ std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(p.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PersonEqual</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; a, <span class="type">const</span> Person&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.name == b.name &amp;&amp; a.age == b.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::unordered_set&lt;Person, PersonHash, PersonEqual&gt; s2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> hash = [](<span class="type">const</span> T&amp; key) &#123; <span class="comment">/* 返回哈希值 */</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> equal = [](<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b) &#123; <span class="comment">/* 返回是否相等 */</span> &#125;;</span><br><span class="line"><span class="function">std::unordered_set&lt;T, <span class="title">decltype</span><span class="params">(hash)</span>, <span class="title">decltype</span><span class="params">(equal)</span>&gt; <span class="title">s3</span><span class="params">(hash, equal)</span></span>;</span><br></pre></td></tr></table></figure><p>哈希表的元素个数除以哈希表长度是哈希表的负载因子load factor。当负载超过负载因子时，哈希表会自动进行扩容。</p><ol><li>计算新桶数量​​：新桶数量通常为不小于 size() &#x2F; max_load_factor() 的质数。</li><li>​​重新分配桶数组​​：分配新桶数组</li><li>​​重新哈希所有元素​​：将所有元素重新插入到新桶中</li><li>最后释放旧桶数组<br>rehash期间hash表会停止工作, rehash完毕后旧的迭代器会失效</li></ol><p>数组和unorder_set&#x2F;unorder_map使用时建议预分配空间（reserve）以减少重新分配。</p><p>map类似set，只是元素是键值对pair，根据键进行排序。unordered_map类似unordered_set，是一个无序映射，使用哈希表进行存储。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::string&gt; um = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="number">3</span>, <span class="string">&quot;three&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : um) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++ STL使用迭代器来标识容器中的元素，以及实现容器中元素的访问。迭代器支持重载<code>*</code>和<code>-&gt;</code>运算符来解引用或访问元素成员变量</p><ol><li>随机访问迭代器 (Random Access Iterator)，类似指针，通过加减算数提供随机访问。对应容器<code>std::vector、std::deque、std::array</code>。支持随机访问迭代器作为参数的算法函数，一般也支持指针作为参数。</li><li>双向迭代器(Bidirectional Iterator)，允许在容器中向前和向后移动。对应容器<code>std::list、std::set、std::map。</code></li></ol><p>迭代器是使用继承结构组织的，随机访问迭代器也是一种双向迭代器</p><p>.begin(), .end() 分别代表首尾迭代器</p><h4 id="算法库algorithm"><a href="#算法库algorithm" class="headerlink" title="算法库algorithm"></a>算法库algorithm</h4><p>std::sort 对容器中的元素进行排序，默认升序。sort可以用std::less和std::greater 进行降序和升序排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">// 默认使用 std::less&lt;int&gt;</span></span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a &gt; b; &#125;); <span class="comment">// 降序</span></span><br></pre></td></tr></table></figure><p>std::sort 内部实现原理,</p><ol><li>快速排序（Quicksort）​​：作为主要排序算法，处理大规模数据。</li><li>​​堆排序（Heapsort）​​：在快速排序递归深度过大时触发，避免最坏情况下的 O(n²) 时间复杂度。</li><li>插入排序（Insertion Sort）​​：在小规模子数组（通常 ≤16 个元素）时使用，减少递归开销。</li></ol><p>常见排序算法的稳定性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">排序算法最佳时间复杂度平均时间复杂度最坏时间复杂度空间复杂度稳定性原地排序备注</span><br><span class="line">​​冒泡排序​​O(n)        O(n²)    O(n²)    O(1)        稳定是优化后可提前终止（如无交换时停止）。</span><br><span class="line">​​选择排序​​O(n²)        O(n²)    O(n²)    O(1)        不稳定是每次选择最小/最大元素交换。</span><br><span class="line">​​插入排序​​O(n)        O(n²)    O(n²)    O(1)        稳定是对部分有序数据效率高。</span><br><span class="line">​​希尔排序​​O(n log n)    O(n^(3/2))O(n²)    O(1)        不稳定是基于插入排序的改进，间隔序列影响性能。</span><br><span class="line">​​归并排序​​O(n log n)    O(n log n)O(n log n)O(n)        稳定否分治思想，需额外空间合并。</span><br><span class="line">​​快速排序​​O(n log n)    O(n log n)O(n²)    O(log n) ~ O(n)不稳定是基于分治和分区操作，平均性能最优。</span><br><span class="line">​​堆排序​​    O(n log n)    O(n log n)O(n log n)O(1)        不稳定是利用堆结构排序，适合大规模数据。</span><br><span class="line">​​计数排序​​O(n + k)    O(n + k)O(n + k)O(n + k)     稳定否适用于整数且范围较小的数据（k为数据范围）。</span><br><span class="line">​​桶排序​​    O(n + k)    O(n + k)O(n²)    O(n + k)     稳定否数据均匀分布时高效，依赖桶的数量和分布。</span><br><span class="line">​​基数排序​​O(d(n + k))    O(d(n + k))O(d(n + k))O(n + k)     稳定否按位排序（d为位数，k为基数大小），通常用于整数或字符串。</span><br></pre></td></tr></table></figure><p>std::sort是不稳定的，std::stable_sort提供稳定排序，即保证相同元素的相对顺序。内部实现原理是基于 ​​归并排序（Merge Sort）​​ 的变体，并结合优化策略以优化空间。</p><p>std::find查找容器中的某个元素，返回第一个匹配元素的迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// 找到了元素</span></span><br><span class="line">&#125;</span><br><span class="line">it == vec.<span class="built_in">end</span>();  <span class="comment">// 未找到元素</span></span><br></pre></td></tr></table></figure><p>std::lower_bound，传入排序好的数组，返回<strong>第一个大于或等于指定元素</strong>的迭代器。<br>std::upper_bound：返回指向已排序数组中<strong>第一个大于指定元素的迭代器</strong>。<br>需要随机访问迭代器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">lower_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">upper_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>std::reverse, 反转容器中的元素顺序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">reverse</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>std::fill, 将容器中的所有元素设置为指定值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>std::transform, 对容器中的每个元素应用指定的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">transform</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), vec.<span class="built_in">begin</span>(), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;);</span><br></pre></td></tr></table></figure><p>std::copy：将容器中的元素复制到另一个容器。std::swap, 交换两个容器的内容。std::move, 移动容器，避免复制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">copy</span>(vec, dest);</span><br><span class="line">std::<span class="built_in">swap</span>(vec, dest);</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; new_vec = std::<span class="built_in">move</span>(vec);</span><br></pre></td></tr></table></figure><p>std::count, 统计容器中某个元素出现的次数。std::count_if：统计符合特定条件的元素的数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = std::<span class="built_in">count</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> count = std::<span class="built_in">count_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br></pre></td></tr></table></figure><p>std::accumulate, 对容器中的元素进行累加。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = std::<span class="built_in">accumulate</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>std::min_element, 返回容器中最小元素的迭代器。std::max_element：返回容器中最大元素的迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> min_it = std::<span class="built_in">min_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">auto</span> max_it = std::<span class="built_in">max_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>std::unique, 将容器中相邻的重复元素移动到末尾，返回新逻辑结尾的迭代器，不修改容器大小​​<br>unique需要和sort一起连用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> last = std::<span class="built_in">unique</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// v 变为 &#123;1, 2, 3, 4, 3, 3, 3, 4&#125;，last 指向第5个元素（第一个3后的位置）</span></span><br></pre></td></tr></table></figure><h4 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h4><p>由于C++兼容C语言，因此支持C风格和C++风格的字符串处理算法。C风格字符串函数参数是指针，C++风格是随机访问迭代器。</p><p>C风格的字符串处理函数, 在C++中，需要<code>#include &lt;cstring&gt;</code>，C语言的字符串处理函数作为std namespace的全局函数。</p><p>C 语言字符串处理函数</p><ol><li>strcpy(dest, src), strncpy(dest, src, n), 字符串拷贝</li><li>strcat(dest, src), strncat(dest, src, n), 字符串拼接</li><li>strcmp(s1, s2), strncmp(s1, s2, n), 字符串比较</li><li>strlen(s), 字符串长度</li><li>strchr(s, c), strrchr(s, c), 字符串查找</li><li>memset, memove, memcpy 内存赋值&#x2F;移动&#x2F;拷贝<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strcpy(dest, src), strncpy(dest, src, n), 字符串拷贝</span></span><br><span class="line"><span class="type">char</span> src[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">char</span> dest[<span class="number">20</span>];</span><br><span class="line">std::<span class="built_in">strcpy</span>(dest, src);</span><br><span class="line">std::<span class="built_in">strncpy</span>(dest, src, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// strcat(str1, str2) 将str2拼接到str1</span></span><br><span class="line">std::<span class="built_in">strcat</span>(str1, str2); </span><br><span class="line">std::<span class="built_in">strncat</span>(str1, str2, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// strlen(str)，返回 C 风格字符串的长度（不包括 \0 终止符）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// strcmp(str1, str2), strncmp(str1, str2, n) 如果str1 &gt; str2, 返回大于0</span></span><br><span class="line">std::<span class="built_in">strcmp</span>(str1, str2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// strchr(str, c)，查找字符c在字符串str中第一次出现的位置。如果找到了，返回指向该字符的指针；如果没找到，返回 nullptr。</span></span><br><span class="line"><span class="type">char</span>* ptr = std::<span class="built_in">strchr</span>(str, <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// strstr(str, sub), 查找子字符串sub在字符串str中的第一次出现。如果找到了，返回指向子字符串的指针；如果没找到，返回 nullptr。</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* sub = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="type">char</span>* ptr = std::<span class="built_in">strstr</span>(str, sub);</span><br><span class="line"></span><br><span class="line"><span class="comment">// memset(str, c, n) 按字节为单位对内存初始化</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">std::<span class="built_in">memset</span>(str, <span class="string">&#x27;*&#x27;</span>, <span class="number">5</span>);  <span class="comment">// 将前 5 个字符设置为 &#x27;*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(dest, src, n) 从src拷贝n个字节到dest</span><br><span class="line"><span class="type">char</span> src[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> dest[<span class="number">10</span>];</span><br><span class="line">std::<span class="built_in">memcpy</span>(dest, src, <span class="number">6</span>); </span><br></pre></td></tr></table></figure></li></ol><p>C++ string函数</p><ol><li>append(xxx) 追加字符串</li><li>substr(start, length) 截取字符串, 需要拷贝</li><li>find(xxx) 查找子串</li><li>replace(start, length, xxx) 替换字符串</li><li>erase(start, length) 删除字符串, 是真正的删除（性能差）</li><li>stoi(xxx) 字符串转整数</li><li>std::string, .c_str()<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// size() 或 length() 获取字符串长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// append(string)，将内容追加</span></span><br><span class="line">std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">str.<span class="built_in">append</span>(<span class="string">&quot;, World!&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// push_back(c)，添加一个字符</span></span><br><span class="line">str.<span class="built_in">push_back</span>(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert(index, string), 指定位置插入字符串</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">5</span>, <span class="string">&quot;, World&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// erase(index, length), 删除指定位置区间的字符串</span></span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">5</span>, <span class="number">7</span>);  <span class="comment">// 从位置 5 开始删除 7 个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// replace(index, length, newstring), 替换字符串中的指定部分。</span></span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">7</span>, <span class="number">5</span>, <span class="string">&quot;C++&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// resize(size) 改变字符串的大小，如果增加字符则填充，减少字符则截断。</span></span><br><span class="line">str.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::find(string) 查找子字符串首次出现的位置。如果找不到返回 std::string::npos。rfind, 从字符串末尾向前查找字符串</span></span><br><span class="line"><span class="type">size_t</span> pos = str.<span class="built_in">find</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// find_first_of(),find_last_of()</span></span><br><span class="line"><span class="type">size_t</span> pos = str.<span class="built_in">find_first_of</span>(<span class="string">&quot;o&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// substr(index, length) 提取子字符串</span></span><br><span class="line">std::string sub = str.<span class="built_in">substr</span>(<span class="number">7</span>, <span class="number">5</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// compare 字符串比较</span></span><br><span class="line">std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">std::string str2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="type">int</span> result = str<span class="number">1.</span><span class="built_in">compare</span>(str2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// stoi(), stol(), stoll() 字符串转为整型</span></span><br><span class="line"><span class="type">int</span> num = std::<span class="built_in">stoi</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// to_string()，转为字符串</span></span><br><span class="line">std::string str = std::<span class="built_in">to_string</span>(num);</span><br><span class="line"></span><br><span class="line"><span class="comment">// c_str(), data() 返回 C 风格字符串（const char*）。</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cstr = str.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></figure></li></ol><p>string_view 是C++17的特性，旨在解决substr()字符串切片会导致拷贝造成性能损失的问题</p><ol><li>string_view不管理内存，仅保存指向外部数据的指针和长度。不能通过string_view修改底层数据。</li><li>构造时不复制数据，可以直接传递字符串参数，避免临时对象的开销。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(std::string_view text)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理 text，无需关心数据来源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">process</span>(<span class="string">&quot;Hello&quot;</span>);       <span class="comment">// C字符串</span></span><br><span class="line"><span class="built_in">process</span>(std::<span class="built_in">string</span>(<span class="string">&quot;World&quot;</span>)); <span class="comment">// std::string</span></span><br><span class="line"><span class="built_in">process</span>(sv1);          <span class="comment">// 另一个 string_view</span></span><br></pre></td></tr></table></figure><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><p>静态数组，</p><ol><li>​​固定长度​​：数组在初始化时指定长度，后续无法修改。</li><li>连续内存​​：元素在内存中连续存储，支持快速随机访问（时间复杂度 O(1)）。</li><li>数组本身也是对象（继承自 Object 类），存储在堆内存中。</li></ol><p>java只有8种基本类型变量(byte, short, int, long, float, double, char, boolean)存放在栈里，数组不是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers;       <span class="comment">// 声明一个整型数组,  此时 arr = null</span></span><br><span class="line">String[] names;      <span class="comment">// 声明一个字符串数组</span></span><br><span class="line"></span><br><span class="line">numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; <span class="comment">// 初始值为 [0, 0, 0, 0, 0]</span></span><br><span class="line"></span><br><span class="line">names = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">numbers[<span class="number">1</span>] = <span class="number">10</span>;             <span class="comment">// 修改第二个元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> numbers.length; <span class="comment">// 获取数组长度（非方法，是字段）</span></span><br></pre></td></tr></table></figure><p>ArrayList，等于C++的vector，动态数组。JAVA的List是一个接口，实现了动态数组和链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line">System.out.println(list);  <span class="comment">// 输出: [Apple, Banana, Cherry]</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> list.get(<span class="number">0</span>);       <span class="comment">// 获取索引 0 的元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> list.get(list.size() - <span class="number">1</span>); <span class="comment">// 获取最后一个元素</span></span><br><span class="line">list.set(<span class="number">0</span>, <span class="number">20</span>); <span class="comment">// 将索引 0 的元素修改为 20</span></span><br><span class="line">list.addAll(otherList); <span class="comment">// 添加另一个集合的所有元素</span></span><br></pre></td></tr></table></figure><p>LinkedList，双向链表，相当于C++的list</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>HashSet, 基于哈希表实现，不保证元素的顺序。</p><p>LinkedHashSet, 基于哈希表和链表实现，能够保证元素的插入顺序。</p><p>TreeSet, 基于红黑树实现，元素按自然顺序或自定义顺序排列。</p><p>HashMap，基于哈希表实现，允许 null 键和值。</p><p>LinkedHashMap，基于哈希表和链表实现，保持插入顺序（或访问顺序）</p><p>TreeMap，基于红黑树实现，键按自然顺序或自定义顺序排序。</p><p>PriorityQueue，基于堆实现的队列，元素按优先级顺序排列</p><p>LinkedList 也实现了 Queue 接口，支持双端队列操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">queue.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">queue.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">queue.add(<span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line">System.out.println(queue.poll());  <span class="comment">// 输出: Apple（出队）</span></span><br><span class="line">System.out.println(queue);  <span class="comment">// 输出: [Banana, Cherry]</span></span><br></pre></td></tr></table></figure><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>Arrays用于操作数组，例如.sort() 用于对静态数组进行排序，数组是基本类型数组<code>int[] arr </code>，或对象数组<code>new Integer[10]</code>.<br>java的.length用于获取静态数组长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">Arrays.sort(arr); <span class="comment">// 数组变为 [1, 2, 3, 4, 5]</span></span><br><span class="line">Arrays.sort(arr, (a, b) -&gt; b - a); <span class="comment">// 降序排序 → [5, 4, 3, 2, 1]</span></span><br><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr, <span class="number">3</span>); <span class="comment">// 返回 2（索引）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">Arrays.fill(arr, <span class="number">10</span>); <span class="comment">// [10, 10, 10, 10, 10]</span></span><br></pre></td></tr></table></figure><p>Collections用于容器算法，.sort() 用于对集合（如 List）进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);  <span class="comment">// 输出: [1, 2, 3, 5, 8]</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Collections.binarySearch(list, <span class="number">5</span>);</span><br><span class="line">        System.out.println(index);  <span class="comment">// 输出: 3</span></span><br><span class="line"></span><br><span class="line">        Collections.fill(list, <span class="number">10</span>);</span><br><span class="line">        System.out.println(list);  <span class="comment">// 输出: [10, 10, 10, 10, 10]</span></span><br><span class="line"></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        System.out.println(list);  <span class="comment">// 输出: 随机打乱后的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h4><p>JAVA的字符串操作类主要是String, StringBuilder, StringBuffer。</p><p>String一旦创建，内容不可修改。任何修改操作（如拼接、替换）都会生成新对象。（如果固定内存的字符串需要修改，用字符数组更好）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 字符串字面量</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 使用构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// length() 获得长度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str.length();</span><br><span class="line"></span><br><span class="line">s.charAt(<span class="number">0</span>)  <span class="comment">// 访问字符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(<span class="number">0</span>, <span class="number">5</span>);  <span class="comment">// 切片</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> s1 + <span class="string">&quot; &quot;</span> + s2;  <span class="comment">// 使用 + 拼接</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();  <span class="comment">// 利用StringBuilder</span></span><br><span class="line">sb.append(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">trimmed</span> <span class="operator">=</span> s.trim();  <span class="comment">// 去除两端空白字符</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> s.indexOf(<span class="string">&quot;World&quot;</span>);  <span class="comment">// 查找子字符串的索引位置</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">upper</span> <span class="operator">=</span> s.toUpperCase();  <span class="comment">// 转为大写</span></span><br><span class="line"><span class="type">String</span> <span class="variable">formatted</span> <span class="operator">=</span> String.format(<span class="string">&quot;My name is %s and I am %d years old.&quot;</span>, name, age);  <span class="comment">// 字符串格式化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;apple,banana,cherry&quot;</span>;</span><br><span class="line">String[] fruits = s.split(<span class="string">&quot;,&quot;</span>);  <span class="comment">// 按逗号分割字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符数组可以修改某位置字符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>[] charArray = str.toCharArray();</span><br><span class="line">charArray[<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">modifiedStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line">System.out.println(modifiedStr);  <span class="comment">// 输出: Hallo</span></span><br></pre></td></tr></table></figure><p>StringBuilder 和 StringBuffer 是用于可变字符串的类。StringBuilder只能用于单线程环境, 直接修改内部字符数组，避免频繁创建新对象。StringBuffer 所有方法均用synchronized修饰, 性能低于StringBuilder, 但多线程安全。</p><p>修改字符串某位置的字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 字符串不可修改某位置字符，可以利用stringBuilder</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">sb.setCharAt(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">System.out.println(sb.toString());  <span class="comment">// 输出: Hallo</span></span><br><span class="line"></span><br><span class="line">sb.insert(<span class="number">5</span>, <span class="string">&quot; World&quot;</span>); <span class="comment">// &quot;Hello&quot; → &quot;Hello World&quot;</span></span><br><span class="line">sb.deleteCharAt(<span class="number">4</span>); <span class="comment">// &quot;Hello&quot; → &quot;Hell&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>  <span class="comment">// 长度</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><h4 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h4><p>golang 用语言关键字提供了容器，不必额外导入包</p><p>静态数组, 固定大小的同一类型的元素。Go 数组的大小在声明时确定并且内容不可更改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="type">int</span> <span class="comment">// 定义一个长度为 5 的整型数组</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">fmt.Println(arr) <span class="comment">// 输出: [1 2 0 0 0]</span></span><br></pre></td></tr></table></figure><p>切片slice，动态数组。[]byte表示动态字符串。slice 的切片截取操作无须拷贝, </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建切片</span></span><br><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>) <span class="comment">// 长度3，容量5</span></span><br><span class="line"></span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">6</span>)</span><br><span class="line">slice = slice[:<span class="built_in">len</span>(slice)<span class="number">-1</span>]  <span class="comment">// 删除最后一个元素</span></span><br><span class="line">s = s[:<span class="number">0</span>] <span class="comment">// 清空元素（容量不变）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> slice &#123; fmt.Printf(<span class="string">&quot;Index: %d, Value: %d\n&quot;</span>, i, v) &#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s)) <span class="comment">// 3 获取长度</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s)) <span class="comment">// 5 获取容量</span></span><br><span class="line"></span><br><span class="line">sub := s[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">// 截取切片, 包含索引1，不包含索引3 → [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素, 将删除位置后的元素前移，时间复杂度为 ​​O(n)​​</span></span><br><span class="line"><span class="comment">// 会拷贝 slice[i+1:] 的元素到 slice[i:] 的位置。</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice[:i], slice[i+<span class="number">1</span>:])</span><br><span class="line"><span class="comment">// 删除元素还可以用最后一个元素覆盖删除位置</span></span><br><span class="line">s[i] = s[<span class="built_in">len</span>(s)<span class="number">-1</span>]</span><br><span class="line">s = s[:<span class="built_in">len</span>(s)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接用数组创建切片</span></span><br><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line">s2 := arr[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">// [20, 30, 40]</span></span><br></pre></td></tr></table></figure><p>map，哈希表实现的容器。map底层实现和C++的unorder_map、JAVA的hashmap不同<br>map的底层结构体是hmap，hmap里维护着若干个bucket数组 (即桶数组)。</p><ol><li>每个桶存储固定数量的键值对（通常为 8 对），如果超过8个键值对了, 会先把多余的pair放到一个溢出桶中</li><li>map负载因子的定义是map中元素的个数 &#x2F; map中当前桶的个数。当装载因子 &gt; 6.5, 或溢出桶的数量过多，就会执行哈希表扩容。扩容非一次性完成, 每次对map进行删改操作时，会触发从oldbucket中迁移到bucket的操作, 在扩容没有完全迁移完成之前，每次get或者put遍历数据时，都会先遍历oldbuckets，然后再遍历buckets。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">myMap := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">    <span class="string">&quot;apple&quot;</span>:  <span class="number">5</span>,</span><br><span class="line">    <span class="string">&quot;banana&quot;</span>: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">m3 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">100</span>) <span class="comment">// 预分配约 100 元素的容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入或更新元素</span></span><br><span class="line">myMap[<span class="string">&quot;orange&quot;</span>] = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">value, exists := m[<span class="string">&quot;key&quot;</span>] <span class="comment">// exists 为 bool 类型，表示是否存在</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> myMap &#123; fmt.Printf(<span class="string">&quot;Key: %s, Value: %d\n&quot;</span>, k, v) &#125;</span><br><span class="line"></span><br><span class="line">value, exists := m[<span class="string">&quot;key&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> exists &#123;</span><br><span class="line">    <span class="comment">// 处理 value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">length := <span class="built_in">len</span>(m)   <span class="comment">// 获取键值对数量</span></span><br></pre></td></tr></table></figure><p>链表，使用container&#x2F;list</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;container/list&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    l := list.New()</span><br><span class="line">    l.PushBack(<span class="number">1</span>) <span class="comment">// 在链表尾部插入</span></span><br><span class="line">    l.PushFront(<span class="number">0</span>) <span class="comment">// 在链表头部插入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> e := l.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">        fmt.Println(e.Value) <span class="comment">// 输出: 0 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>channel，channel可认为是一个线程安全的协程间任务队列，内部通过链表和环形链表实现，这个可以在并发编程处详细展开。</p><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><p>排序，import “sort”标准库</p><p>golang自定义struct的排序比较麻烦, 需要对自定义的struct实现<code>Len() int</code> ,  <code>Less(i, j int) bool</code>, <code>Swap(i, j int) </code>三个接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">numbers := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">sort.Ints(numbers) <span class="comment">// 排序，可以选择Ints, Strings, Stable等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型排序</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByAge []Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> a[i].Age &lt; a[j].Age &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Swap(i, j <span class="type">int</span>)      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">people := []Person&#123;</span><br><span class="line">&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">20</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort.Sort(ByAge(people)) <span class="comment">// 排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串处理函数-1"><a href="#字符串处理函数-1" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h4><p>Go中，string是不可变的 UTF-8 编码字符串, 无法原地修改字符串（编译失败）。[]byte是字符序列切片，可原地修改字符串。</p><p>golang字符串处理函数strings，如果要修改字符串, 必然会有内存拷贝。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">b := []<span class="type">byte</span>(s) <span class="comment">// 将 string 转换为 []byte</span></span><br><span class="line"></span><br><span class="line">b := []<span class="type">byte</span>&#123;<span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>&#125;</span><br><span class="line">s := <span class="type">string</span>(b) <span class="comment">// 将 []byte 转换为 string</span></span><br><span class="line"></span><br><span class="line">str := <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="built_in">len</span>(str)  <span class="comment">// 返回长度</span></span><br><span class="line">str[<span class="number">1</span>]  <span class="comment">// 根据索引查看字符</span></span><br><span class="line"></span><br><span class="line">str1 := <span class="string">&quot;Hello&quot;</span></span><br><span class="line">str2 := <span class="string">&quot;World&quot;</span></span><br><span class="line">result := str1 + <span class="string">&quot;, &quot;</span> + str2  <span class="comment">// + 拼接字符串</span></span><br><span class="line"></span><br><span class="line">strings.Index(str, <span class="string">&quot;World&quot;</span>)  <span class="comment">// 查找字符串</span></span><br><span class="line">strings.Contains(str, <span class="string">&quot;World&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下都有内存拷贝</span></span><br><span class="line">strings.Split(str, <span class="string">&quot;,&quot;</span>)  <span class="comment">// 字符串分割，返回字符串数组</span></span><br><span class="line">strings.TrimSpace(str)  <span class="comment">// 去掉两侧空白</span></span><br><span class="line"></span><br><span class="line">strings.ToUpper(str)  <span class="comment">// 字符串大小写</span></span><br><span class="line">strings.ToLower(str)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化生成新字符串</span></span><br><span class="line">result := fmt.Sprintf(<span class="string">&quot;Name: %s, Age: %d&quot;</span>, name, age)</span><br><span class="line"></span><br><span class="line">strconv.Atoi(numStr) <span class="comment">// 字符串转整数</span></span><br></pre></td></tr></table></figure><p>bytes 包处理 []byte</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">data := []<span class="type">byte</span>(<span class="string">&quot;name:age:email&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分割操作（无拷贝，共享底层数组）</span></span><br><span class="line">parts := bytes.Split(data, []<span class="type">byte</span>(<span class="string">&quot;:&quot;</span>)) </span><br></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><h4 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h4><p>列表，动态数组。和go一样，python列表支持切片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">my_list[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">my_list.append(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>元组Tuple，不可变，只可被访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">a, b, c = my_tuple</span><br></pre></td></tr></table></figure><p>字典dict, 无序（Python 3.7 及以上版本中插入有序）、键值对、键唯一。</p><ol><li>dict的内部实现基于​​开放寻址法的哈希表​​</li><li>python3.7之后, 字典内部新增一个​​双向链表​​（或紧凑数组），按插入顺序记录所有键值对。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">my_dict = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>&#125;</span><br><span class="line">my_dict[<span class="string">&quot;age&quot;</span>] = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">​​要求​​：对象必须实现__hash__和__eq__方法。</span><br><span class="line">__hash__：返回唯一且不变的哈希值。</span><br><span class="line">__eq__：判断键是否相等。</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">id</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">id</span> = <span class="built_in">id</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(<span class="variable language_">self</span>.<span class="built_in">id</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.<span class="built_in">id</span> == other.<span class="built_in">id</span></span><br><span class="line"></span><br><span class="line">users = &#123;User(<span class="number">1</span>): <span class="string">&quot;Alice&quot;</span>, User(<span class="number">2</span>): <span class="string">&quot;Bob&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li></ol><p>集合set，无序、不重复。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">my_set.add(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>有序字典, 保留键值对插入顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">ordered_dict = OrderedDict()</span><br><span class="line">ordered_dict[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">ordered_dict[<span class="string">&quot;b&quot;</span>] = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>python的 str不可变, 任何修改生成新对象（原对象不变）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 列表（可变）</span></span><br><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">lst[<span class="number">0</span>] = <span class="number">10</span>      <span class="comment"># 直接修改 → [10, 2, 3]</span></span><br><span class="line">lst.append(<span class="number">4</span>)    <span class="comment"># 追加元素 → [10, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串（不可变）</span></span><br><span class="line">s = <span class="string">&quot;hello&quot;</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&quot;H&quot;</span>       <span class="comment"># 报错：TypeError</span></span><br><span class="line">new_s = s.replace(<span class="string">&quot;h&quot;</span>, <span class="string">&quot;H&quot;</span>)  <span class="comment"># 生成新对象 &quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表</span></span><br><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">sub_lst = lst[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment"># [2, 3]（浅拷贝）</span></span><br><span class="line"><span class="comment"># 字符串</span></span><br><span class="line">s = <span class="string">&quot;hello&quot;</span></span><br><span class="line">sub_s = s[<span class="number">1</span>:<span class="number">3</span>]     <span class="comment"># &quot;el&quot;（新字符串）</span></span><br></pre></td></tr></table></figure><h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><p>排序<br>sorted(iterable, key&#x3D;None, reverse&#x3D;False), 返回一个新的排序列表，不改变原列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(nums))  <span class="comment"># 升序: [1, 2, 5, 9]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(nums, reverse=<span class="literal">True</span>))  <span class="comment"># 降序: [9, 5, 2, 1]</span></span><br><span class="line"></span><br><span class="line">words = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(words, key=<span class="built_in">len</span>))  <span class="comment"># 按字符串长度排序: [&#x27;apple&#x27;, &#x27;cherry&#x27;, &#x27;banana&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># list.sort(), 原地排序，直接修改列表</span></span><br><span class="line">nums = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>]</span><br><span class="line">nums.sort()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典排序</span></span><br><span class="line">my_dict = &#123;<span class="string">&quot;b&quot;</span>: <span class="number">2</span>, <span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;c&quot;</span>: <span class="number">3</span>&#125;</span><br><span class="line">sorted_keys = <span class="built_in">sorted</span>(my_dict)  <span class="comment"># 按键排序</span></span><br><span class="line">sorted_items = <span class="built_in">sorted</span>(my_dict.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>])  <span class="comment"># 按值排序</span></span><br></pre></td></tr></table></figure><h4 id="字符串处理-1"><a href="#字符串处理-1" class="headerlink" title="字符串处理"></a>字符串处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="built_in">len</span>(s)</span><br><span class="line">s[<span class="number">1</span>]</span><br><span class="line">s[-<span class="number">1</span>]</span><br><span class="line">s[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">s + <span class="string">&quot; &quot;</span>  <span class="comment"># 拼接</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;My name is <span class="subst">&#123;name&#125;</span> and I am <span class="subst">&#123;age&#125;</span> years old.&quot;</span>)  <span class="comment"># 格式化输出, python3支持</span></span><br><span class="line">s.upper()，s.lower()</span><br><span class="line">s.strip()  <span class="comment"># 去除空格</span></span><br><span class="line">s.find(<span class="string">&quot;World&quot;</span>)</span><br><span class="line">s.replace(<span class="string">&quot;World&quot;</span>, <span class="string">&quot;Python&quot;</span>)</span><br><span class="line"></span><br><span class="line">s.split(<span class="string">&quot;,&quot;</span>)</span><br></pre></td></tr></table></figure><p>对于python2, 还有个编码的问题。处理办法是，对于u开头的字符串或者unicode类型的字符串，都使用encode(“utf-8”) 编码为str类型后，再使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line">unicode_str = <span class="string">u&quot;中文&quot;</span>  <span class="comment"># Unicode 字符串</span></span><br><span class="line">byte_str = <span class="string">&quot;byte&quot;</span>  <span class="comment"># 字节字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(unicode_str))  <span class="comment"># &lt;type &#x27;unicode&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(byte_str))  <span class="comment"># &lt;type &#x27;str&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(unicode_str.encode(<span class="string">&quot;utf-8&quot;</span>)))  <span class="comment"># &lt;type &#x27;str&#x27;&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> base </category>
          
      </categories>
      
      
        <tags>
            
            <tag> language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程语言——映射结构</title>
      <link href="/2024/12/06/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94%E6%98%A0%E5%B0%84%E7%BB%93%E6%9E%84/"/>
      <url>/2024/12/06/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94%E6%98%A0%E5%B0%84%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>映射是最重要的数据结构之一，动态数组也可以看做特殊的映射。映射的优势是，它的增删改查性能都很好。增-&gt;增加key，删-&gt;删除key，改-&gt;更改某key的vakue，查-&gt;给定key查询value。</p><span id="more"></span><h3 id="映射结构"><a href="#映射结构" class="headerlink" title="映射结构"></a>映射结构</h3><p>C++ STL 对映射有两种实现，红黑树和哈希表。</p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>红黑树是在AVL树发展的二叉有序平衡树。AVL树通过左旋、右旋实现了高度平衡树，查询更改性能稳定O(n&#x2F;2)，但频繁插入删除会造成经常的rebalance，造成插入、删除性能下降。</p><p>红黑树有以下要求</p><ol><li>每个节点都是红色或黑色。</li><li>根节点始终是黑色。</li><li>每个<strong>叶节点（NIL 或空节点）是黑色</strong>。（实际红黑树叶子节点是黑色的NIL，NIL不存储数据，存储数据的“叶子节点”可以为红色）</li><li>从任意节点到其每个叶节点的<strong>所有路径中，包含相同数量的黑色节点</strong>。</li><li>红色节点的两个子节点必须是黑色（红色节点不能有两个连续的红色节点）。</li></ol><p><img src="/../images/rbtree.png" alt="rbtree" title="rbtree"></p><p>插入操作时，新插入的节点被视为红色（孩子是黑色的NIL）。如果新插入节点的父节点为黑色，插入后不需要调整。只有当插入节点的父节点为红色，才需要调整。</p><p>删除操作类似，删除的节点如果是红色，调整较少；只有删除的节点是是黑色，才需要重新调整</p><p>具体后面有时间再分析吧2333</p><h4 id="STL-哈希表"><a href="#STL-哈希表" class="headerlink" title="STL 哈希表"></a>STL 哈希表</h4><p>哈希表的实现主要有两部分 1. hash计算索引 2. 哈希碰撞处理</p><p>哈希表需要根据类型key计算hash key，来确定变量在hash表的位置。C++ hash函数使用std::hash模版函数计算hash key</p><ol><li>对于整数类型，通常直接返回值本身或经过简单混淆的值（如乘以某个大素数）。</li><li>浮点型，std::hash 会将其二进制表示重新解释为整数，然后对该整数值计算哈希。</li><li>字符串类型，<code>std::hash&lt;std::string&gt;</code> 通常使用简单的字符串哈希算法, 例如DJB2 算法。DJB2通过<strong>逐字符累积计算哈希值</strong>，每次累积时将现有的哈希值乘以一个素数（通常是 33），再加上当前字符的 ASCII 值。</li><li>指针，通常直接使用指针的值（地址）</li></ol><p>哈希碰撞处理，通常使用开链法。</p><p>在hash表碰撞不严重的情况下，哈希表的增、删、改、查时间复杂度都是O(1)。另外，由于hash表的数组是预先分配好的，动态处理比红黑树简单很多。例如hash表可以通过key数量除以数组长度作为负载因子来判断是否应该扩容缩容。（相比下，红黑树没有扩缩容的概念？）</p><p>hash表的数组（slot）长度通常选择素数（减少冲突），或者选择2的幂次，容易使用按位操作（hash &amp; (bucket_count - 1)）来快速定位索引。</p><p>hash表扩缩容也称为rehash，数组size为素数的扩容，size选择距离扩容前size两倍最近的素数；数组size为2的幂次的扩容，size直接乘2即可。</p><p>rehash单线程场景下，rehash操作在用户程序进程执行（可以在调用插入命令后触发，也可手动调用rehash函数触发）。</p><p>多线程情况下，rehash往往由后台线程执行，需要考虑和前台io线程的冲突。一般来说，前台io线程或后台扫描线程根据负载因子，触发rehash，rehash首先创建扩容后的数组。创建完后通知前台io线程数据正在rehash。</p><p>rehash是从旧表读数据，向新表插数据。本质是个增操作，单位是key</p><ol><li>增操作<ol><li>如果数据在旧表不存在，则直接新hash表增加key，多线程的数据增操作很重，需要对整个hash表（或分段）加锁</li><li>如果数据已存在，则判断key是否rehash完毕。如果rehash完毕，在新表删除旧key然后加新key; 没有rehash则旧表删除旧key,新表增加新key；如果正在rehash，需要等rehash完抢到锁，然后在新表删除旧key然后加新key</li></ol></li><li>删操作<ol><li>数据在旧表不存在，报错</li><li>数据在旧表存在，类似增操作。需要看key的rehash状态，rehash完在新表删除，否则在旧表删除</li></ol></li><li>改操作<ol><li>数据在旧表不存在，报错</li><li>数据在旧表存在，如果key rehash完毕，在新表改；否则在旧表改</li></ol></li><li>查操作<ol><li>先查询新表，新表查询不到则查询旧表。</li></ol></li></ol><p>哈希表的rehash是一个数据迁移操作，对表迁移有很大参考意义。更进一步</p><ol><li>hash表支持将某个value从key1，移动到key2，需要是原子的（即文件系统的rename）。多线程时需要对key1和key2加锁，需要避免死锁。此外，rehash时应该怎么处理？</li><li>hash表怎么拆分，key锁，插入锁，怎么优化。</li></ol><p>问题1, rehash时，可能出现key1在旧hash表, key2在新hash表。为了死锁避免，一张表或一个segment只同时刻允许一次rename（可使用单线程多协程实现），为了保证rename的原子性（即删除key1,增加key2两个操作需要原子性），可以使用事务。更复杂的，两张表可能不在一个机器上，需要更复杂的死锁避免，同时为了保证原子性需要分布式事务。</p><h4 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h4><p>hash表的的数据排布是无序的，常用的有序替代品是跳跃表skiplist。redis，leveldb, rocksdb的有序内存集合都是使用跳跃表实现。由于内存数据不能持久化，redolog+跳跃表的组合是kv单机存储引擎最常见的组合。</p><p>使用redolog的表迁移(rehash)，可以选择让新表一直replay redolog来让数据和旧表保持一致。但这种办法不能实现彻底的热迁移，当检测到写请求少时（例如晚上），旧表会禁止用户写入，等待新表replay完毕，将新表配置成接受读写请求的表。期间会有短暂的写不可用，不可用时间主要来自等待新表replay完毕和必要的数据校验。这种表迁移比较简单，尤其当表被拆分到多个机器中（分布式表），只需要让机器1和机器2能共享相同的redolog文件。例如把redolog存储到hdfs中，当机器A的表尝试rehash到机器2时，只需要机器2 replay写到hdfs中的机器1的redolog即可。replay过程中，数据读写照常在机器1进行，直到监控到写请求少，进行短暂的禁写等待机器2replay完毕，然后通知placement该表的后续读写路由到机器2，即可。</p><p>越简单的实现越安全，越可控。所以生产上尤其是分布式系统中，表迁移大多数借助replay redolog实现。</p><h4 id="JAVA-hashmap和线程安全hash表"><a href="#JAVA-hashmap和线程安全hash表" class="headerlink" title="JAVA hashmap和线程安全hash表"></a>JAVA hashmap和线程安全hash表</h4><p>java 的hashmap实现和C++的unordered_map大同小异，采用头插法处理碰撞，非线程安全。</p><p>java的每个对象都会有hashcode函数，hashcode可被重写，默认使用对象的地址。hashcode决定了对象插入到hash表时的hash key。</p><p>前面说到，hash表多线程增删操作很重，需要对全表加写锁；改操作只需要对key加写锁。java hashtable的线程安全就是通过全表加锁实现。</p><p>为了降低锁的粒度，JAVA ConcurrentHashMap 实现segment-&gt;table两级哈希表。定位元素需要进行两次Hash，第一次 Hash 定位到 Segment，第二次 Hash 定位到元素所在的链表的头部。加锁只需要对segment加写锁，不影响其他segment。</p><p>使用多级hash表还可以降低存储空间的占用，可参考MMU 虚拟内存-&gt;物理内存映射的哈希表。对于两个key 10、499，一张哈希表需要512个slot，两张哈希表只需要256+26&#x3D;282个slot。</p><p><strong>JAVA volatile关键字保证的可见性可以实现多线程查询操作无锁</strong>，通过使用volatile修饰key，get操作不用加锁。使用final修饰常量，也可以保证查操作无锁。</p><h4 id="golang的map和sync-Map"><a href="#golang的map和sync-Map" class="headerlink" title="golang的map和sync.Map"></a>golang的map和sync.Map</h4><p>golang的map是非协程安全的，go提供协程安全map sync.Map。</p><p>golang map 使用开链法处理冲突。初始时map的键值对存放到哈希桶中，哈希桶是一个对象，可以放置 8 个键值对。超出哈希桶后的键值对存放到溢出桶，溢出桶就是开链法的链表。</p><p>sync.Map的实现比较特殊，使用了两个原生map，一个叫read，仅用于读；一个叫dirty，用于存储最新写入的key-value数据。read map相当于读缓存</p><ol><li>写操作：直接写入dirty map</li><li>读操作：先读read map，没有再读dirty map</li></ol><h4 id="Python的dict"><a href="#Python的dict" class="headerlink" title="Python的dict"></a>Python的dict</h4><p>Python的映射称之为字典，dict</p><p>python使用P开放地址法（Open Addressing） 来解决冲突。当计算出的索引位置已被占用时，通过一定的规则寻找下一个空闲位置。Python 字典采用了一种变体的开放地址法，称为 探测（Probing），通常是线性探测或伪随机探测。</p><p>当字典中的元素数量接近数组的容量时，数组会扩展到原来容量的两倍。</p><p>Python的可变对象（如列表）不可哈希，不能作为字典的键。只有不可变对象（如字符串、元组）才可以作为dict的键。</p><p>dict不是线程安全的</p><h3 id="其他常见数据结构的实现"><a href="#其他常见数据结构的实现" class="headerlink" title="其他常见数据结构的实现"></a>其他常见数据结构的实现</h3><p>TODO</p>]]></content>
      
      
      <categories>
          
          <category> base </category>
          
      </categories>
      
      
        <tags>
            
            <tag> language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux系统(3)——监控工具</title>
      <link href="/2024/12/05/linux%E7%B3%BB%E7%BB%9F(3)%E2%80%94%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/"/>
      <url>/2024/12/05/linux%E7%B3%BB%E7%BB%9F(3)%E2%80%94%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>linux 系统观测工具是问题排查的有效手段, 性能排查一般过程</p><ol><li>首先利用top和iostat看cpu和磁盘利用率（或者磁盘吞吐&#x2F;iops），是否到瓶颈。也就是硬件到瓶颈</li><li>如果1没有到，说明是软件栈瓶颈。需要看用户程序瓶颈还是内核。</li><li>可以使用perf 直接观察软件栈，可以打印火焰图，也可以perf top -p 查看线程情况</li><li>可以用strace 查看系统调用的延迟，判断内核是不是有瓶颈</li><li>如果程序里有链路 trace，可以直接通过 trace 看程序那部分耗时大</li><li>确认出问题的线程后，可以用 pstack 打印线程栈帧，看是否一直出现wait 相关的栈。（日志里打印线程id的必要性）</li></ol><span id="more"></span><h3 id="系统整体监控"><a href="#系统整体监控" class="headerlink" title="系统整体监控"></a>系统整体监控</h3><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>top 能整体查看系统运行情况工具。利用top，能够观察到cpu,内存的运行情况，过滤出cpu 内存占用高的进程</p><p>%Cpu，可以看出cpu各种操作的时间占比。</p><ol><li>us(用户态进程执行)，</li><li>sy(内核进程执行), </li><li>ni(nice低优先级执行), </li><li>id(idle, cpu空闲时间占比), </li><li>wa(wait, 等待时间占比, 如果时间段在执行io且cpu空闲，则这段空闲cpu时间认为是wait), </li><li>hi(hard interrupt), 硬中断执行时间</li><li>si(soft interrupt), 操作系统软中断执行时间</li><li>st(Steal Time), 分配给虚拟机的时间片<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">top - 16:16:56 up 16:55,  0 users,  load average: 2.01, 1.83, 1.48</span><br><span class="line">Tasks: 340 total,   1 running, 338 sleeping,   1 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  1.3 us,  0.3 sy,  0.0 ni, 98.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">MiB Mem :   7902.0 total,   2180.4 free,   2668.4 used,   3053.2 buff/cache</span><br><span class="line">MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   4924.6 avail Mem </span><br><span class="line">  scroll coordinates: y = 1/340 (tasks), x = 1/12 (fields)</span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                               </span><br><span class="line"> 172367 root      20   0   31.3g 171008  54448 S   1.0   2.1   0:56.97 node                                                                  </span><br><span class="line">   1832 root      20   0   11.4g  76164  43988 S   0.7   0.9   7:02.08 node                                                                  </span><br><span class="line"> 171284 root      20   0   13884   8968   7412 S   0.7   0.1   0:06.62 sshd                                                                  </span><br><span class="line">     14 root      20   0       0      0      0 I   0.3   0.0   5:13.07 rcu_sched                                                             </span><br><span class="line">   1774 root      20   0   11.3g 128480  46240 S   0.3   1.6   9:43.66 node</span><br></pre></td></tr></table></figure></li></ol><p><strong>top 命令点击大写P、M实现按照cpu&#x2F;mem 排序的进程，点击数字键1 可以看到每个cpu的占用。</strong></p><h4 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h4><p>iostat是监控磁盘性能的工具。如果top发现cpu慢在wa，可以使用iostat看具体盘有无问题。命令<code>iostat -x 1 2</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           1.69    0.01    1.05    0.02    0.00   97.23</span><br><span class="line"></span><br><span class="line">Device            r/s     rkB/s   rrqm/s  %rrqm r_await rareq-sz     w/s     wkB/s   wrqm/s  %wrqm w_await wareq-sz     d/s     dkB/s   drqm/s  %drqm d_await dareq-sz  aqu-sz  %util</span><br><span class="line">loop0            0.00      0.00     0.00   0.00    0.29     1.21    0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00   0.00</span><br><span class="line"></span><br><span class="line">r/s w/s 每秒读和写的请求数量(qos)</span><br><span class="line">rrqm/s wrqm/s 每秒合并的读写请求数量</span><br><span class="line">rkB/s wkB/s 每秒读写的字节数(吞吐)</span><br><span class="line">r_await w_await 读写操作io平均等待时间</span><br><span class="line">avgrq-sz：每个IO的平均扇区数，一个扇区512字节</span><br><span class="line">await：平均每个IO所需要的时间, </span><br><span class="line">%util 磁盘的利用率</span><br></pre></td></tr></table></figure><p>磁盘利用率表示io时间占cpu总时间的比例， 表示cpu处理空闲阶段且存在io操作，这段cpu时间片就认为是iowait消耗的</p><h4 id="网络信息"><a href="#网络信息" class="headerlink" title="网络信息"></a>网络信息</h4><p>ifconfig 能输出 网卡、ip地址、网络传输等基本信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.92.128  netmask 255.255.255.0  broadcast 192.168.92.255</span><br><span class="line">        inet6 fe80::20c:29ff:fe51:9544  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:51:95:44  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 695151  bytes 132025574 (132.0 MB)</span><br><span class="line">        RX errors 183  dropped 206  overruns 0  frame 0</span><br><span class="line">        TX packets 863078  bytes 357598696 (357.5 MB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">        device interrupt 19  base 0x2000</span><br></pre></td></tr></table></figure><p>netstat -nultp 查看pid和监听的端口信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 127.0.0.1:39997         0.0.0.0:*               LISTEN      171361/code-fabdb6a </span><br><span class="line">tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      130592/systemd-reso </span><br><span class="line">tcp        0      0 127.0.0.1:44791         0.0.0.0:*               LISTEN      172327/code-fabdb6a </span><br><span class="line">tcp        0      0 127.0.0.1:32819         0.0.0.0:*               LISTEN      169497/code-fabdb6a </span><br><span class="line">tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      2793/cupsd</span><br></pre></td></tr></table></figure><p>netstat -r 显示路由表</p><p>ss（socket statistics）是一个比 netstat 更快速和功能更强大的工具。</p><p>ss -t显示tcp连接数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">State               Recv-Q               Send-Q                                Local Address:Port                                Peer Address:Port                Process               </span><br><span class="line">ESTAB               0                    0                                         127.0.0.1:41999                                  127.0.0.1:52880                                     </span><br><span class="line">ESTAB               0                    0                                    192.168.92.128:ssh                                 192.168.92.1:55778        </span><br></pre></td></tr></table></figure><p>ping和curl 查看网络和端口的连通性</p><p>使用iftop 统计网卡实时流量<br>iftop -i 指定网卡</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TX:             cum:   12.4KB   peak:   11.9Kb                                                                                                          rates:   9.09Kb  9.89Kb  9.89Kb</span><br><span class="line">RX:                    8.64KB           8.17Kb                                                                                                                   8.17Kb  6.91Kb  6.91Kb</span><br><span class="line">TOTAL:                 21.0KB           18.3Kb                                                                                                                   17.3Kb  16.8Kb  16.8Kb</span><br></pre></td></tr></table></figure><h4 id="sar-和tsar"><a href="#sar-和tsar" class="headerlink" title="sar 和tsar"></a>sar 和tsar</h4><p>sar (System Activity Report) 是 Linux 系统中的一个性能监控工具，可以用来统计历史的cpu, 内存, io, 网络等， tsar 是淘宝开源的性能监控工具, 同样可以用来统计历史监控数据</p><p>sar -u 1 5 统计cpu 信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Linux 5.15.0-127-generic (larry-latop-ubuntu)   2025年01月04日  _x86_64_        (8 CPU)</span><br><span class="line"></span><br><span class="line">17时00分04秒     CPU     %user     %nice   %system   %iowait    %steal     %idle</span><br><span class="line">17时00分05秒     all      4.96      0.00      2.01      0.00      0.00     93.03</span><br><span class="line">17时00分06秒     all      0.13      0.00      1.00      0.00      0.00     98.87</span><br><span class="line">17时00分07秒     all      0.00      0.00      0.76      0.13      0.00     99.12</span><br><span class="line">17时00分08秒     all      0.00      0.00      0.13      0.00      0.00     99.87</span><br></pre></td></tr></table></figure><p>sar -hr 1 5 显示内存信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">17时01分34秒 kbmemfree   kbavail kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">17时01分35秒      2.0G      4.8G      2.5G     32.6%    438.8M      2.2G      4.9G     50.6%      1.5G      3.3G     28.0k</span><br><span class="line">17时01分36秒      2.0G      4.8G      2.5G     32.6%    438.8M      2.2G      4.9G     50.6%      1.5G      3.3G     72.0k</span><br><span class="line">17时01分37秒      2.0G      4.8G      2.5G     32.6%    438.8M      2.2G      4.9G     50.6%      1.5G      3.3G     72.0k</span><br></pre></td></tr></table></figure><p>查看磁盘统计, 统计每个磁盘的iops, 读写吞吐, wait, 使用率<br>tps Transactions Per Second, 每秒io数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Average:          DEV       tps     rkB/s     wkB/s     dkB/s   areq-sz    aqu-sz     await     %util</span><br><span class="line">Average:       dev7-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:       dev7-1      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:       dev7-2      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br></pre></td></tr></table></figure><p>sar -n DEV 1 5 统计网络流量</p><p>rxkB&#x2F;s：每秒接收的数据量（KB）。<br>txkB&#x2F;s：每秒发送的数据量（KB）。<br>%ifutil 网络接口利用率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">17时03分27秒     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil</span><br><span class="line">17时03分28秒        lo     34.00     34.00      3.79      3.79      0.00      0.00      0.00      0.00</span><br><span class="line">17时03分28秒     ens33     15.00     15.00      1.67      2.79      0.00      0.00      0.00      0.37</span><br><span class="line">17时03分28秒   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br></pre></td></tr></table></figure><p>sar -q 1 5 查看系统负载（进程）信息</p><p>runq-sz：运行队列的长度。<br>plist-sz：当前进程的数量。<br>ldavg-1、ldavg-5、ldavg-15：系统在 1、5 和 15 分钟的平均负载。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">17时04分40秒   runq-sz  plist-sz   ldavg-1   ldavg-5  ldavg-15   blocked</span><br><span class="line">17时04分41秒         1       787      0.21      0.13      0.40         0</span><br><span class="line">17时04分42秒         1       788      0.21      0.13      0.40         0</span><br><span class="line">17时04分43秒         0       785      0.21      0.13      0.40         0</span><br><span class="line">17时04分44秒         1       804      0.21      0.13      0.40         0</span><br></pre></td></tr></table></figure><h3 id="进程监控"><a href="#进程监控" class="headerlink" title="进程监控"></a>进程监控</h3><h4 id="查看运行进程的信息"><a href="#查看运行进程的信息" class="headerlink" title="查看运行进程的信息"></a>查看运行进程的信息</h4><p><code>ps -ef | grep</code>, <code>ps aux |grep</code> 获得进程的pid, 状态等信息</p><p><code>/proc/&#123;pid&#125;</code> 目录可以看到进程相关资源信息。例如</p><p>&#x2F;proc&#x2F;{pid}&#x2F;fd 查看打开的文件信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@larry-latop-ubuntu:/proc/812# ll /proc/812/fd/</span><br><span class="line">total 0</span><br><span class="line">dr-x------ 2 root       root        0 1月   3 23:22 ./</span><br><span class="line">dr-xr-xr-x 9 messagebus messagebus  0 1月   3 23:22 ../</span><br><span class="line">lrwx------ 1 root       root       64 1月   3 23:22 0 -&gt; /dev/null</span><br><span class="line">lrwx------ 1 root       root       64 1月   3 23:22 1 -&gt; &#x27;socket:[39683]&#x27;</span><br><span class="line">lrwx------ 1 root       root       64 1月   3 23:22 10 -&gt; &#x27;socket:[269352]&#x27;</span><br><span class="line">lrwx------ 1 root       root       64 1月   3 23:22 11 -&gt; &#x27;socket:[36858]&#x27;</span><br></pre></td></tr></table></figure><p>&#x2F;proc&#x2F;{pid}&#x2F;cgroup，查看cgroup信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">13:hugetlb:/</span><br><span class="line">12:perf_event:/</span><br><span class="line">11:blkio:/system.slice/dbus.service</span><br><span class="line">10:memory:/system.slice/dbus.service</span><br><span class="line">9:rdma:/</span><br><span class="line">8:pids:/system.slice/dbus.service</span><br><span class="line">7:freezer:/</span><br><span class="line">6:cpu,cpuacct:/system.slice/dbus.service</span><br><span class="line">5:cpuset:/</span><br><span class="line">4:misc:/</span><br><span class="line">3:devices:/system.slice/dbus.service</span><br><span class="line">2:net_cls,net_prio:/</span><br><span class="line">1:name=systemd:/system.slice/dbus.service</span><br><span class="line">0::/system.slice/dbus.service</span><br></pre></td></tr></table></figure><h4 id="性能排查"><a href="#性能排查" class="headerlink" title="性能排查"></a>性能排查</h4><p>pstack, strace, perf等</p><h4 id="日志监控"><a href="#日志监控" class="headerlink" title="日志监控"></a>日志监控</h4><p>linux 系统日志，默认存储在&#x2F;var&#x2F;log目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/var/log/</span><br><span class="line">├── syslog          # 通用系统日志（Debian/Ubuntu）</span><br><span class="line">├── messages        # 通用系统日志（RHEL/CentOS）</span><br><span class="line">├── auth.log        # 认证日志（登录、sudo）</span><br><span class="line">├── kern.log        # 内核日志（硬件、驱动事件）</span><br><span class="line">├── boot.log        # 系统启动日志</span><br><span class="line">├── dmesg           # 内核环形缓冲区日志（启动阶段信息）</span><br><span class="line">├── cron            # 定时任务日志</span><br><span class="line">├── apache2/        # Apache 服务日志（访问日志、错误日志）</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure><p>nginx, mysql 等系统服务可能把日志写到&#x2F;var&#x2F;log下<br>&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.logNginx 访问日志（客户端请求）tail -f &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log<br>&#x2F;var&#x2F;log&#x2F;mysql&#x2F;error.logMySQL 错误日志sudo less &#x2F;var&#x2F;log&#x2F;mysql&#x2F;error.log</p><p>journalctl​​：查看 systemd 日志（支持服务筛选、时间范围）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">journalctl -u nginx.service -f    <span class="comment"># 实时追踪 Nginx 日志</span></span><br><span class="line">journalctl --since <span class="string">&quot;2024-01-01&quot;</span> --<span class="keyword">until</span> <span class="string">&quot;2024-01-02&quot;</span></span><br></pre></td></tr></table></figure><p>dmesg​​：查看内核环形缓冲区日志。内核环形缓冲区（Kernel Ring Buffer）是Linux内核用于临时存储运行时消息（如硬件事件、驱动状态、系统错误）的内存区域。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep <span class="string">&quot;USB&quot;</span>           <span class="comment"># 检查 USB 设备事件</span></span><br><span class="line">dmesg -T                     <span class="comment"># 显示人类可读的时间戳</span></span><br></pre></td></tr></table></figure><p>配置日志轮转<br>&#x2F;etc&#x2F;logrotate.conf 和 &#x2F;etc&#x2F;logrotate.d&#x2F;*</p>]]></content>
      
      
      <categories>
          
          <category> base </category>
          
      </categories>
      
      
        <tags>
            
            <tag> language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程语言(2)—类型和运算符</title>
      <link href="/2024/11/30/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(2)%E2%80%94%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2024/11/30/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(2)%E2%80%94%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>程序&#x3D;数据+计算。类型确定了数据的定义、数据支持的计算。是程序的基础。</p><p>类型可分为静态类型和动态类型。绝大多数类型是静态类型，编译期确定(常见的如C++的模版类型、sizeof(int)、typeid(int))。动态类型特指接口和多态, 对象的类型需运行时确定。例如C++具有虚函数的多态类, golang的interface{}和通过接口访问struct对象, 以及java的普通类(java的类普通方法均需通过虚函数表调用)。</p><p>本文介绍C、C++、JAVA、Go、Python的类型和运算符。</p><span id="more"></span><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><p>C语言类型主要有</p><ol><li>整型int</li><li>浮点型float, double</li><li>字符型char</li><li>枚举类型enum</li><li>数组<code>int[]</code></li><li>指针<code>int*</code>，包含函数指针<code>int (* p)(int, int)</code></li><li>结构体struct</li><li>共用体Union，</li><li>空类型void</li></ol><p>C 语言支持的运算符，按优先级从高到低排列</p><ol><li><code>() [] -&gt; .</code>，括号、<strong>数组下标、成员访问</strong></li><li><code>! ~ ++ -- - +</code>，逻辑非、按位取反、自增、自减、取负、正号; <code>* &amp; (type) sizeof</code> <strong>解引用、取地址</strong>、类型转换、大小计算</li><li><code>* / %</code> 乘法、除法、取模</li><li><code>+ -</code>加法、减法</li><li><code>&lt;&lt; &gt;&gt;</code>左移、右移</li><li><code>&lt; &lt;= &gt; &gt;=</code>小于、小于等于、大于、大于等于</li><li><code>== !=</code>等于、不等于</li><li><code>&amp;</code> 按位与</li><li><code>^</code>按位异或</li><li><code>|</code> 按位或</li><li><code>&amp;&amp;</code> 逻辑与</li><li><code>||</code> 逻辑或</li><li><code>?:</code> </li><li><code>= += -= *= /= %= &lt;&lt;= &gt;&gt;= &amp;= ^=</code> 赋值及复合赋值</li><li><code>,</code> 逗号</li></ol><h4 id="具体类型"><a href="#具体类型" class="headerlink" title="具体类型"></a>具体类型</h4><p>整型，整型几乎支持所有运算，包括加减乘除算数运算，左移右移，大于等于比较运算，按位运算，逻辑运算(0表示false，其余整型表示true)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="comment">//基本整型，4字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">short</span> <span class="type">int</span>  <span class="comment">// 短整型，2字节</span></span><br><span class="line"><span class="type">short</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">int</span>  <span class="comment">// 长整型，8字节。</span></span><br><span class="line"><span class="type">long</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="comment">// 无符号整型，即正整数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x %x \n&quot;</span>, a&amp;b, a|b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x %x \n&quot;</span>, a&amp;&amp;b, a||b);</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">0</span> f </span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>浮点型，<strong>浮点型不支持左移右移、按位运算</strong>。支持算术、逻辑、比较运算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span>  <span class="comment">// 单精度浮点型，4字节。</span></span><br><span class="line"><span class="type">double</span>  <span class="comment">// 双精度浮点型，8字节。</span></span><br></pre></td></tr></table></figure><p>字符型，<strong>字符型实际等于8位无符号整型</strong>，整数支持的运算它都支持，运算等价于ACCSI码整数运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>  <span class="comment">// 字符型，1字节，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用整数定义char</span></span><br><span class="line"><span class="type">char</span> c = <span class="number">68</span>; </span><br></pre></td></tr></table></figure><p>枚举类型，C语言的枚举类型同样等价于整型，整数支持的运算它都支持</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;RED, GREEN, BLUE&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED = <span class="number">10</span>,    </span><br><span class="line">    GREEN,  </span><br><span class="line">    BLUE </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Color</span> Color1 = RED;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Color</span> Color2 = GREEN;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, Color1, Color2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, Color1||Color2, Color1|Color2, Color1&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">10</span> <span class="number">11</span></span><br><span class="line"><span class="number">1</span> <span class="number">11</span> <span class="number">40</span></span><br></pre></td></tr></table></figure><p>数组，数组本身支持<code>[index]</code>索引查询。另外，<strong>数组名相当于数组第一个元素的地址</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr1[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr2[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr3[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, arr1[<span class="number">0</span>], arr2[<span class="number">1</span>], arr3[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x %d %d\n&quot;</span>, arr1, *arr1, *(arr1<span class="number">+2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span>d941bd0 <span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>指针，指针本身是一个64位的整型。但<strong>不支持乘除、移位、按位运算</strong>。支持加减，逻辑运算。当然还支持<code>*</code>解引用运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br></pre></td></tr></table></figure><p>结构体, 结构体支持使用<code>.</code>找到成员变量, 结构体指针则使用<code>-&gt;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>共用体，共享内存。共用体的size是size最大的成员变量的size。共用体运算同结构体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>void类型, 主要应用于void指针。void指针支持加减，逻辑运算。但不支持<code>*</code>解引用运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *ptr;</span><br></pre></td></tr></table></figure><p>函数指针。函数指针除了支持指针运算，还支持使用<code>()</code>执行函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义函数指针，指向返回 int，接收两个 int 参数的函数</span></span><br><span class="line">    <span class="built_in">int</span> (*func_ptr)(<span class="type">int</span>, <span class="type">int</span>) = add;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, *func_ptr);</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">func_ptr</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">182948169</span></span><br><span class="line">Result: <span class="number">30</span></span><br></pre></td></tr></table></figure><h4 id="转型"><a href="#转型" class="headerlink" title="转型"></a>转型</h4><p>C语言没有RTTI运行时类型信息, 因此C语言没有动态类型。<strong>如果函数参数需要传接口, C语言一般选择<code>void*</code>。</strong>所有指针先转为void*传给函数, 在函数内再转型回来。</p><p>C语言支持隐式转型和强制转型。强制转型和隐式转型都发生在编译期。</p><p><strong>C语言运算符的两侧必须是相同类型，如果不是，就会尝试隐式转型</strong>。隐式转型规则，隐式转型主要针对整型和浮点型。<strong>隐式转型规则是size小的转为size大的</strong>，例如char转为int，int 转换为 unsigned&#x2F;float, float 转换为 double</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">-2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, (i + j) &gt;= <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出.原因，在执行(i + j)时，i转为unsigned int再和j加。0在这里转成了unsigned int</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>C语言的转型有很复杂，比如下面的例子。因此<strong>尽量保证类型的统一。</strong>,使用stdint.h库里的int32_t、uint32_t</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">-2</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ((<span class="type">int</span>)i + (<span class="type">int</span>)j) &gt;= <span class="number">0</span> );  <span class="comment">// 输出0</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ((<span class="type">int</span>)i + j) &gt;= <span class="number">0</span> );  <span class="comment">// 输出1</span></span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>C++兼容C语言的类型、操作符和转型，另外，还支持class定义、类重载运算符、动态类型和静态模版类型</p><ol><li>class 定义, C++ 通过定义class，实现了面向对象（封装、继承、多态）。通过拷贝构造和移动构造, 合并了对象创建和初始化（相比C的struct, 配合new和delete关键字）。通过重载操作符,实现类型比较、赋值等功能。通过虚函数和虚函数表, 实现RTTI和动态类型。</li><li>静态模版类型。C++模版大大增强了编译期类型能力, 除了虚函数调用和动态类型操作(如dynamic_cast, typeid(动态对象指针)), C++的类型信息和操作完全在编译期完成, 相比C语言无性能损失、无额外空间占用。</li></ol><p>类型定义举例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> a = <span class="number">0</span>, <span class="type">int</span> b = <span class="number">0</span>) : <span class="built_in">x</span>(a), <span class="built_in">y</span>(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载赋值运算符</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Point&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> x == other.y &amp;&amp; x == other.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载输出运算符</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Point&amp; p) &#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载加法运算符</span></span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="type">const</span> Point&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(x + other.y, x + other.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">1</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; p1 &lt;&lt; std::endl;  <span class="comment">// 输出：(3, 4)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p1==p2);</span><br><span class="line">    Point p3 = p1 + p2;</span><br><span class="line">    std::cout &lt;&lt; p3 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line">(<span class="number">7</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>C++ 支持bool型，bool型基本等同于1bit的整型，支持加减、移位等运算符，默认false(0)</p><p>C语言只能通过malloc申请进程堆内存，把地址给指针，并通过free释放内存。C++提供了new关键字在堆内存创建对象，new后面可以跟int, float, char, 数组等基本类型，也可以跟自定义类型。对应的释放关键字是delete。new相比malloc，可以通过调用构造函数实现对象初始化。</p><p>在值和指针类型之上，C++增加了引用类型。引用相当于const指针, 但简化了使用。初始化引用时即实现对原值的绑定，对引用的修改等价于对原值的修改。C++的指针和引用使用规则</p><ol><li>若某函数不创建对象，不具有对象的所有权，只修改对象，函数参数传裸指针</li><li>若函数不修改对象，只读对象，传const&amp;</li><li>若函数创建对象同时具有对象的所有权, 使用std::unique_ptr和make_unique。若要转移所有权, 使用std::move(unique_ptr)。</li><li>如果某对象只要创建一次, 需要被共享访问, 尤其是多线程共享， 对象无法预知何时不再被使用时, 使用std::shared_ptr和make_shared。</li></ol><p>shared_ptr 例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataProcessor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setData</span><span class="params">(std::shared_ptr&lt;Data&gt; data)</span> </span>&#123; </span><br><span class="line">        m_data = data;  <span class="comment">// 多个Processor共享同一份Data</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Data&gt; m_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;Data&gt; data = std::<span class="built_in">make_shared</span>&lt;Data&gt;();</span><br><span class="line">DataProcessor processor1, processor2;</span><br><span class="line">processor<span class="number">1.</span><span class="built_in">setData</span>(data);</span><br><span class="line">processor<span class="number">2.</span><span class="built_in">setData</span>(data);</span><br><span class="line"><span class="comment">// 当processor1和processor2都析构后，data自动释放</span></span><br></pre></td></tr></table></figure><p>C++提供右值引用，函数的右值引用参数表示要接收对象的所有权。例如某函数执行std::move(unique_ptr)将所有权转移, 函数参数传右值引用获得所有权。右值引用只能在所有权转移时使用，常见的是赋值(旧对象成员的所有权转移到新建对象), 容器构造(对象所有权从本函数转移到容器)。std::move是将左值转为右值, 目的是转移左值的所有权。 </p><p>在C语言的隐式和显示转换之上，C++增加了四个显示类型转换</p><ol><li>static_cast，编译期间类型转换，基于类型信息</li><li>dynamic_cast，运行时接口向下转型, 接口指针转为对象类型指针</li><li>const_cast，将const* 指针转为普通指针, 从而可以通过指针修改对象。 编译期行为</li><li>reinterpret_cast，等价于运行时指针强制转换</li></ol><h4 id="对象创建和初始化"><a href="#对象创建和初始化" class="headerlink" title="对象创建和初始化"></a>对象创建和初始化</h4><p>运行期局部变量在栈上创建，全局变量和静态变量在静态区创建，new 产生的变量在堆上创建。栈变量的作用域等于函数作用域，全局变量和静态变量的作用域是进程执行期，new产生的堆变量可能逃逸，需要用户自行管理生命周期和内存释放。</p><p>确定所有权是管理堆变量生命周期的推荐方式，具有对象所有权的负责创建和析构堆对象，而其他的只有对象的读写权限，不负责生命周期管理。难以明确所有权的，使用引用计数管理，也就是shared_ptr。</p><p>std::weak_ptr弱引用，不增加引用计数；​必须通过lock()方法获取临时的shared_ptr才能访问对象。可以作为观察者, 通过尝试lock判断对象是否存在，然后访问对象。weak_ptr可用来处理循环引用，也就是如果想父对象引用子对象，子对象也引用父对象，就会造成循环引用，可以通过父对象通过weak_ptr来引用子对象, 当调用子对象时, 通过lock()判断子对象是否存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; *ptr1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;int&gt; ptr2 = ptr1;                  // 错误：不能复制</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = std::<span class="built_in">move</span>(ptr1);          <span class="comment">// 转移所有权</span></span><br><span class="line">    std::cout &lt;&lt; *ptr2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sp = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">30</span>);</span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; wp = sp;                          <span class="comment">// 创建weak_ptr</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Use count: &quot;</span> &lt;&lt; sp.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> sp2 = wp.<span class="built_in">lock</span>()) &#123;                           <span class="comment">// 检weak_ptr检查资源是否有效</span></span><br><span class="line">        std::cout &lt;&lt; *sp2 &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp.<span class="built_in">reset</span>();                                           <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (wp.<span class="built_in">lock</span>() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resource no longer exists&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">Use count: <span class="number">1</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line">Resource no longer exists</span><br></pre></td></tr></table></figure><p>初始化</p><ol><li>局部变量，未初始化的为不确定值（即垃圾值）</li><li>静态变量，自动初始化为 0 或 NULL（指针类型），静态变量初始化只执行一次</li><li>全局变量，自动初始化为 0 或 NULL</li></ol><p>C++类变量规则</p><ol><li>普通成员变量, 必须在构造函数中显式初始化，未初始化的普通成员变量值是未定义的（包含随机值）</li><li>静态成员变量是类级别的，需要在类外初始化，自动初始化为 0 或 NULL（指针类型），静态变量初始化只执行一次</li><li>const变量必须在构造函数的初始化列表中初始化，初始化后不可修改</li><li>C++11 允许为 非静态成员变量 提供类内初始值。<strong>静态成员变量仍需在类外初始化。</strong></li><li>成员变量按 声明的顺序 初始化，与初始化列表的顺序无关。</li></ol><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>static, 静态变量。一个编译单元(.cpp)文件一个静态变量, <strong>静态变量不可跨编译单元共享</strong>，因此不能作为全局变量。全局变量（外部变量）跨.cpp文件，链接多文件共享；</p><ol><li>静态函数的定义一般放到头文件里, 如果放到.cpp文件，头文件被其他.cpp引用时, 由于静态函数无法变链接，其他.cpp文件会发生函数链接错误。</li></ol><p>const，表示常量，不可改变量。</p><ol><li>修饰函数表示函数不可修改类成员变量, 可通过mutable关键字修改。</li></ol><p>volatile，告诉编译器不要对该变量进行优化。常用于 多线程编程 或 硬件编程，避免编译器对变量的访问进行优化。</p><p>extern，声明变量或函数在其他文件中定义。它不分配存储空间，只是告诉编译器该变量在其他地方定义过。链接时全局变量在多个文件共享。</p><p>mutable 用来修饰类中的成员变量，即使类的对象是 const 类型，成员变量仍然可以被修改。</p><h4 id="C-编译类型推导"><a href="#C-编译类型推导" class="headerlink" title="C++ 编译类型推导"></a>C++ 编译类型推导</h4><p>C++ 编译期静态类型推导</p><p>C++ 14 允许 Lambda 参数使用 auto 类型推导</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">lambda</span>(<span class="number">3</span>, <span class="number">5</span>);     <span class="comment">// 8</span></span><br><span class="line"><span class="type">double</span> b = <span class="built_in">lambda</span>(<span class="number">2.5</span>, <span class="number">3</span>); <span class="comment">// 5.5</span></span><br></pre></td></tr></table></figure><p>支持返回类型推导, decltype(auto)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回类型自动推导</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保留引用语义</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) ref = (x); <span class="comment">// int&amp; 类型</span></span><br></pre></td></tr></table></figure><p>constexpr，修饰函数和表达式，尝试在编译期就给出计算结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Circle</span><span class="params">(<span class="type">double</span> r)</span> : radius(r) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> radius * radius * <span class="number">3.1415</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Circle <span class="title">c</span><span class="params">(<span class="number">2.0</span>)</span></span>;</span><br><span class="line"><span class="built_in">static_assert</span>(c.<span class="built_in">area</span>() &gt; <span class="number">12.0</span>, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p>结构化绑定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::pair&lt;<span class="type">int</span>, std::string&gt; data&#123;<span class="number">42</span>, <span class="string">&quot;Alice&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [id, name] = data; <span class="comment">// id=42, name=&quot;Alice&quot;</span></span><br></pre></td></tr></table></figure><h3 id="C-模版编程"><a href="#C-模版编程" class="headerlink" title="C++ 模版编程"></a>C++ 模版编程</h3><p>既然讲到类型, 就离不开C++模版编程, 编译期类型</p><h4 id="value-和-type"><a href="#value-和-type" class="headerlink" title="::value 和::type"></a>::value 和::type</h4><p><code>::value</code> 和 <code>::type</code> 是两种常见的成员访问形式，用于从 ​类型特性（Type Traits）​ 或 ​元函数（Metafunctions）​ 中提取信息</p><p><code>::value</code> 用于从 ​类型特性 中提取一个 ​编译时常量值​（通常是布尔值），表示某种类型或条件的静态属性。</p><ul><li>类型检查：检查类型是否符合特定条件（如是否是整数、指针、类类型等）。</li><li>​数值提取：获取类型关联的静态数值（如数组维度、对齐值等）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 T 是否是整数类型</span></span><br><span class="line"><span class="built_in">static_assert</span>(std::is_integral&lt;<span class="type">int</span>&gt;::value, <span class="string">&quot;int 是整型&quot;</span>);  <span class="comment">// 通过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类型的对齐值</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> align = std::alignment_of&lt;<span class="type">double</span>&gt;::value;  <span class="comment">// 通常是 8</span></span><br></pre></td></tr></table></figure><p><code>::type</code> 用于从 ​<strong>元函数</strong> 中提取一个 ​<strong>类型</strong>，常用于类型转换或条件编译。</p><ul><li>​类型转换：生成与输入类型相关的新类型（如移除引用、添加常量等）。</li><li>​条件分支：通过 <code>std::enable_if</code> 控制模板的启用或禁用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除类型的引用</span></span><br><span class="line"><span class="keyword">using</span> NakedType = std::remove_reference&lt;<span class="type">int</span>&amp;&gt;::type;  <span class="comment">// NakedType = int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件启用模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">(T value)</span> </span>&#123; <span class="keyword">return</span> value * <span class="number">2</span>; &#125;</span><br></pre></td></tr></table></figure><p>在模板中访问 ​<strong>依赖名称（Dependent Name）​</strong> 的 <code>::type</code> ​<strong>必须</strong> 使用 <code>typename</code> 关键字，以明确告知编译器这是一个类型而非静态成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 正确：typename 告诉编译器 std::remove_reference&lt;T&gt;::type 是类型</span></span><br><span class="line">    <span class="keyword">using</span> NakedT = <span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误：缺少 typename，编译器认为 ::type 是静态成员</span></span><br><span class="line">    <span class="keyword">using</span> WrongT = std::remove_reference&lt;T&gt;::type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模版匹配规则"><a href="#模版匹配规则" class="headerlink" title="模版匹配规则"></a>模版匹配规则</h4><p>类模板的匹配优先级为：</p><ol><li>​完全特化版本​（全参数指定）。</li><li>​部分特化版本​（部分参数特化）。</li><li>​主模板。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123; <span class="comment">/* 通用实现 */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分特化：当 U 是 T 的指针时</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span>&lt;T, U*&gt; &#123; <span class="comment">/* 指针特化 */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完全特化：当 T=int, U=double 时</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>, <span class="type">double</span>&gt; &#123; <span class="comment">/* 完全特化 */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass&lt;<span class="type">int</span>, <span class="type">double</span>&gt; a;    <span class="comment">// 使用完全特化</span></span><br><span class="line">    MyClass&lt;<span class="type">float</span>, <span class="type">int</span>*&gt; b;    <span class="comment">// 使用部分特化</span></span><br><span class="line">    MyClass&lt;<span class="type">char</span>, <span class="type">bool</span>&gt; c;     <span class="comment">// 使用主模板</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数匹配规则</p><ol><li>​非模板函数​（如果有精确匹配）。</li><li>​最特化的模板函数​（通过参数推导和约束判断）。</li><li>​通用模板函数。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;通用模板\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化版本（对指针类型）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T*)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;指针特化\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非模板函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>*)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;非模板函数\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">foo</span>(p);  <span class="comment">// 输出：非模板函数</span></span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">42</span>); <span class="comment">// 输出：通用模板</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++20 引入 ​<strong>概念（Concepts）​</strong>，允许更直观地约束模板参数，改变匹配逻辑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">requires</span> std::integral&lt;T&gt;  <span class="comment">// 约束 T 为整数类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T value)</span> </span>&#123; <span class="comment">/* 整数处理 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">requires</span> std::floating_point&lt;T&gt;  <span class="comment">// 约束 T 为浮点类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T value)</span> </span>&#123; <span class="comment">/* 浮点处理 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(<span class="number">42</span>);    <span class="comment">// 匹配整数版本</span></span><br><span class="line">    <span class="built_in">process</span>(<span class="number">3.14</span>);  <span class="comment">// 匹配浮点版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SFINAE（替换失败并非错误"><a href="#SFINAE（替换失败并非错误" class="headerlink" title="SFINAE（替换失败并非错误"></a>SFINAE（替换失败并非错误</h4><p>SFINAE（替换失败并非错误）是C++模板元编程中的核心原则，其核心思想是：​在模板实例化过程中，如果替换（Substitution）模板参数导致无效代码，编译器不会报错，而是将该候选从重载集中剔除，继续寻找其他合法候选。</p><ul><li>当调用一个函数或使用类模板时，编译器会尝试推导模板参数，并生成具体的代码（实例化）。</li><li>如果替换模板参数后生成的代码无效​（例如访问不存在的成员、类型不兼容），编译器不会抛出错误，而是静默忽略该候选，继续尝试其他可能的重载或模板。</li><li>若替换成功但实例化后的代码在函数体内报错​（如无效操作），编译器仍会报错。</li></ul><p>可以直接设置根据不同类型提供不同的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅对整数类型有效</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value, <span class="type">void</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 整数处理逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅对浮点类型有效</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, <span class="type">void</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 浮点处理逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(<span class="number">42</span>);    <span class="comment">// 调用整数版本</span></span><br><span class="line">    <span class="built_in">process</span>(<span class="number">3.14</span>);  <span class="comment">// 调用浮点版本</span></span><br><span class="line">    <span class="comment">// process(&quot;hello&quot;);  // 无匹配候选，编译报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模版特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Enable = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Container;  <span class="comment">// 主模板未定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化：仅支持可迭代类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span>&lt;T, <span class="keyword">typename</span> std::enable_if&lt;has_iterator&lt;T&gt;::value&gt;::type&gt; &#123;</span><br><span class="line">    <span class="comment">// 实现...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="std-enable-if"><a href="#std-enable-if" class="headerlink" title="std::enable_if"></a>std::enable_if</h4><p>std::enable_if的作用是条件编译，</p><p>基于 SFINAE（Substitution Failure Is Not An Error）原则。它允许根据类型特性或编译时条件启用或禁用特定的函数重载或模板特化。</p><p><code>std::enable_if&lt;Condition, T&gt;::type</code>：如果 <code>Condition</code> 为 <code>true</code>，则 <code>std::enable_if</code> 的 <code>type</code> 成员是 <code>T</code>；否则，<code>std::enable_if</code> 没有 <code>type</code> 成员，这会导致模板实例化失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅对整数类型有效</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value, <span class="type">void</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实现整数处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅对浮点类型有效</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, <span class="type">void</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实现浮点处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时和运行时的一个优势是，编译期能知道类型信息。<br>C++ type_traits提供<code>std::is_integral</code> 是用于在编译时检查某个类型是否为 ​整型（整数类型）​。</p><p>以下类型std::is_integral返回tree</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">​有符号整型：signed char, short, int, long, long long</span><br><span class="line">​无符号整型：unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long</span><br></pre></td></tr></table></figure><p><code>std::is_floating_point</code>：检查浮点类型</p><p><code>std::is_arithmetic</code>：检查算术类型（整型 + 浮点型）。</p><p><code>std::is_signed</code>：检查类型是否有符号。</p><h4 id="模版实例化失败"><a href="#模版实例化失败" class="headerlink" title="模版实例化失败"></a>模版实例化失败</h4><ol><li>类型不满足模版约束</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    value.<span class="built_in">print</span>(); <span class="comment">// 若 T 无 print() 成员函数，实例化失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span> &#123; <span class="comment">/* 无 print() 方法 */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Data d;</span><br><span class="line">    <span class="built_in">print</span>(d); <span class="comment">// 错误：&#x27;Data&#x27; 没有成员 &#x27;print&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>static_assert</code> 提前验证类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(has_print_method&lt;T&gt;, <span class="string">&quot;T must have print()&quot;</span>);</span><br><span class="line">    value.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 ​C++20 概念（Concepts）​ 约束模板参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">requires</span> <span class="title">requires</span><span class="params">(T t)</span> </span>&#123; t.<span class="built_in">print</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    value.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>模版参数不匹配</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Array&lt;std::string, <span class="number">-5</span>&gt; arr; <span class="comment">// 错误：非类型模板参数 N 为负数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>依赖名称未正确解析</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T::value_type data; <span class="comment">// 若 T 无 value_type 成员，实例化失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyType</span> &#123; <span class="comment">/* 无 value_type 定义 */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>&lt;MyType&gt;(); <span class="comment">// 错误：&#x27;value_type&#x27; 未声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>typename</code> 明确依赖名称</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> T::value_type data;</span><br></pre></td></tr></table></figure><h4 id="模版头文件"><a href="#模版头文件" class="headerlink" title="模版头文件"></a>模版头文件</h4><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><p><strong>JAVA所有类型和函数都是写到类</strong>中，类名和文件名相同。main函数是在主类中定义的static函数。JAVA没有全局变量，因为所有变量都是在类中。</p><p>JAVA基本类型变量存储在栈中，引用类型变量存储在堆中。引用类型变量使用new创建，jvm的垃圾回收模块负责对象回收。JAVA的变量都会初始化，不会有随机值。</p><p>JAV<em>A</em>类最大的特点是动态加载（按需加载）<strong>，类静态变量和静态模块随着类加载而初始化和执行，</strong>如果某类无须被加载，则不会执行该类中的静态变量和静态块。**</p><ol><li>类的加载通常是在访问类的静态成员（如静态字段、静态方法）或创建类的实例时触发的。</li><li>类加载器会在需要时加载类，不会提前加载。</li></ol><p>JAVA运算符基本和C++一致，除了</p><ol><li>取消指针和引用相关运算符，包括<code>*</code>, <code>-&gt;</code>, <code>&amp;</code></li></ol><p>JAVA类型默认值是0, JAVA的boolean型不再和整型互通</p><p>基本数据类型, 存储值本身, 参数会选择传值本身</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">数据类型存储大小（字节）</span><br><span class="line"><span class="type">byte</span><span class="number">1</span></span><br><span class="line"><span class="type">short</span><span class="number">2</span></span><br><span class="line"><span class="type">int</span>    <span class="number">4</span></span><br><span class="line"><span class="type">long</span><span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span><span class="number">4</span></span><br><span class="line"><span class="type">double</span><span class="number">8</span></span><br><span class="line"><span class="type">char</span><span class="number">2</span> (unicode范围)</span><br><span class="line"><span class="type">boolean</span>依赖 JVM 实现</span><br></pre></td></tr></table></figure><p>引用类型, 存储对象的引用。引用类型默认值是null, 参数会选择传引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED, GREEN, BLUE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JAVA提供包装类型为基本数据类型提供引用, 默认值是null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">基本数据类型包装类型</span><br><span class="line"><span class="type">byte</span>Byte</span><br><span class="line"><span class="type">short</span>Short</span><br><span class="line"><span class="type">int</span>Integer</span><br><span class="line"><span class="type">long</span>Long</span><br><span class="line"><span class="type">float</span>Float</span><br><span class="line"><span class="type">double</span>Double</span><br><span class="line"><span class="type">char</span>Character</span><br><span class="line"><span class="type">boolean</span>Boolean</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      System.out.println(x.compareTo(y));</span><br><span class="line">      System.out.println(x.equals(y));</span><br><span class="line">      System.out.println(z==<span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>JAVA包装类型的常用函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer.valueOf(<span class="type">int</span> i) <span class="comment">// 返回表示基本类型的Integer对象</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x.intValue(); <span class="comment">// 返回包装对象的 int 值, 同样还有doubleValue等</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">System.out.println(x.compareTo(y)); <span class="comment">// 比较</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>  <span class="comment">// 比较两个对象的值是否相等。</span></span><br></pre></td></tr></table></figure><p>JAVA 通过(type)实现显式转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> dog;  <span class="comment">// 子类对象自动转换为父类引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal;  <span class="comment">// 强制将父类引用转换为子类类型, 向下转型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog) &#123;  <span class="comment">// instanceof 检查对象是否是某个类型</span></span><br><span class="line">    <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JAVA中，所有类都直接或间接继承自 Object 类。Object类提供的成员方法, 也就是任何都有以下方法，也可以重载以下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br></pre></td></tr></table></figure><h4 id="变量访问控制和修饰"><a href="#变量访问控制和修饰" class="headerlink" title="变量访问控制和修饰"></a>变量访问控制和修饰</h4><p>Java中，如果需要使用其他包中的类，必须利用import显式地导入它们。import 语句只能导入类，而不能导入方法、字段</p><p>Java 的访问控制包括四种权限：</p><ol><li>public：类或成员可以被任何类访问。</li><li>protected：类或成员可以被同一个包中的类或子类访问。</li><li>default（无修饰符）：类或成员只能被同一个包中的类访问。</li><li>private：类或成员只能在当前类内部访问。</li></ol><p>包名通常采用 小写字母，以避免与类名的命名冲突。</p><p>包名通常使用 反向域名，例如 com.example.myapp。这种做法避免了不同公司或组织的包名冲突。</p><p>除了类，java的变量和函数也有访问修饰符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public：变量可以被任何其他类访问，无论它们在同一包中还是不同的包中。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> x;</span><br><span class="line"><span class="comment">// protected：变量可以被同一包中的类或继承自该类的子类访问</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> y;</span><br><span class="line"><span class="comment">// default（无修饰符）：变量的默认访问权限是包级访问（包私有）。</span></span><br><span class="line"><span class="type">int</span> z; </span><br><span class="line"><span class="comment">// private：变量只能在当前类内部访问</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> a;</span><br></pre></td></tr></table></figure><p>static，声明为 static 为静态变量，属于类。</p><p>final，声明为 final 的变量是常量，初始化之后不能再修改。final修饰函数表示该函数不能被重写</p><p>volatile 变量会告诉 Java 虚拟机（JVM）每次访问该变量时都要从内存中读取，而不是从缓存中读取。通常用于多线程编程中，确保变量的可见性。</p><p>synchronized 主要用于方法，确保同一时刻只有一个线程能执行该方法。</p><p>native 关键字用于声明本地方法，这些方法通过 JNI（Java Native Interface）调用非 Java 语言（如 C、C++）编写的代码。native通常用于方法声明。</p><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>由于java是动态加载类, 这让java 具有利用反射动态加载类, 这催生了spring ioc框架。如果要根据字符串的内容匹配对应的类&#x2F;函数，C++和go都要维护一个(string-&gt;函数)的map，但java可以直接通过类名来动态加载类。java利用反射动态加载类分两步1. 获取class类 2.加载class类</p><p>获取class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类名.class</span></span><br><span class="line">Class&lt;String&gt; stringClass = String.class;</span><br><span class="line"><span class="comment">// 对象.getClass()</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">Class&lt;?&gt; strClass = str.getClass();</span><br><span class="line"><span class="comment">// ​​Class.forName(&quot;全限定类名&quot;)</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure><p>利用反射调用方法，修改变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;methodName&quot;</span>, parameterTypes);</span><br><span class="line">method.setAccessible(<span class="literal">true</span>); <span class="comment">// 访问私有方法</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(obj, args);</span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;fieldName&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>); <span class="comment">// 访问私有字段</span></span><br><span class="line">field.set(obj, value);     <span class="comment">// 设置字段值</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> field.get(obj); <span class="comment">// 获取字段值</span></span><br></pre></td></tr></table></figure><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p>Golang的运算符和C++的类似，区别主要是指针类型。Go指针类型不支持算术运算，只支持引用和解引用运算。Go指针零值是nil, 获取成员变量用<code>.</code></p><p>golang可以使用 new 分配内存，并返回指针。对切片、map、channel、interface，golang可以使用make函数分配内存和初始化。</p><p>golang可以使用<code>var xxx type</code>声明变量，<code>var xxx = value</code>或<code>xxx := value</code>声明变量并赋值</p><p>当变量的生命周期仅限于当前函数时（不用new构造的对象），Go 会尽量将其分配到栈上。堆内存，通常分配给引用类型(slice, map, channel, pointer)或者使用new创建变量且变量的地址被传递到函数外部。</p><p>Go 变量的访问控制。全局定义的小写字母只能包内访问，大写字母可以跨包访问。访问其他包的变量需要先import。golang 提供struct组合代替继承（C++继承内部的实现就是组合）。</p><ol><li>匿名嵌入的结构体方法会被​​提升（Promote）​​到外层结构体。</li><li>若外层结构体定义了同名方法，会​​覆盖​​嵌入结构体的方法</li></ol><p>golang支持的类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是值类型</span></span><br><span class="line"><span class="type">bool</span><span class="number">1</span></span><br><span class="line"><span class="type">byte</span><span class="number">1</span></span><br><span class="line"><span class="type">int32</span>, <span class="type">uint32</span><span class="number">4</span></span><br><span class="line"><span class="type">int64</span>, <span class="type">uint64</span><span class="number">8</span></span><br><span class="line"><span class="type">float32</span><span class="number">4</span></span><br><span class="line"><span class="type">float64</span> <span class="number">8</span></span><br><span class="line">array</span><br><span class="line"><span class="keyword">struct</span></span><br><span class="line"><span class="type">string</span>（golang字符串不可修改，若想修改, 需要转成[]<span class="type">byte</span></span><br></pre></td></tr></table></figure><p>Go中只有强制类型转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int64</span> = <span class="type">int64</span>(a)  <span class="comment">// 必须显式转换</span></span><br><span class="line"><span class="keyword">var</span> c <span class="type">float64</span> = <span class="type">float64</span>(a)</span><br></pre></td></tr></table></figure><p>golang 可以通过直接赋值将struct转为接口, 同时通过类型断言将接口转换为具体类型（动态类型）。Golang中，所有struct都实现<code>interface&#123;&#125;</code>空接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="number">42</span> <span class="comment">// 接口存储了具体类型 int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型断言</span></span><br><span class="line">    value, ok := i.(<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Converted value:&quot;</span>, value) <span class="comment">// 输出：Converted value: 42</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Conversion failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反射-1"><a href="#反射-1" class="headerlink" title="反射"></a>反射</h4><p>golang 反射的目的是运行时获取对象的类型信息。一方面，golang不支持模版编程, 对象的静态类型信息也需要运行时获得（C++编译期就可以获得静态类型信息）。另一方面，动态类型信息同样需要运行时获得。(golang的这个反射不支持根据字符串动态获取对象, 和C++ 的动态类型差不多)</p><p>golang 的struct 统一实现了interface{}。interface{}包含了类型信息和对象指针。因此golang静态类型和动态类型信息都是借助interface获得。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类型信息</span></span><br><span class="line">x := <span class="number">3.14</span></span><br><span class="line">t := reflect.TypeOf(x)  <span class="comment">// t.Kind() 返回 reflect.Float64</span></span><br><span class="line">fmt.Println(t.Name())   <span class="comment">// 输出: float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取值</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(v.Float())  <span class="comment">// 输出: 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改值</span></span><br><span class="line">p := reflect.ValueOf(&amp;x)</span><br><span class="line">v := p.Elem()           <span class="comment">// 获取指针指向的值</span></span><br><span class="line">v.SetFloat(<span class="number">6.28</span>)        <span class="comment">// 修改原变量 x 的值</span></span><br><span class="line">fmt.Println(x)          <span class="comment">// 输出: 6.28</span></span><br></pre></td></tr></table></figure><p>golang的多态依赖于interface{}，包括静态多态。例如json序列化提供的统一接口就是interface{}</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="type">byte</span>, v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>python类型比较特别, 把类型分为两类，可变类型和不可变类型。</p><p><strong>如果修改一个不可变对象，Python 将会创建一个新的对象</strong>。</p><ol><li>不可变类型包括整数（int）、浮点数（float）、字符串（str）、元组（tuple）等。</li><li>可变类型的值可以原地修改。可变对象包括列表（list）、字典（dict）、集合（set）等, class定义的类默认是可变类型</li></ol><p>不可变类型函数参数可以认为是值传递，可变类型函数参数可以认为是引用传递</p><p><strong>Python变量的类型是在运行时决定的，不需要显式声明。Python 不允许隐式类型转换。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">modify</span>(<span class="params">x</span>):</span><br><span class="line">    x = <span class="number">10</span></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line">modify(a)</span><br><span class="line"><span class="built_in">print</span>(a)  </span><br><span class="line"><span class="comment"># 输出：5，a的值未变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modify</span>(<span class="params">lst</span>):</span><br><span class="line">    lst.append(<span class="number">4</span>)</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">modify(nums)</span><br><span class="line"><span class="built_in">print</span>(nums)  </span><br><span class="line"><span class="comment"># 输出：[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>Python的类型如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">类型描述</span><br><span class="line"><span class="built_in">int</span>整型 支持任意大小</span><br><span class="line"><span class="built_in">float</span>浮点数</span><br><span class="line"><span class="built_in">complex</span>复数，形式为 a + bj</span><br><span class="line"><span class="built_in">bool</span>布尔值，<span class="literal">True</span> 和 <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span>Unicode 文本数据</span><br><span class="line">NoneType<span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>可变的有序集合  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">tuple</span>不可变的有序集合  (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">range</span>表示数字范围<span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>可变集合，支持哈希操作&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">dict</span>可变键值对集合&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">iterator迭代器<span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>类型检查和转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">42</span>))  <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="number">42</span>, <span class="built_in">int</span>))  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">x = <span class="built_in">int</span>(<span class="number">3.5</span>)   <span class="comment"># 3</span></span><br><span class="line">y = <span class="built_in">float</span>(<span class="number">3</span>)   <span class="comment"># 3.0</span></span><br><span class="line"></span><br><span class="line">lst = <span class="built_in">list</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))       <span class="comment"># [1, 2, 3]</span></span><br><span class="line">tpl = <span class="built_in">tuple</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])      <span class="comment"># (1, 2, 3)</span></span><br><span class="line">st = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>])      <span class="comment"># &#123;1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure><p><strong>Python局部变量区域可以访问全局变量，但无法修改全局变量</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>():</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">my_function()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>():</span><br><span class="line">    <span class="comment"># 修改全局变量需要在局部变量区加 global x</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    x=<span class="number">20</span></span><br><span class="line"></span><br><span class="line">my_function()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">UnboundLocalError: local variable <span class="string">&#x27;x&#x27;</span> referenced before assignment</span><br></pre></td></tr></table></figure><p><code>if __name__ == &quot;__main__&quot;</code>函数里可以正常修改全局变量（其余函数不行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>():</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    x=<span class="number">20</span></span><br><span class="line">    my_function()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><p>python无法对变量进行修饰，但可以通过@注解对函数进行修饰。例如@staticmethod，@classmethod</p><p>常见@注解</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@classmethod 装饰器定义类方法，允许方法访问类本身，而不是实例。</span><br><span class="line">@staticmethod 装饰器定义静态方法，静态方法不能访问实例和类本身</span><br><span class="line">@property 用于将类的方法变成一个只读属性</span><br></pre></td></tr></table></figure><p>python的操作符按照优先级排序为</p><ol><li>小括号<code>()</code></li><li>索引运算符 <code>x[i] 或 x[i1: i2 [:i3]]</code></li><li>属性访问 <code>x.attribute</code></li><li>乘方 <code>**</code></li><li>按位取反 <code>~</code></li><li>符号运算符 <code>+（正号）、-（负号）</code></li><li>乘除<code>*、/、//、%</code></li><li>加减<code>+、-</code></li><li>位移<code>&gt;&gt;、&lt;&lt;</code></li><li>按位与 <code>&amp;</code></li><li>按位异或<code>^</code></li><li>按位或<code>|</code></li><li>比较运算符<code>==、!=、&gt;、&gt;=、&lt;、&lt;=</code></li><li>is 运算符<code>is、is not</code></li><li>in 运算符 <code>in、not in</code></li><li>逻辑非 <code>not</code></li><li>逻辑与 <code>and</code></li><li>逻辑或 <code>or</code></li><li>逗号<code>exp1, exp2</code></li></ol><p>类似JAVA，在python中，object是所有类的基类。object类的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__init__(<span class="variable language_">self</span>)初始化方法，用于对象创建后初始化属性。</span><br><span class="line">__del__(<span class="variable language_">self</span>)析构方法，用于对象销毁时清理资源。</span><br><span class="line">__str__(<span class="variable language_">self</span>)返回对象的字符串表示，通常用于打印或转换为字符串时调用。</span><br><span class="line">__repr__(<span class="variable language_">self</span>)返回对象的官方表示，通常用于调试。</span><br><span class="line">__eq__(<span class="variable language_">self</span>, other)比较对象是否相等，默认比较引用地址，可重写实现值比较。</span><br><span class="line">__ne__(<span class="variable language_">self</span>, other)比较对象是否不等，默认基于 __eq__ 结果。</span><br><span class="line">__hash__(<span class="variable language_">self</span>)返回对象的哈希值，用于哈希表等数据结构。</span><br><span class="line">__getattribute__(<span class="variable language_">self</span>, name)获取对象属性的值，所有属性访问都会调用此方法，可重写以自定义行为。</span><br><span class="line">__setattr__(<span class="variable language_">self</span>, name, value)设置对象属性的值。</span><br><span class="line">__delattr__(<span class="variable language_">self</span>, name)删除对象属性。</span><br><span class="line">__dir__(<span class="variable language_">self</span>)返回对象的属性和方法列表，供 <span class="built_in">dir</span>() 函数使用。</span><br><span class="line">__class__返回对象的类。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> base </category>
          
      </categories>
      
      
        <tags>
            
            <tag> language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程语言(1)—概览</title>
      <link href="/2024/11/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(1)%E2%80%94%E6%A6%82%E8%A7%88/"/>
      <url>/2024/11/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(1)%E2%80%94%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<p>简谈C、C++、JAVA、Go、Python、Rust编程语言</p><span id="more"></span><p>C语言的特点</p><ol><li>原生的linux系统调用，linux系统就是C开发的，提供的系统调用是C语言函数接口。使用C语言开发的程序原生的可以利用操作系统提供的系统调用接口，执行进程管理、IO等操作。也正是由于C语言支持原生的系统调用，让C语言称为最好的linux系统二次开发语言。glibc，pthread等基础库都是C语言开发。</li><li>高自由度的指针来操纵内存。程序的指令、对象、数据本质就是排列的一段内存。通过操纵内存可以实现1. 数据零拷贝，高性能 2. 对象随意转型，随意引用对象的子变量 3. 函数类型指针。高灵活度提高了编写优秀C语言代码的难度。 </li><li>原生支持嵌入汇编语言。使用汇编语言能直接操纵CPU和寄存器，能不经由系统调用写出高性能的指令，例如设置CPU屏蔽中断。</li><li>C语言缺点也很明显，没有封装，标准库功能少。</li></ol><p>C++语言的特点</p><ol><li>兼容C语言，好处是具备C语言兼容系统调用、高性能指针等特点，缺点是C++实际没有禁止高自由度代码。兼容C语言的后果是, C++的一切规则都不是强制的规则，例如C++提供了智能指针，但程序员完全可以用写C的样子写C++，裸指针满天飞。C++空有一堆规范，但不要求强制遵守的规范很难起到效果。<a href="https://github.com/isocpp/CppCoreGuidelines">CppCoreGuidelines</a></li><li>C++ 类支持public、protected、private封装，继承，以及基于虚函数的多态。C++利用类的虚函数表和实例的虚函数指针实现了多态。C++ 还利用namespace 实现简单的包隔离。</li><li>包管理工具几乎没有。C++有cmake，bazel等较通用的编译工具，但至今没有通用的包管理工具。这是影响C++开发效率的重要原因，编译运行一个C++项目总是要在模块依赖上耗费大量时间。</li><li>标准库功能少。C++标准库主要有数据结构和算法库（STL）、标准IO库（基本没人用）、线程和同步库、智能指针库。没有常用的网络库、高级并发库（线程池，异步IO）、字符串处理库、文件系统IO库。这同样增加了C++开发的难度，重复造轮子现象严重。</li></ol><p>我不太推荐使用C++开发大型项目，即使C++项目有较高的编码规范要求，但开发期间如果项目周期缩短，“下周上线”、“能用就行”，那程序员会充分利用C++的“自由”，代码质量基本不能看了。对于把代码规范和安全交给程序员还是编译器的问题，我选择交给编译器。C++孱弱的包管理工具也让C++工程一旦开发完毕，后续的重构升级都很困难，“牵一发而动全身”。</p><p>JAVA语言的特点</p><ol><li>语言层对C++进行了扬弃，取消了指针，不需要手动管理内存。提供了全面的基础库，java.lang提供了字符串和线程类，java.util提供了容器类，java.io和java.nio提供了文件IO类，java.net提供网络类， java.util.concurrent提供并发编程支持。JAVA的基础库全面而有效，JAVA基础库的重复造轮子现象远远少于C++。</li><li>JAVA类函数默认所有实例方法都是虚函数，支持多态，final、static、private方法除外。但滥用虚函数会带来性能开销。</li><li>反射和spring框架提供了JAVA对象集中管理的能力，即所谓的控制反转。spring框架强制让程序员按照模块化，将不同的功能模块切分（AOP，面向切面编程）。JAVA程序员无须管理对象的创建（生命周期），专注于如何将分散在各个业务逻辑代码中相同的代码通过横向切割的方式抽取到一个独立的模块中。依赖框架的缺点也很明显，缺乏灵活性。</li><li>主要缺点是配置文件复杂，maven作为包管理工具配置比较复杂（可用gradle代替）。</li></ol><p>Go语言的特点</p><ol><li>语言实现对JAVA进行了扬弃，舍弃了public，protect, private封装只支持package封装，舍弃了继承用组合代替，扩展了并发库语言原生支持协程、广泛使用context、channel进行协程间通信，支持指针但不支持指针运算，重新定义了接口（只要struct实现了接口的所有方法，那就认为它实现了接口），采用默认规则（文件名以 _test.go 结尾的文件被认为是测试文件，以大写字母开头的标识符包外可见、小写包外不可见，提供 gofmt 工具统一代码格式）</li><li>包管理简单，大型项目只需要执行go build就可编译得到二进制文件，大大提高效率。</li></ol><p>Python语言特点</p><ol><li>对象定义简单, 例如{}定义map, []定义列表, ()定义元组，简单几行代码就可完成功能</li><li>自带丰富标准库和庞大扩展库，尤其是数据&#x2F;向量处理和机器学习算法库，如numpy, pandas, tensorflow, Matplotlib，lxml，python在数据处理和机器学习方面找不到语言替代者。</li><li>语法灵活，可简单可复杂。典型例子是装饰器，装饰器是一种函数修饰，用以减少通用代码。但装饰器被滥用，会严重降低代码可读性。python 函数参数没有类型检查，这导致直接从代码层面难以确定程序正确性，程序往往只有运行后才能知道问题（哪怕是很小的问题），加剧了“能用就行”的代码开发心态，同时降低了代码可读和可维护性。</li><li>虽然Python2已停止维护，但还有不少老项目还在使用python2，由于可维护性差，这些老项目难以迁移到python3。</li></ol><p>Rust 语言特点</p><ol><li>变量在默认不可变，有利于编译优化和可读性。</li><li>rust 语法上避免内存逃逸和多线程数据竞争。例如，rust 堆上变量等价于C++的unique_ptr, 复制等价于unique_ptr的移动语义，即对象所有权和转移，不会出现内存逃逸。同一作用域rust只允许一个可变引用、不允许可变引用与不可变引用同时存在，避免发生多指针写导致数据竞争。rust对于可变引用的限制是要避免多线程状态的数据安全问题，通过增加代码编写的限制和难度，来避免运行时可能的数据竞争问题。rust指针不受所有权限制，只能在unsafe块中使用</li><li>具有Cargo包管理器</li><li>TODO</li></ol>]]></content>
      
      
      <categories>
          
          <category> base </category>
          
      </categories>
      
      
        <tags>
            
            <tag> language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储——块、对象和文件存储</title>
      <link href="/2024/11/15/%E5%AD%98%E5%82%A8%E2%80%94%E5%9D%97%E3%80%81%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/"/>
      <url>/2024/11/15/%E5%AD%98%E5%82%A8%E2%80%94%E5%9D%97%E3%80%81%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<p>块存储、对象存储、文件存储是云计算云存储的概念，我想基于云存储，但也不限于云存储，谈谈自己的想法。</p><span id="more"></span><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>首先给出chatgpt对块、对象、文件存储的定义</p><p>块存储（Block Storage），是一种高性能存储技术，主要用于对结构化或非结构化数据进行低延迟、高效存储。它将数据划分为固定大小的“块”，每个块都有唯一的地址，独立存储于存储介质上。这种存储方式广泛用于云计算、数据库和虚拟化等场景。</p><p>文件存储（File Storage），是一种常见的数据存储方式，使用文件和文件夹的层次化结构来组织和管理数据。它类似于操作系统中的文件系统，提供直观的路径访问和共享功能，适用于多个客户端访问共享数据的场景。</p><p>对象存储是一种现代化的存储架构，专为存储大量非结构化数据而设计。它将数据存储为对象，并通过唯一的标识符（Object ID）进行访问，而不是使用传统的文件系统层次结构。对象存储以高可扩展性、弹性和低成本著称，是云计算和大规模数据存储的核心技术之一。</p><p>下面从我的角度给出以上名词定义的解释版本</p><h3 id="块存储"><a href="#块存储" class="headerlink" title="块存储"></a>块存储</h3><p>块存储功能上等价于一个块设备，linux 上可以使用lsblk 查看设备。在没有虚拟化情况下，一个块设备就是一块物理意义的硬盘。linux用sda，sdb, sdc表示块设备，块设备可以分区，例如sda1, sda2, sda3就是sda设备上的三个分区。linux 常用的分区工具是fdisk，每个块设备分区可以单独格式化文件系统（类似windows C, D等区）。</p><p>块存储的访问是在文件系统层下的，linux用户io会先走内核文件系统层，文件系统会维护（文件id，offset, length）到块设备的（设备号，块号）的映射，这种映射也可以理解成一种虚拟地址到物理地址的映射。一旦得到设备号和块号，对于本地存储，操作系统会调用驱动程序读写磁盘，并利用中断实现数据读写完毕后通知cpu处理。对于云存储，操作系统会携带（设备号，块号）发送网络包，同样注册中断实现网络包返回时通知cpu处理。一般而言，TCP协议网络包可以满足要求，如果追求高性能，就要涉及到用户态tcp协议，dpdk工具链，virtio协议规范，rdma高性能网络了。</p><p>根据块存储定义“它将数据划分为固定大小的“块”，每个块都有唯一的地址，独立存储于存储介质上”，可以得到<strong>块对齐</strong>的特点</p><ol><li>块存储的单位是“块”，<strong>块是固定大小的（通常为4KB）</strong>。相较之下，文件存储的单位“文件”（File），对象存储的单位“对象”（object），是任意大小的。</li><li>由于”块”是固定大小，例如4K，那<strong>读写iosize可以设计成4K对齐</strong>。这可以大大减小存储涉及的复杂性。如果读写大小是任意的，用户可以写<code>[1023, 1025]</code>, <code>[1022, 1026]</code>等任意区间，新区间数据还应该覆盖旧区间数据。可以想到，随着不断写入，区间数量线性增长，不仅占用大量内存，读操作还由于遍历所有区间导致性能下降。块存储的读写iosize设计成4K对齐的，用户只能4K对齐写，区间管理和读性能大大降低。</li></ol><p>写区间管理是存储的重要模块，称为layout管理，可以分析得到，<br>写区间越多-&gt;内存占用越多-&gt;读性能下降，写性能不受影响</p><p>除了固定大小和iosize外，块存储的另一个重要特点是，<strong>一个块每时每刻只会被一个ip主机访问，一个云硬盘每时每刻也只会被一个ip主机访问</strong>，这很关键，这意味着，如果我们把云硬盘划分成固定大小的segment（segment可以很大，例如16GB、32GB，因为云硬盘大小很大）。我们可以把相同云硬盘的多个segment调度到多机上，而不用考虑对多机加分布式锁，甚至不用加锁! 我们可以想象块存储架构的一般实现形式，只关心segment的调度和segment中的(devid, blockid)到实际物理存储的映射，每个server记录了某个segment (devid, blockid)到实际物理存储映射（索引表），根据索引表处理读写请求，而master记录了segment和server的调度计划，如果底层采用的是类似hdfs的分布式文件系统，只需要把<strong>索引表全量复制到其他server</strong>，就可以实现segment的调度。</p><p>如果允许多个ip同时访问一块云硬盘，可以想到，为了保证数据一致性，需要保证某ip请求写数据时，其他ip无法写数据，也就是加写锁。但如果一个segment永远只有一个ip读写数据，我们只需要保证io处理顺序和客户端发出的请求顺序一致，不需要加写锁！单ip访问的特点也让块存储优化读写路径变得容易，因为不需要考虑多客户端缓存&#x2F;数据一致性。</p><p>单ip访问导致块存储的缺点是，块存储不能多机共享。这是块存储的应用上的最大劣势。</p><p>总结块存储的三大特点</p><ol><li>功能等价硬盘</li><li>块和读写iosize 4K对齐，layout管理容易</li><li>每个块设备每时每刻只有一个ip访问</li></ol><h3 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h3><p>块存储相当于硬盘块设备，文件系统相当于ext4等文件系统。块存储访问的路径是，用户程序-&gt;虚拟文件系统-&gt;ext4等单机文件系统-&gt;网络层（TCP-&gt;IP-&gt;网卡）-&gt;后端；文件系统则是，用户程序-&gt;虚拟文件系统-&gt;网络层（TCP-&gt;IP-&gt;网卡）-&gt;后端。文件系统的网络层同样可以利用块存储介绍的用户态tcp协议，dpdk工具链，virtio协议规范，rdma高性能网络了来优化。</p><p>块存储遵循的网络协议常见的是iSCSI和NVMe-oF，前者更通用后者更追求性能。文件存储的网络协议Linux是NFS协议，Windows是SMB协议。其中，Linux 内核除了提供NFS模块之外，还提供fuse接口支持用户态自定义文件系统。</p><p>相比块存储协议主要是块读写，文件存储的协议更复杂。除读写外，还有rename（移动），readdir（读目录文件），link（软硬链接），文件锁等。文件协议的全部特性实现复杂，很多选择基于fuse自定义文件存储协议。</p><p>文件系统用N叉树来组织结构，或者说二元组（父目录handle，子文件name）。子文件和父目录常常相互影响，例如创建子目录后父目录link数量需要+1，子文件删除需要父目录加锁等</p><p>除了复杂的文件存储协议，文件存储另一个挑战是多客户端共享。和块存储不同，文件存储支持多客户端同时访问一个文件系统。这给文件存储实现带来很大困难</p><ol><li>文件系统元数据难以拆分。如果一个文件系统拆分成两部分，每部分位于一个节点。那么从机器A rename文件到机器B就要加分布式锁，保证只有一个请求执行rename，否则会导致死锁。分布式锁性能代价很大。事实上rename 的死锁问题在单机文件系统也存在，linux通过保证rename操作全局唯一来避免死锁，可以参考这个文章， <a href="http://www.linuxeden.com/html/sysadmin/20090903/67802.html">Linux文件系统中元数据的加锁机制与组织方式</a>。元数据不拆分会导致元数据iops受限于单机iops，一个文件系统只能位于某个节点，那该文件系统的元数据iops受制于单节点的iops（数据可以拆分到多个节点，因此读写iops和吞吐可以水平扩展）</li><li>readdir和remove 等语义实现困难，某客户端正在readdir，另一个客户端把目录或目录下的文件remove掉。可以对readdir的目录加读锁，删目录需要申请写锁；此外由于readdir 会分批返回，因此应该对readdir 的cookie文件进行软删除，使readdir 下次请求还可以在cookie文件处继续readdir，不受cookie文件删除影响。</li><li>复杂的元数据缓存。元数据缓存至少有inode缓存，缓存inode 的size, mode, link数量, atime&#x2F;ctime&#x2F;mtime等信息，加快getattr速度；dentry缓存，缓存目录项下的文件名，提高readdir速度。带来的问题就是, lookup，create,remove,rename会写dentry缓存（缓存穿透，会读后端，结果更新缓存），写期间需要对dentry加写锁，导致缓存无法被读写（相当于缓存失效），即dentry的所有请求都需要阻塞直到缓存更新好，会拖累元数据性能。方案是考虑多shot并发写后端元数据，读操作使用多版本，在写成功之前，只能读到写成功的数据。</li><li>客户端缓存一致性困难。客户端天然pagecache缓存是write-back缓存策略，多客户端同时写文件会不可避免的导致某客户端写入的数据无法被其他客户端感知的。处理方案，1.close-and-open一致性，即close文件会把数据刷到后端，从而被其他客户端看到 2. 定期刷到后端，nfsv3使用该策略，会牺牲一部分一致性 3. 使用文件锁，保证某文件同时刻只有一个客户端执行写操作，即保证1写多读。但文件锁的实现难点是服务端failover。nfsv3协议是无状态的，好处是服务端&#x2F;客户端崩溃后重新连接不用恢复状态；客户端文件锁实现要求协议具有状态，问题就是崩溃后需要状态恢复。</li></ol><p>块存储的块大小和iosize 4K对齐，对块存储的io区间管理（称为layout管理）降低了难度。不幸的是，文件存储对这俩都没要求，文件大小不固定，iosize也不固定。为了降低layout管理的复杂度，可以通过fuse自定义客户端让客户端发往后端的iosize尽量对齐。</p><p>文件存储的实现充满了折衷，例如元数据拆分能提高getattr，readdir等元数据操作的性能，但牺牲了rename的延迟和iops。客户端文件锁的实现提高了一致性和状态管理，但牺牲了客户端的多写能力。相对容易的文件存储实现架构是后端分为协议层、元数据层和数据层。协议层负责解析协议，转发，鉴权; 元数据层管理inode, dentry和hardlink表和元数据操作，数据层管理文件layout和读写；数据拆分，元数据不拆分；fuse实现自定义的客户端取代nfs。</p><p>总结文件存储的特点</p><ol><li>功能等价文件系统</li><li>块和读写iosize 不要求对齐，layout管理困难</li><li>支持多ip共享访问</li><li>协议复杂，实现多样。主要的调用有lookup, getattr, setaddr, access, read, write, link, symlink, readlink, readdir, readdirplus, remove，rename, fsstat等</li></ol><h3 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h3><p>对象存储是文件存储简化而来的，由于文件存储实现复杂，处处需要折衷，难以元数据拆分（水平扩展），无法提供稳定的高性能。</p><ol><li>文件存储元数据难以拆分的原因是其利用（目录，文件）构建的目录树结构，对象存储取消目录概念，文件全部通过对象路径hash查找。因此对象存储的元数据就是一个简单的hash表，hash表是容易多机拆分的。只需要1. 将对象路径hash到节点ip 2. 将对象路径hash到key。因此，对象存储bucket的元数据能力远超文件存储。前者元数据iops能达到几十万上百万，后者只有几万。</li><li>对象存储没有了目录概念，自然也没有了rename，link，目录锁概念。而rename，link是文件存储最难实现的调用之一。</li><li>对象存储只有object元数据缓存，没有dentry缓存，缺点就是对象存储的listobject 性能一般</li><li>对象存储的块大小定长且很大（高达1M），对象存储原生不支持对象的随机写和追加写，没有文件存储客户端锁保证一写多读和layout管理困难的问题。</li></ol><p>对象存储在读io上类似文件存储，支持对象随机读，只需要把路径&#x2F; 解析为目录；对象存储不支持写操作。如果要对象存储和文件存储结合使用，可以 1. 写io 写文件存储，文件存储后台tiering到对象存储 2. 读io 先读文件存储，文件存储不存在再读对象存储。</p><p>对象存储协议s3协议是一种http协议，也就是说对象存储支持浏览器互联网的访问，对象存储的服务环境更复杂，这让对象存储在鉴权、安全等方面建设比文件存储&#x2F;块存储更完善，后两者一般在高可信、高速网络中使用rpc调用。</p><p>总结对象存储的特点</p><ol><li>文件系统的简化版，无目录概念，支持海量客户端访问</li><li>s3协议是一种http协议，服务更广泛（块&#x2F;对象的主要服务对象是ecs&#x2F;gpu等计算单元）</li><li>支持随机读但不支持写，几乎不需要layout管理。元数据能力容易扩展。</li></ol><h3 id="layout管理"><a href="#layout管理" class="headerlink" title="layout管理"></a>layout管理</h3><ul><li>写操作</li></ul><p>块存储的layout，（设备号、块）-&gt;后台（文件id, offset），offset和length是4K对齐的</p><p>文件存储的layout，用户（文件inode, offset）-&gt; 后台（文件id, offset），offset和length可以不对齐</p><p>对象存储的layout，用户（objectid）-&gt;后台（文件id, offset）</p><ul><li>读操作</li></ul><p>块存储的layout，（设备号、块）-&gt;后台（文件id, offset, length），offset和length是4K对齐的，后台文件offset是最新的写入</p><p>文件存储的layout，用户（文件inode, offset, length）-&gt; 后台（文件id, offset, length），offset和length可以不对齐，offset是最新的写入</p><p>对象存储的layout，用户（objectid）-&gt;后台（文件id, offset）。直接记录object在后台文件存放的起始位置，即可随机读。对象存储没有覆盖写</p><p>块存储和文件存储由于支持随机覆盖写，读操作需要保证始终读到最新写入的offset，对象存储不支持随机写，读操作只需要找到object的起始位置即可。</p><h3 id="索引表的分裂和调度"><a href="#索引表的分裂和调度" class="headerlink" title="索引表的分裂和调度"></a>索引表的分裂和调度</h3><p>块存储&#x2F;文件存储的layout表，文件存储的元数据inode&#x2F;dentry表都要记录到KV存储中。KV存储的基本能力是，</p><ol><li>如果KV体积庞大，能分裂成两个KV；</li><li>KV可以调度到任何机器中</li></ol><p>如果KV的key是有序的，KV的分裂可以按照key来拆分，小于某key的为KV1，大于的为KV2。KV分裂依赖于复制，</p><ol><li>全量复制。对旧KV复制出两个新KV，复制过程没有发生数据的复制，只是数据的引用。KV内存态的信息记录在redolog，磁盘态的信息记录在SST文件。新的KV1，2 replay redolog生成内存态KV，根据区间引用SST获得磁盘态信息。全量复制应当是复制到某个checkpoint。</li><li>增量复制。增量复制的进度单位应该是inode，设备等物理概念，当一个inode全量复制完毕，后续该inode写操作即可在新KV上进行。逐渐过渡到全部inode，设备复制完毕，把旧KV清理掉。</li></ol><p>KV的调度也依赖于复制</p><ol><li>将旧KV在新节点上复制一份。同样是先全量复制，后增量复制。</li></ol>]]></content>
      
      
      <categories>
          
          <category> multi-machine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储——单机存储引擎B+树和LSM树</title>
      <link href="/2024/11/14/%E5%AD%98%E5%82%A8%E2%80%94%E5%8D%95%E6%9C%BA%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EB+%E6%A0%91%E5%92%8CLSM%E6%A0%91/"/>
      <url>/2024/11/14/%E5%AD%98%E5%82%A8%E2%80%94%E5%8D%95%E6%9C%BA%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EB+%E6%A0%91%E5%92%8CLSM%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>B+树和LSM树是最常见的单机存储引擎，前者代表是Mysql等事务性数据库，后者代表是Rocksdb等nosql KV数据库。</p><span id="more"></span><h3 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h3><p>B树是一种平衡的多叉树，通常说m 阶B树，树的阶指的是B树中节点的子节点数目的最大值。</p><p>B树必须满足如下条件：</p><ol><li>所有叶子节点都在同一层级；</li><li>除了根节点以外的<strong>其他节点包含的key值数量</strong>在<code>[m/2]-1</code>到<code>m-1</code>的数据范围；</li><li>除了根节点和叶子节点外，<strong>所有中间节点至少有m&#x2F;2个子节点</strong>；</li><li>根节点如果不是叶子节点的话，它必须包含至少2个孩子节点；</li><li><strong>拥有n-1个key值非叶子节点必须有n个孩子节点</strong>；这要求每个key的前后都有指向子节点的指针</li><li>一个节点的所有key值必须是升序排序的；</li></ol><p><img src="/../images/Btree.png" alt="Btree" title="Btree"></p><p>B+树是应文件系统所需而产生的 B 树的变形树。B+树的特征：</p><ol><li>B+树包含2种类型的节点：内部节点（也称索引节点）和叶子节点。根节点本身即可以是内部节点，也可以是叶子节点。</li><li>B+树与B树最大的不同是<strong>内部节点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子节点中；</strong></li><li>m阶B+树表示了内部节点最多有m-1个key（或者说内部节点最多有m个子树，和B树相同），<strong>阶数m同时限制了叶子节点最多存储m-1个记录</strong>；</li><li>内部节点中的key都按照从小到大的顺序排列，对于内部节点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子节点中的记录也按照key的大小排列；<br><strong>每个叶子节点都存有相邻叶子节点的指针</strong>，叶子节点本身依key的大小自小而大顺序链接；</li></ol><p><img src="/../images/B+tree.png" alt="B+tree" title="B+tree"></p><p>B+ 树相比 B 树，最大差异是<strong>非叶子节点不再存储具体数据，以及叶子节点是链表结构</strong>。非叶子节点不再存储具体数据，这使得 <strong>B+ 树更加扁平化</strong>，查找效率更高。叶子节点是链表结构，这使得 <strong>B+ 树更适合用在范围查找</strong>的场景中。</p><p>在Mysql的InnoDB中，每个数据表的索引都会有一个B+树维护。在主键索引中，B+树的节点是16K固定大小的page，page内部由记录链表构成，每个记录的key是主键，value则是行数据。B+树查询相当于一个巨大的二分查找，先根据主键和区间定位到主键所属的page，然后在page内部遍历记录链表找到key所在的记录和行数据。</p><p>B+树的优势</p><ol><li>B+树的非叶子节点不存储数据，内存可以容纳，实际磁盘IO数量只有访问叶子节点的一次。</li><li>B+树叶子节点有序，互相有链接，范围查询能充分利用磁盘的顺序读优势</li><li>B+树的节点是固定大小的page，page对齐落盘。但如果数据页没有在cache，写操作需要等待数据页从磁盘中读取，写性能不如读</li></ol><h3 id="LSM树"><a href="#LSM树" class="headerlink" title="LSM树"></a>LSM树</h3><p>LSM（Log-Structured Merge Tree）相比B+树，写性能高，读性能稍逊。</p><p>LSM 树由两部分组成：</p><ol><li>MemTable（内存表）</li></ol><p>是一个可变的有序数据结构（如红黑树或跳表），存储数据的最新写入。使用redolog保证memtable的数据安全，写操作先顺序写redolog和MemTable，提高写性能。</p><ol start="2"><li>SSTable（Sorted String Table）</li></ol><p>当 MemTable 达到一定大小时，会作为SSTable文件写入磁盘。SSTable 是不可变的。<br>SSTable 通常通过多个层级组织，使用compaction策略减少存储。</p><p>LSM的特点</p><ol><li>写性能高</li><li>读性能不稳定，随着需要读的数据位置层次由高到低，读性能逐渐下降。读操作存在大量不必要的磁盘读操作，可用布隆过滤器缓解</li><li>写放大，写操作先写redolog和memtable，memtable后台dump到sst, 旧sst再重新comapction到新的sst，后台存在大量读写。大量写放大可能增加磁盘IO压力影响前台IO，磁盘寿命。</li><li>空间放大。更新键和删除键同样写入到redolog和memtable，不同层级的SSTable可能存在相同但新旧不同的键。</li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> single-machine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> single-machine </tag>
            
            <tag> storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux系统(2)——内存和IO网络</title>
      <link href="/2024/11/10/linux%E7%B3%BB%E7%BB%9F(2)%E2%80%94%E5%86%85%E5%AD%98%E5%92%8CIO%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/11/10/linux%E7%B3%BB%E7%BB%9F(2)%E2%80%94%E5%86%85%E5%AD%98%E5%92%8CIO%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>linux操作系统大致可分为进程管理、进程协调、内存管理、文件系统、网络管理等五大部分。本文讲述内存管理、文件系统、IO&#x2F;网络管理。</p><span id="more"></span><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>linux 内部管理的核心就是把虚拟内存映射到物理内存。</p><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>为什么需要虚拟内存？</p><ol><li>虚拟内存下，用户程序无法感知真实的物理内存地址，避免用户程序直接操纵物理内存带来的风险</li><li>虚拟内存下，所有用户程序的虚拟地址是一致的，32位系统是2^32&#x3D;4GB，64位系统是2^64。操作系统给进程一致的抽象，而内部实现上，可能是物理内存，也可能是磁盘swap空间的换页。</li></ol><p>有虚拟内存和物理内存，就需要管理两种内存的映射（layout管理）。</p><h4 id="虚拟内存映射"><a href="#虚拟内存映射" class="headerlink" title="虚拟内存映射"></a>虚拟内存映射</h4><p>虚拟内存，内存由固定大小（4K）的页page组成。物理内存，内存由4K固定大小的页框Frame组.</p><p>虚拟内存地址由两部分组成：<br>页号（Page Number），定位页表中的条目。<br>页内偏移量（Offset），定位页框内的具体位置。 </p><p>虚拟内存映射过程</p><ol><li>根据虚拟地址中的页号，查找页表中的对应条目，找到物理页框。</li><li>根据页内偏移量，确定具体物理地址。</li></ol><p>页表，<strong>每个进程维护一个页表</strong>，记录虚拟内存page到物理地址frame的映射。执行虚拟内存到物理内存地址映射的是MMU单元，MMU是一个硬件，传入进程和虚拟地址，它首选使用TLB缓存，缓存不命中则去内存查找进程页表记录的物理地址。</p><p>操作系统中的页表一般是多级页表（四级），多级页表避可以避免单表过大，按需分配子页表，当进程申请内存时才创建页表，降低内存消耗。</p><h4 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h4><p>上面说到，内存会对虚拟和物理内存空间划分为固定大小的连续内存块，称为页（Page），也就是内存分页。在Linux下，每一页的大小通常为4KB。虚拟地址与物理地址之间通过页表进行映射。</p><p>除了分页，虚拟内存还会将进程地址空间的用户区域分段，地址从高到低分别是栈、内存内核空间映射区域、堆、已初始化数据段 (.data)、未初始化数据段 (.bss) 、代码段 (.text)。初始化数据段包括已初始化的全局变量和静态变量，未初始化数据段则包括未初始化的全局变量 和 静态变量，在程序运行时会被自动初始化为 0。.bss 段在可执行文件中不占用实际空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------+ 高地址</span><br><span class="line">|        栈 (Stack)           | 动态分配，向下增长</span><br><span class="line">+-----------------------------+</span><br><span class="line">|       内核映射区域          | 受保护的内核空间</span><br><span class="line">+-----------------------------+</span><br><span class="line">|          堆 (Heap)          | 动态分配，向上增长</span><br><span class="line">+-----------------------------+</span><br><span class="line">|     已初始化数据段 (.data)   |</span><br><span class="line">+-----------------------------+</span><br><span class="line">|   未初始化数据段 (.bss)      |</span><br><span class="line">+-----------------------------+</span><br><span class="line">|        代码段 (.text)        | 固定大小，只读</span><br><span class="line">+-----------------------------+ 低地址</span><br></pre></td></tr></table></figure><p>linux使用<strong>伙伴系统算法(Buddy system)管理物理内存的页框</strong>frame。把空闲页框分组为11个块链表，每个块链表分别包含大小为1，2，4，8，16，32，64，128，256，512和1024个连续页框的页框块。Buddy system算法物理内存分配的最小单位是页框，由于任何整数可以由若干2^n的和组成，在内存足够的情况下，任意数量的页框Buddy算法都可配置。</p><p>slab分配器负责管理少于一个页框的小内存，分配内存以Byte为单位。每个SLAB 包含若干个同类型的对象，这些对象通常大小相同。内核为常用的内核对象（如任务结构、网络缓冲区）建立的 Cache，Cache 负责管理slab对象的分配、初始化、释放等操作。</p><p>slab分配器的对象是内核结构体，用户程序、文件的内存分配直接使用buddy算法分配4K对齐的内存。而ptmalloc, tcmalloc等内存分配器是在buddy算法已经分配的物理页的页内部进一步分配。</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统可以认为是linux系统的用户界面。启动linux系统后，呈现在用户眼前的是文件系统，用户编写时程序、运行指令是在文件系统。用户感知不到进程、内存的存在，只能感知到目录、文件的存在。</p><h4 id="文件系统外层"><a href="#文件系统外层" class="headerlink" title="文件系统外层"></a>文件系统外层</h4><p>文件系统的外层提供文件属主、权限功能。文件属主提供了多用户访问操作系统的能力，每个文件提供属主owner，用户组group，其他组other的权限隔离和读r、写w、可执行x 三种权限。linux的用户信息记录在&#x2F;etc&#x2F;passwd文件，用户组信息记录在&#x2F;etc&#x2F;group文件。</p><p>文件由数据和元数据组成，文件的元数据包括文件类型、文件权限、文件所有权，文件时间戳atime, ctime, mtime，文件大小，硬链接数，inode号，块大小和块数量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件类型</span></span><br><span class="line">-：普通文件</span><br><span class="line">d：目录</span><br><span class="line">l：符号链接</span><br><span class="line">b：块设备</span><br><span class="line">c：字符设备</span><br><span class="line">p：命名管道</span><br><span class="line">s：套接字</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件权限，三组三位表示（rwxrwxrwx）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件所有权，包括文件所有者的用户 ID，文件所属组的组 ID。</span></span><br></pre></td></tr></table></figure><h4 id="文件fd"><a href="#文件fd" class="headerlink" title="文件fd"></a>文件fd</h4><p>文件fd是进程内部标识文件的方法，文件inode则是文件系统内部标识文件。因此应当管理映射（进程id，fd）-&gt;（文件系统id，文件inode）。</p><p>进程会使用file对象维护进程已经打开的文件, file对象会记录当前文件偏移量、文件的访问模式（如只读、只写）、指向inode的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">file</span> &#123;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">llist_node</span>fu_llist;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rcu_head</span> fu_rcuhead;</span><br><span class="line">&#125; f_u;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">path</span>f_path;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">inode</span>*f_inode;<span class="comment">/* cached value */</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span>*f_op;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Protects f_ep_links, f_flags.</span></span><br><span class="line"><span class="comment"> * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">spinlock_t</span>f_lock;</span><br><span class="line"><span class="type">atomic_long_t</span>f_count;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> f_flags;</span><br><span class="line"><span class="type">fmode_t</span>f_mode;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mutex</span>f_pos_lock;</span><br><span class="line"><span class="type">loff_t</span>f_pos;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fown_struct</span>f_owner;</span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">cred</span>*f_cred;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">file_ra_state</span>f_ra;</span><br><span class="line"></span><br><span class="line">u64f_version;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">address_space</span>*f_mapping;</span><br><span class="line">&#125; __attribute__((<span class="built_in">aligned</span>(<span class="number">4</span>)));<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">file_operations</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">module</span> *owner;</span><br><span class="line"><span class="built_in">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line"><span class="built_in">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="built_in">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="built_in">ssize_t</span> (*read_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line"><span class="built_in">ssize_t</span> (*write_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line"><span class="built_in">int</span> (*iterate) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line"><span class="built_in">int</span> (*iterate_shared) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span></span>;</span><br><span class="line"><span class="built_in">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="built_in">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="built_in">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line"><span class="built_in">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="built_in">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line"><span class="built_in">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="built_in">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line"><span class="built_in">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line"><span class="built_in">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line"><span class="built_in">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span></span>;</span><br><span class="line"><span class="built_in">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line"><span class="built_in">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line"><span class="built_in">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="built_in">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="built_in">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **, <span class="type">void</span> **);</span><br><span class="line"><span class="built_in">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,</span><br><span class="line">  <span class="type">loff_t</span> len);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="文件inode"><a href="#文件inode" class="headerlink" title="文件inode"></a>文件inode</h4><p>inode 需要管理文件使用page cache的页框，这是物理内存。inode使用address_space这个结构管理page cache的页框。adress_space采用基数树管理inode的页，为什么不使用链表？链表查找慢O(n)；为什么不使用数组?数据查找虽然快，但删除（即淘汰一个page）慢。</p><p>address_space负责从page cache申请空闲内存页，跟踪文件脏页的flush。address_space前台（例如找page，读page）由用户进程执行，后台操作（例如刷page，缺页中断）由kworker线程执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line"><span class="type">umode_t</span>i_mode;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>i_opflags;</span><br><span class="line"><span class="type">kuid_t</span>i_uid;</span><br><span class="line"><span class="type">kgid_t</span>i_gid;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>i_flags;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>*<span class="title">i_op</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>*<span class="title">i_sb</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>*<span class="title">i_mapping</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Stat data, not accessed from path walking */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>i_ino;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Filesystems may only read i_nlink directly.  They shall use the</span></span><br><span class="line"><span class="comment"> * following functions for modification:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    (set|clear|inc|drop)_nlink</span></span><br><span class="line"><span class="comment"> *    inode_(inc|dec)_link_count</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> i_nlink;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __i_nlink;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">dev_t</span>i_rdev;</span><br><span class="line"><span class="type">loff_t</span>i_size;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span><span class="title">i_atime</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span><span class="title">i_mtime</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span><span class="title">i_ctime</span>;</span></span><br><span class="line"><span class="type">spinlock_t</span>i_lock;<span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>          i_bytes;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>i_blkbits;</span><br><span class="line"><span class="type">blkcnt_t</span>i_blocks;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Misc */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>i_state;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span><span class="title">i_rwsem</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>dirtied_when;<span class="comment">/* jiffies of first dirtying */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>dirtied_time_when;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span><span class="title">i_hash</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">i_io_list</span>;</span><span class="comment">/* backing dev IO list */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">i_lru</span>;</span><span class="comment">/* inode LRU list */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">i_sb_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">i_wb_list</span>;</span><span class="comment">/* backing dev writeback list */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span><span class="title">i_dentry</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">i_rcu</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">u64i_version;</span><br><span class="line"><span class="type">atomic_t</span>i_count;</span><br><span class="line"><span class="type">atomic_t</span>i_dio_count;</span><br><span class="line"><span class="type">atomic_t</span>i_writecount;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>*<span class="title">i_fop</span>;</span><span class="comment">/* former -&gt;i_op-&gt;default_file_ops */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_lock_context</span>*<span class="title">i_flctx</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span><span class="title">i_data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">i_devices</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>*<span class="title">i_pipe</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>*<span class="title">i_bdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>*<span class="title">i_cdev</span>;</span></span><br><span class="line"><span class="type">char</span>*i_link;</span><br><span class="line"><span class="type">unsigned</span>i_dir_seq;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__u32i_generation;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>*i_private; <span class="comment">/* fs or device private pointer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>inode_operations，这些实际是文件系统操作函数接口，也就是“虚拟文件系统”。实现了这些函数的，是真实文件系统。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">inode_operations</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dentry</span> * (*lookup) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * (*get_link) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> inode *, <span class="keyword">struct</span> delayed_call *);</span><br><span class="line"><span class="built_in">int</span> (*permission) (<span class="keyword">struct</span> inode *, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">posix_acl</span> * (*get_acl)(<span class="keyword">struct</span> inode *, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*readlink) (<span class="keyword">struct</span> dentry *, <span class="type">char</span> __user *,<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*create) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *, <span class="type">umode_t</span>, <span class="type">bool</span>);</span><br><span class="line"><span class="built_in">int</span> (*link) (<span class="keyword">struct</span> dentry *,<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *);</span><br><span class="line"><span class="built_in">int</span> (*unlink) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *);</span><br><span class="line"><span class="built_in">int</span> (*symlink) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,<span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line"><span class="built_in">int</span> (*mkdir) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,<span class="type">umode_t</span>);</span><br><span class="line"><span class="built_in">int</span> (*rmdir) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *);</span><br><span class="line"><span class="built_in">int</span> (*mknod) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,<span class="type">umode_t</span>,<span class="type">dev_t</span>);</span><br><span class="line"><span class="built_in">int</span> (*rename) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *,</span><br><span class="line"><span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="built_in">int</span> (*setattr) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> iattr *);</span><br><span class="line"><span class="built_in">int</span> (*getattr) (<span class="keyword">struct</span> vfsmount *mnt, <span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> kstat *);</span><br><span class="line"><span class="built_in">ssize_t</span> (*listxattr) (<span class="keyword">struct</span> dentry *, <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line"><span class="built_in">int</span> (*fiemap)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> fiemap_extent_info *, u64 start,</span><br><span class="line">      u64 len);</span><br><span class="line"><span class="built_in">int</span> (*update_time)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> timespec *, <span class="type">int</span>);</span><br><span class="line"><span class="built_in">int</span> (*atomic_open)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *,</span><br><span class="line">   <span class="keyword">struct</span> file *, <span class="type">unsigned</span> open_flag,</span><br><span class="line">   <span class="type">umode_t</span> create_mode, <span class="type">int</span> *opened);</span><br><span class="line"><span class="built_in">int</span> (*tmpfile) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *, <span class="type">umode_t</span>);</span><br><span class="line"><span class="built_in">int</span> (*set_acl)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> posix_acl *, <span class="type">int</span>);</span><br><span class="line">&#125; ____cacheline_aligned;</span><br></pre></td></tr></table></figure><h4 id="文件write接口"><a href="#文件write接口" class="headerlink" title="文件write接口"></a>文件write接口</h4><p>多进程读文件不用考虑竞争，因为没有修改文件。但写文件需要考虑多线程&#x2F;并发的竞争问题。</p><p>进程会记录操作文件的pos，读写文件从pos位置开始读写指定字节。pos 使用lseek系统调用设置。如果在指定位置写数据，需要先lseek到位置，再调用write调用写数据。write调用执行完pos位置会自动修改为旧pos+length。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">off_t</span> <span class="title">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span></span>;  <span class="comment">// whence可以选择SEEK_SET，SEEK_CUR，SEEK_END。offset是相对whence的位置</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> buf[.count], <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>lseek+write调用不是原子的，多进程&#x2F;线程写相同文件情况下，会导致数据错乱。linux提供pread&#x2F;pwrite调用支持传入offset 来随机读写文件，其内部是lseek+read&#x2F;write，但保证原子性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">pread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> buf[.count], <span class="type">size_t</span> count, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">pwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> buf[.count], <span class="type">size_t</span> count, <span class="type">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><p>多线程读写文件的原子性很重要，原子性有两层意思————不能数据错乱、也不能数据丢失。例如，多进程&#x2F;线程各自打开文件，向fd各自发出写请求A和B。原子性要求1. 不要求写入顺序，但要么A写完再写B、要么B写完再写A，不能存在A写了一半、然后B写、最后A写另一半这种场景，也就是说，不能数据错乱；2. 不能数据丢失，也就是说要么AB、要么BA，不能写完只有A或只有B。</p><p>除了pwrite, linux的append写也保证写入的原子性。append 标识在open时设置。因此，append写除了能利用磁盘顺序写提高性能，也容易实现并发原子性，相比随机写，是理想的底层存储写入策略。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags,  <span class="type">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>flag可以选择</p><ol><li>O_APPEND，The modification of the file offset and the write operation are performed as a single atomic step. </li><li>O_ASYNC，Enable signal-driven I&#x2F;O: generate a signal SIGIO bydefault</li><li>O_CLOEXEC，Enable the close-on-exec flag for the new file descriptor. 利用execve()执行子进程函数时，父进程的fd会关闭，防止传给新函数，避免资源逃逸导致泄露</li><li>O_CREAT，If pathname does not exist, create it as a regular file.</li><li>O_DIRECTORY，If pathname is not a directory, cause the open to fail.</li><li>O_NOFOLLOW，If the trailing component (i.e., basename) of pathname is a symbolic link, then the open fails, with the error ELOOP.</li><li>O_NONBLOCK，When possible, the file is opened in nonblocking mode.</li><li>O_PATH，Obtain a file descriptor that can be used for two purposes: to <strong>indicate a location in the filesystem tree</strong> and to perform operations that act purely at the file descriptor level</li><li>O_TRUNC，If the file already exists and is a regular file and the access mode allows writing (i.e., is O_RDWR or O_WRONLY) it will be truncated to length 0.</li><li>O_SYNC，O_DSYNC。Write operations on the file will complete according to the requirements of synchronized I&#x2F;O file integrity completion. 即分别保证元数据+数据、数据的完整性（落盘）</li><li>O_DIRECT，Try to minimize cache effects of the I&#x2F;O to and from this file. 即相较于O_SYNC, O_DIRECT是try best，不保证一定落盘（try best是兼顾性能和一致性的手段）</li><li>O_RDONLY，O_WRONLY，O_RDWR 打开方式</li><li></li></ol><p>mode_t 对新建文件有效，表示文件权限。</p><h4 id="文件page的管理"><a href="#文件page的管理" class="headerlink" title="文件page的管理"></a>文件page的管理</h4><p>文件inode 通过address_space结构管理当前文件的page。页缓存基数树（page_tree）可以通过当前文件的offset来快速查找对应的页。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">address_space</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">inode</span>            *host;          <span class="comment">// 关联的inode</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">radix_tree_root</span>  page_tree;      <span class="comment">// 页缓存基数树（或XArray）</span></span><br><span class="line">    <span class="type">spinlock_t</span>              tree_lock;      <span class="comment">// 保护基数树的锁</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>           nrpages;        <span class="comment">// 缓存的页总数</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">address_space_operations</span> *a_ops; <span class="comment">// 操作函数表</span></span><br><span class="line">    <span class="comment">// ...其他成员（如脏页链表、回写控制等）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">address_space_operations</span> &#123;</span><br><span class="line">    <span class="comment">// 从磁盘读取一页到内存</span></span><br><span class="line">    <span class="built_in">int</span> (*readpage)(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *);</span><br><span class="line">    <span class="comment">// 将内存中的脏页写回磁盘</span></span><br><span class="line">    <span class="built_in">int</span> (*writepage)(<span class="keyword">struct</span> page *, <span class="keyword">struct</span> writeback_control *);</span><br><span class="line">    <span class="comment">// 同步文件的脏页（如调用fsync）</span></span><br><span class="line">    <span class="built_in">int</span> (*sync_page)(<span class="keyword">struct</span> address_space *, <span class="keyword">struct</span> writeback_control *);</span><br><span class="line">    <span class="comment">// 直接I/O操作（绕过页缓存）</span></span><br><span class="line">    <span class="built_in">ssize_t</span> (*direct_IO)(<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *iter);</span><br><span class="line">    <span class="comment">// 处理内存映射的页错误（mmap缺页中断）</span></span><br><span class="line">    <span class="built_in">vm_fault_t</span> (*fault)(<span class="keyword">struct</span> vm_fault *);</span><br><span class="line">    <span class="comment">// ...其他函数（如设置/释放页、预读等）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>address_space只是用来定位页，文件系统的页由page cache管理。</p><h4 id="page-cache"><a href="#page-cache" class="headerlink" title="page_cache"></a>page_cache</h4><p>page_cache使用若干队列来管理页，活跃队列（Active List）、不活跃队列（Inactive List）、脏页队列（Dirty Pages）、Clean Pages、写回队列（Writeback Pages）。如果需要申请一个页来写数据，会尝试从Clean page中获取。</p><p>page_cache对page设置活跃页（Active Pages）、不活跃页（Inactive Pages）、脏页（Dirty Pages）、干净页（Clean Pages）四种状态。四种状态可以相互转换。内存地址可以通过MMU地址转换得到（页号，偏移量）地址，page cache会维护一个mapping表用来通过页号快速查找页。因此page cache也可以抽象成一个LRU cache。</p><p>page_cache采用write_back策略，原因是单机缓存，不用考虑多客户端访问的客户端缓存不一致问题。</p><ol><li>page_cache处理和address_space的联系，如利用buddy算法申请一个空闲的内存页作为新的页缓存，page添加到 address_space 结构的 page_tree 中。</li><li>page_cache作为lru，实现缓存淘汰。lru_cache_add 函数把页缓存添加到 LRU 队列中。LRU 队列用于当系统内存不足时，对页缓存进行清理时使用。</li></ol><p><strong>缺页中断由CPU触发，是一种硬中断。</strong></p><ol><li>当 CPU 尝试访问某个虚拟地址时，检测到虚拟地址无效，无法通过页表找到对应的物理页面。触发缺页中断。当前进程进入等待队列阻塞</li><li>缺页中断处理函数尝试定位页来源，尝试从硬盘swap空间读page</li><li>当address_space发现要读的文件offset, length不在page cache中，不需要触发中断，直接调用处理函数从swap空间读page</li><li>page 读完后，唤醒阻塞的进程继续执行。</li></ol><p>操作系统的中断由硬中断和软中断组成，硬中断负责立即响应的简单操作，例如缺页中断触发进程等待，内核线程执行缺页中断程序。而从磁盘读取数据操作则由后续的软中断负责，因此如果CPU处理数据读取慢，top会显示CPU软中断占用高。</p><h3 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h3><h4 id="内核网络协议栈"><a href="#内核网络协议栈" class="headerlink" title="内核网络协议栈"></a>内核网络协议栈</h4><p>传输层，确保数据可靠传输（TCP）或快速传输（UDP）。</p><ol><li>TCP Transmission Control Protocol面向连接、可靠传输，提供流量控制、拥塞控制、重传机制。</li><li>UDP User Datagram Protocol面向无连接、低延迟。</li></ol><p>网络层，负责数据包的寻址和路由，从源主机传输到目标主机。网络层数据包是网络间数据传输的基本单位。</p><ol><li>IP协议Internet Protocol，IPv4：经典的网络协议，基于 32 位地址。IPv6：下一代协议，基于 128 位地址，支持更大的地址空间。</li><li>TCMP协议Internet Control Message Protocol，用于网络诊断（如 ping）</li></ol><p>链路层，负责数据帧的封装与传输，连接网络接口（网卡），网卡使用MAC地址</p><ol><li>Ethernet：以太网协议。</li><li>PPP（Point-to-Point Protocol）：点对点协议。</li><li>802.11：无线局域网协议（Wi-Fi）</li></ol><h4 id="网络包"><a href="#网络包" class="headerlink" title="网络包"></a>网络包</h4><p>TCP网络包需要考虑飞着的请求，例如连接关闭时数据包可能还在网络中没有收到，所以连接主动关闭方需要TimeWait等待2MSL（Maximum Segment Lifetime，最大报文生存时间），等待对方数据包接收完毕，防止当前链接中飞着的数据包干扰下次链接。MSL 通常为30秒，因此TIME_WAIT状态持续2 × MSL，即60秒。</p><p>IP协议头中有一个TTL字段（time to live），TTL由源主机设置初始值，表示ip数据包可以经过的最大路由数，每经过一个路由器此值就减1，值为0则数据包将被丢弃</p><p>IPv4 包的最大总大小为 65,535 字节（由 16 位总长度字段决定）。</p><ul><li>最小大小：20 字节（没有数据）</li><li>最大大小：65,535 字节（包括头部和数据）</li></ul><h3 id="内存文件系统"><a href="#内存文件系统" class="headerlink" title="内存文件系统"></a>内存文件系统</h3><p>linux的文件系统抽象，已经是一种标准接口。核心的操作是4个，create, remove, read, write</p><ol><li>linux的块设备和流设备 通过实现read, write接口，让用户程序读写设备的数据</li><li>linux的运行态监控数据，如进程、内存等统计数据，以树组织结构，提供read, write接口访问运行数据、和接受数据更新</li><li>分布式锁也以文件树的形式组织，提供create, remove接口申请和释放分布式锁</li></ol><p>内存文件系统</p><ol><li>tmpfs</li></ol><p>tmpfs（temporary filesystem）是Linux特有的文件系统，标准挂载点是&#x2F;dev&#x2F;shm，默认大小是实际内存的一半<br><img src="/../images/shm.png" alt="shm" title="shm"></p><p>tmpfs对于文件缓存和临时数据来说，是一种较理想的做法。</p><h4 id="proc文件系统"><a href="#proc文件系统" class="headerlink" title="&#x2F;proc文件系统"></a>&#x2F;proc文件系统</h4><p>以文件系统的形式组织和显示内核和进程的状态</p><p>&#x2F;proc 是linux内核的信息中心，其他监控工具，如top, iostat, sar 的信息基本来自&#x2F;proc</p><p>显示cpu和mem信息<br>&#x2F;proc&#x2F;cpuinfo<br>&#x2F;proc&#x2F;meminfo<br><img src="/../images/cpuinfo.png" alt="cpuinfo" title="cpuinfo"></p><p><code>/proc/[PID]/</code>进程详细信息（如 status、cmdline、fd）</p><p>内核版本和编译信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2204:~# cat /proc/version</span><br><span class="line">Linux version 5.15.0-136-generic (buildd@lcy02-amd64-034) (gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, GNU ld (GNU Binutils for Ubuntu) 2.38) #147-Ubuntu SMP Sat Mar 15 15:53:30 UTC 2025</span><br></pre></td></tr></table></figure><p>网络流量信息<br>&#x2F;proc&#x2F;net&#x2F;dev</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2204:~# cat /proc/net/dev</span><br><span class="line">Inter-|   Receive                                                |  Transmit</span><br><span class="line"> face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed</span><br><span class="line">    lo: 7759911598 1360449    0    0    0     0          0         0 7759911598 1360449    0    0    0     0       0          0</span><br><span class="line"> ens33: 417062256 3321954    0    0    0     0          0         0 7652714047 5639881    0    0    0     0       0          0</span><br></pre></td></tr></table></figure><p>&#x2F;proc&#x2F;sys&#x2F; 目录，记录和修改内核参数配置，重要</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2204:~# ls /proc/sys</span><br><span class="line">abi  debug  dev  fs  kernel  net  user  vm</span><br></pre></td></tr></table></figure><p>&#x2F;proc&#x2F;loadavg<br>系统负载（1&#x2F;5&#x2F;15分钟平均负载，运行队列进程数）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2204:~# cat /proc/loadavg</span><br><span class="line">1.57 1.76 0.99 1/838 26242</span><br></pre></td></tr></table></figure><p>&#x2F;proc&#x2F;stat cpu相关全局统计信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2204:~# cat /proc/stat</span><br><span class="line">cpu  399417 4928 339405 84450316 7139 0 30675 0 0 0</span><br><span class="line">cpu0 21195 2 26481 5268694 336 0 2800 0 0 0</span><br><span class="line">cpu1 42402 74 31192 5240571 427 0 2972 0 0 0</span><br><span class="line">cpu2 33478 15 27717 5257818 604 0 2324 0 0 0</span><br><span class="line">cpu3 30995 406 23975 5226927 613 0 2168 0 0 0</span><br><span class="line">cpu4 27296 404 20764 5284437 383 0 1675 0 0 0</span><br><span class="line">cpu5 26414 890 21324 5267819 645 0 2164 0 0 0</span><br><span class="line">cpu6 19211 24 31810 5251556 437 0 1526 0 0 0</span><br><span class="line">cpu7 25022 1109 19356 5287793 316 0 1593 0 0 0</span><br><span class="line">cpu8 23924 219 18628 5293679 500 0 1420 0 0 0</span><br><span class="line">cpu9 21991 214 17550 5291998 484 0 1370 0 0 0</span><br><span class="line">cpu10 22884 99 15854 5300435 359 0 1347 0 0 0</span><br><span class="line">cpu11 18719 382 18216 5276030 425 0 4018 0 0 0</span><br><span class="line">cpu12 20634 200 16434 5303424 502 0 1283 0 0 0</span><br><span class="line">cpu13 22901 125 16799 5297069 354 0 1407 0 0 0</span><br><span class="line">cpu14 20533 50 16129 5303203 375 0 1300 0 0 0</span><br><span class="line">cpu15 21812 708 17170 5298855 370 0 1302 0 0 0</span><br><span class="line">intr 42988264 23 45 0 0 0 0 0 0 0 0 0 0 216 0 0 0 256678 109314 1337306 1358118 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 26747 7701 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </span><br></pre></td></tr></table></figure><h4 id="proc-sys-net-参数配置"><a href="#proc-sys-net-参数配置" class="headerlink" title="&#x2F;proc&#x2F;sys&#x2F;net 参数配置"></a>&#x2F;proc&#x2F;sys&#x2F;net 参数配置</h4><p>网络参数<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward  启用 IP 数据包转发（用于路由器或 VPN 服务器） 1启用</p><p>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn TCP 连接队列的最大长度 默认4096</p><p>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog SYN 队列长度（防御 SYN Flood 攻击） 默认512</p><p>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_tw_reuse 允许复用 TIME-WAIT 状态的端口（降低端口耗尽风险）建议开启（配置1</p><p>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_fin_timeout TIME-WAIT 状态超时时间（秒） 默认60</p><p>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;rmem_max &#x2F; wmem_max 接收&#x2F;发送缓冲区最大大小（字节） 默认16M</p><h4 id="proc-sys-vm"><a href="#proc-sys-vm" class="headerlink" title="&#x2F;proc&#x2F;sys&#x2F;vm"></a>&#x2F;proc&#x2F;sys&#x2F;vm</h4><p>&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;swappiness 控制内核使用交换分区（Swap）的倾向（0&#x3D;禁用，100&#x3D;积极使用） 默认60</p><p>&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;overcommit_memory 内存分配策略（0&#x3D;启发式，1&#x3D;总是允许，2&#x3D;禁止超限） 默认0</p><p>&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;dirty_ratio 内存中脏页占比阈值（触发同步写入磁盘） 默认20</p><p>&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;dirty_background_ratio 后台刷脏页的阈值（异步写入） 默认10</p><h4 id="proc-sys-fs"><a href="#proc-sys-fs" class="headerlink" title="&#x2F;proc&#x2F;sys&#x2F;fs"></a>&#x2F;proc&#x2F;sys&#x2F;fs</h4><p>&#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max 系统最大可用fd数量 默认655360（高并发场景），linux 5.15 是9223372036854775807</p><h4 id="proc-id"><a href="#proc-id" class="headerlink" title="&#x2F;proc&#x2F;:id&#x2F;"></a>&#x2F;proc&#x2F;:id&#x2F;</h4><p>&#x2F;proc&#x2F;:id&#x2F;status 进程状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2204:~# cat /proc/1/status</span><br><span class="line">Name:   systemd</span><br><span class="line">Umask:  0000</span><br><span class="line">State:  S (sleeping)</span><br><span class="line">Tgid:   1</span><br><span class="line">Ngid:   0</span><br><span class="line">Pid:    1</span><br><span class="line">PPid:   0</span><br><span class="line">TracerPid:      0</span><br><span class="line">Uid:    0       0       0       0</span><br><span class="line">Gid:    0       0       0       0</span><br><span class="line">FDSize: 128</span><br><span class="line">Groups:  </span><br><span class="line">NStgid: 1</span><br><span class="line">NSpid:  1</span><br><span class="line">NSpgid: 1</span><br><span class="line">NSsid:  1</span><br><span class="line">VmPeak:   231576 kB</span><br><span class="line">VmSize:   166608 kB</span><br><span class="line">VmLck:         0 kB</span><br><span class="line">VmPin:         0 kB</span><br><span class="line">VmHWM:     12008 kB</span><br><span class="line">VmRSS:     12008 kB</span><br><span class="line">RssAnon:            3596 kB</span><br><span class="line">RssFile:            8412 kB</span><br><span class="line">RssShmem:              0 kB</span><br><span class="line">VmData:    19728 kB</span><br><span class="line">VmStk:       132 kB</span><br><span class="line">VmExe:       896 kB</span><br><span class="line">VmLib:      9056 kB</span><br><span class="line">VmPTE:        92 kB</span><br><span class="line">VmSwap:        0 kB</span><br><span class="line">HugetlbPages:          0 kB</span><br><span class="line">CoreDumping:    0</span><br><span class="line">THP_enabled:    1</span><br><span class="line">Threads:        1</span><br><span class="line">SigQ:   0/31167</span><br><span class="line">SigPnd: 0000000000000000</span><br><span class="line">ShdPnd: 0000000000000000</span><br><span class="line">SigBlk: 7be3c0fe28014a03</span><br><span class="line">SigIgn: 0000000000001000</span><br><span class="line">SigCgt: 00000001000004ec</span><br><span class="line">CapInh: 0000000000000000</span><br><span class="line">CapPrm: 000001ffffffffff</span><br><span class="line">CapEff: 000001ffffffffff</span><br><span class="line">CapBnd: 000001ffffffffff</span><br><span class="line">CapAmb: 0000000000000000</span><br></pre></td></tr></table></figure><p>&#x2F;proc&#x2F;:id&#x2F;stat 进程资源统计</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2204:~# cat /proc/1/stat</span><br><span class="line">1 (systemd) S 0 1 1 0 -1 4194560 21072 10673320 170 5762 93 710 123609 96361 20 0 1 0 139 170606592 3002 18446744073709551615 94801583210496 94801584125325 140737195847840 0 0 0 671173123 4096 1260 1 0 0 17 6 0 0 0 0 0 94801584520848 94801584840988 94802160250880 140737195851553 140737195851564 140737195851564 140737195851757 0</span><br></pre></td></tr></table></figure><p>&#x2F;proc&#x2F;:id&#x2F;exe 链接到进程的可执行文件地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2204:~# ll /proc/1/exe</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr 18 15:40 /proc/1/exe -&gt; /usr/lib/systemd/systemd*</span><br></pre></td></tr></table></figure><p>&#x2F;proc&#x2F;:id&#x2F;limit 进程资源限制</p><p>&#x2F;proc&#x2F;:id&#x2F;environ 进程使用的环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2204:~# cat /proc/1/environ</span><br><span class="line">HOME=/init=/sbin/initNETWORK_SKIP_ENSLAVED=TERM=linuxBOOT_IMAGE=/vmlinuz-5.15.0-136-genericdrop_caps=PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binPWD=/roo</span><br></pre></td></tr></table></figure><p>&#x2F;proc&#x2F;:id&#x2F;cwd 链接到进程的工作目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2204:~# ll /proc/1/cwd</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr 18 15:41 /proc/1/cwd -&gt; //</span><br></pre></td></tr></table></figure><p>&#x2F;proc&#x2F;:id&#x2F;cgroup 进程的cgroup配置</p><h4 id="proc-id-fd"><a href="#proc-id-fd" class="headerlink" title="&#x2F;proc&#x2F;:id&#x2F;fd"></a>&#x2F;proc&#x2F;:id&#x2F;fd</h4><p>进程打开的fd<br>可以用来衡量进程处理的网络链接（在read&#x2F;write中，网络链接抽象成一个fd）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2204:~# ll /proc/1/fd</span><br><span class="line">total 0</span><br><span class="line">dr-x------ 2 root root  0 Apr 18 15:40 ./</span><br><span class="line">dr-xr-xr-x 9 root root  0 Apr 18 15:40 ../</span><br><span class="line">lrwx------ 1 root root 64 Apr 18 15:40 0 -&gt; /dev/null</span><br><span class="line">lrwx------ 1 root root 64 Apr 18 15:40 1 -&gt; /dev/null</span><br><span class="line">lr-x------ 1 root root 64 Apr 20 03:17 10 -&gt; /proc/1/mountinfo</span><br><span class="line">lrwx------ 1 root root 64 Apr 19 00:55 100 -&gt; &#x27;socket:[68961]&#x27;</span><br><span class="line">lrwx------ 1 root root 64 Apr 20 01:46 102 -&gt; &#x27;socket:[164205]&#x27;</span><br><span class="line">lr-x------ 1 root root 64 Apr 20 03:17 11 -&gt; anon_inode:inotify</span><br><span class="line">lrwx------ 1 root root 64 Apr 18 15:40 12 -&gt; &#x27;socket:[59674]&#x27;</span><br><span class="line">lr-x------ 1 root root 64 Apr 20 03:17 13 -&gt; anon_inode:inotify</span><br><span class="line">lr-x------ 1 root root 64 Apr 20 03:17 14 -&gt; /proc/swaps</span><br><span class="line">lrwx------ 1 root root 64 Apr 20 03:17 15 -&gt; &#x27;socket:[30476]&#x27;</span><br><span class="line">lrwx------ 1 root root 64 Apr 20 03:17 16 -&gt; &#x27;socket:[30477]&#x27;</span><br><span class="line">lrwx------ 1 root root 64 Apr 20 03:17 17 -&gt; &#x27;socket:[30478]&#x27;</span><br><span class="line">lrwx------ 1 root root 64 Apr 20 03:17 18 -&gt; &#x27;socket:[30479]&#x27;</span><br><span class="line">lrwx------ 1 root root 64 Apr 20 03:17 19 -&gt; &#x27;socket:[30480]&#x27;</span><br><span class="line">lrwx------ 1 root root 64 Apr 18 15:40 2 -&gt; /dev/null</span><br><span class="line">lrwx------ 1 root root 64 Apr 18 15:40 20 -&gt; &#x27;socket:[30482]&#x27;</span><br><span class="line">lrwx------ 1 root root 64 Apr 20 03:17 21 -&gt; &#x27;socket:[30483]&#x27;</span><br><span class="line">lrwx------ 1 root root 64 Apr 20 03:17 25 -&gt; &#x27;socket:[28946]&#x27;</span><br><span class="line">lr-x------ 1 root root 64 Apr 20 03:17 26 -&gt; anon_inode:inotify</span><br><span class="line">lr-x------ 1 root root 64 Apr 20 03:17 27 -&gt; /dev/autofs</span><br><span class="line">lr-x------ 1 root root 64 Apr 20 03:17 28 -&gt; &#x27;pipe:[30488]&#x27;</span><br><span class="line">lrwx------ 1 root root 64 Apr 20 03:17 29 -&gt; &#x27;anon_inode:[timerfd]&#x27;</span><br><span class="line">l-wx------ 1 root root 64 Apr 18 15:40 3 -&gt; /dev/kmsg</span><br><span class="line">lrwx------ 1 root root 64 Apr 18 15:40 30 -&gt; /run/dmeventd-server|</span><br><span class="line">lrwx------ 1 root root 64 Apr 20 03:17 31 -&gt; /run/dmeventd-client|</span><br><span class="line">lrwx------ 1 root root 64 Apr 20 03:17 32 -&gt; &#x27;socket:[30491]&#x27;</span><br><span class="line">lrwx------ 1 root root 64 Apr 18 15:40 33 -&gt; &#x27;socket:[30493]&#x27;</span><br></pre></td></tr></table></figure><h4 id="sysfs-内存文件系统"><a href="#sysfs-内存文件系统" class="headerlink" title="sysfs 内存文件系统"></a>sysfs 内存文件系统</h4><p>挂载到&#x2F;sys&#x2F;fs</p><p>&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;​，管理cgroup，用于限制和监控进程的 CPU、内存、I&#x2F;O 等资源。</p><p>&#x2F;sys&#x2F;fs&#x2F;fuse&#x2F;，管理 FUSE（用户态文件系统）的连接和参数。</p><p>&#x2F;sys&#x2F;fs&#x2F;ext4&#x2F;​，管理<code>ext4</code> 文件系统的全局配置。</p><p>&#x2F;sys&#x2F;fs&#x2F;overlayfs，OverlayFS（联合文件系统）的配置</p>]]></content>
      
      
      <categories>
          
          <category> single-machine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> single-machine </tag>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux系统(1)——进程管理和调度</title>
      <link href="/2024/11/06/linux%E7%B3%BB%E7%BB%9F(1)%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%92%8C%E8%B0%83%E5%BA%A6/"/>
      <url>/2024/11/06/linux%E7%B3%BB%E7%BB%9F(1)%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%92%8C%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>linux操作系统大致可分为进程管理、进程协调、内存管理、文件系统、网络管理等五大部分。本文讲述进程管理和进程协调。</p><span id="more"></span><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>进程管理的目的是将用户和内核创建的进程&#x2F;程序调度到cpu上执行，这些进程有三种</p><ol><li>用户程序创建的一次性运行完的进程</li><li>systemd等维护了常驻后台的后台进程，例如nginx，sshd</li><li>操作系统内核进程，例如kworker处理硬中断、信号、IO操作（包括cpu时间片硬中断调度、软中断抢占），kswapd管理页缓存和内存淘汰swap空间，watchdog检查内核死锁、防止系统卡死，ksoftirqd处理软中断，kblockd处理块设备IO，系统空闲线程（idle 线程）。这些进程一般定时执行。</li></ol><p>为什么cpu要执行idle线程？因为CPU需要执行指令才能保持正常运行。CPU按照“取指令（Fetch）—解码（Decode）—执行（Execute）”的周期运行。如果没有指令可以取，或者取到的指令无法正确解码，CPU无法正常工作。程序计数器（PC）用于指示下一条需要执行的指令地址。如果没有明确的任务，PC可能指向无效地址，导致不可预测的行为。</p><h3 id="进程队列"><a href="#进程队列" class="headerlink" title="进程队列"></a>进程队列</h3><p>进程管理器需要把已经创建的进程放入队列中, 进程排队接受多核cpu的处理。</p><p>进程调度器有很多设计值得学习的，例如</p><ol><li>就绪任务采用优先级队列组织，支持任务公平调度和任务抢占</li><li>存在等待队列存放需要等待较长时间，需要唤醒的任务</li><li>停止队列支持任务暂停和断点继续执行</li><li>任务执行前创建结构，执行完销毁结构</li></ol><h4 id="就绪队列（Ready-Queue）"><a href="#就绪队列（Ready-Queue）" class="headerlink" title="就绪队列（Ready Queue）"></a>就绪队列（Ready Queue）</h4><p>就绪队列是一个<strong>优先级队列</strong>。</p><p>新创建的进程会放入就绪队列Ready Queue，等待队列是进程调度的对象，将这些进程调度给CPU执行。Linux使用 CFS调度器（完全公平调度器） 管理就绪队列。CFS调度器通过一个红黑树（rb_tree）来组织进程，就绪队列中的每个进程以其虚拟运行时间作为排序依据。</p><p>调度器从红黑树中选择虚拟运行时间最小的进程进行执行。当进程时间片用完，或被抢占，进程更新虚拟运行时间后重新插入到就绪队列</p><p>就绪队列中进程的状态是R (TASK_RUNNING)</p><h4 id="等待队列（Wait-Queue）"><a href="#等待队列（Wait-Queue）" class="headerlink" title="等待队列（Wait Queue）"></a>等待队列（Wait Queue）</h4><p>进程在等待某些事件（如IO完成、信号到达、锁释放）时进入该队列。对应进程S状态和D状态</p><p>进程S状态TASK_INTERRUPTIBLE，可中断的睡眠状态。例如等待锁，等待socket事件。该状态进程可被调度器调度。</p><p>D状态TASK_UNINTERRUPTIBLE，不可中断的睡眠状态。该状态进程无法响应信号，无法被调度，只能等待IO执行完毕（但可以响应硬中断）。例如进程等待磁盘IO期间无法中断，原因1. 进程没必要被中断，数据到不了中断也处理不了什么 2. 简化实现，防止IO读写没有进程处理导致问题 3. 避免由于磁盘等故障导致大量进程持续中断。</p><p>对于持有spinlock的进程需要屏蔽中断，但这时候的进程不是等待状态。</p><h4 id="停止队列（Stopped-Queue）"><a href="#停止队列（Stopped-Queue）" class="headerlink" title="停止队列（Stopped Queue）"></a>停止队列（Stopped Queue）</h4><p>进程被暂停（例如接收到SIGSTOP信号）后进入该队列，例如ptrace机制调试进程时会暂停某些进程，放入停止队列中。</p><p>停止队列中的进程不会被调度器调度，直到接收到恢复信号（如SIGCONT）。</p><h4 id="僵尸队列（Zombie-Queue）"><a href="#僵尸队列（Zombie-Queue）" class="headerlink" title="僵尸队列（Zombie Queue）"></a>僵尸队列（Zombie Queue）</h4><p>包含所有处于TASK_ZOMBIE状态的进程。僵尸进程是已结束执行但尚未被其父进程回收的进程。</p><p>父进程调用wait族函数等待子进程执行完并回收时，僵尸进程会被从队列中移除。</p><p>TASK_DEAD状态的进程会被系统回收所有资源，释放进程控制块（PCB）。</p><h3 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h3><p>实时进程优先级：范围从 1 到 99（高优先级）。实时进程调度时，高优先级的进程必须执行完毕或主动放弃 CPU，低优先级的进程才能运行。</p><p>普通进程优先级：范围从 100 到 139（低优先级）。默认优先级为 120。普通进程使用 完全公平调度器（CFS），CFS中，执行时间少的进程在计算时会有较高的动态优先级。</p><h4 id="普通进程优先级"><a href="#普通进程优先级" class="headerlink" title="普通进程优先级"></a>普通进程优先级</h4><p>可以通过 nice 或 renice 命令设置普通进程的静态优先级。范围：-20（最高优先级）到 19（最低优先级）。<strong>nice默认值为 0。</strong><br>nice 值越低，进程优先级越高。</p><p>内核线程是由内核创建并运行的任务，通常用于关键系统功能，优先级由内核自行分配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进程类别优先级范围优先级特点</span><br><span class="line">kswapd高内存页面交换线程，优先级较高</span><br><span class="line">kworker高内核工作队列处理线程</span><br><span class="line">khugepaged中大页面分配优化</span><br><span class="line">jbd2中日志缓冲区管理线程</span><br></pre></td></tr></table></figure><p>系统服务和守护进程通常负责后台任务，默认优先级设置中等，以确保它们不会过多占用 CPU，但仍能及时响应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">进程类别默认 Nice 值优先级特点</span><br><span class="line">init/systemd0系统初始化进程，优先级适中</span><br><span class="line">cron0定时任务调度器，重要但无需实时响应</span><br><span class="line">sshd0远程登录服务，优先级适中</span><br><span class="line">udevd0设备管理服务，实时性要求中等</span><br><span class="line">NetworkManager0网络管理，重要性较高</span><br><span class="line">rsyslogd0日志服务，优先级适中</span><br></pre></td></tr></table></figure><h3 id="完全公平调度CFS"><a href="#完全公平调度CFS" class="headerlink" title="完全公平调度CFS"></a>完全公平调度CFS</h3><ol><li>操作系统统计周期内每个进程的执行时间，这个执行时间是个虚拟执行时间vriture_runtime，计算时会考虑进程优先级，优先级高的进程统计的执行时间会偏少。</li><li>执行时间少的进程在下个周期优先执行</li></ol><p>进程切换，Linux内核使用定时器硬中断来实现时间片轮转调度。当定时器中断发生时，内核会检查当前运行的进程是否超过其时间片。是则进行进程切换。定时器中断的频率通常为100Hz或1000Hz，表示每隔10ms或1ms中断一次。</p><h2 id="进程协调"><a href="#进程协调" class="headerlink" title="进程协调"></a>进程协调</h2><p>进程协调的手段包括两个部分</p><ol><li>协调进程切换，包括信号、硬&#x2F;软中断、系统调用</li><li>协调进程&#x2F;线程同步，包括锁、条件变量、信号量等</li></ol><h3 id="协调进程切换"><a href="#协调进程切换" class="headerlink" title="协调进程切换"></a>协调进程切换</h3><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>当进程从执行用户代码转向执行内核代码时，就发生系统调用。需要注意该过程不发生进程切换。</p><ol><li>进入内核代码前，进程首先调用<code>int $0x80</code>或<code>syscall指令</code>，该指令会让CPU转向执行（entry_INT80_32或entry_SYSCALL_64）汇编代码，即根据系统调⽤号调⽤对应的内核处理函数。</li><li>执行内核处理函数前，cpu 将当前寄存器内容保存到用户栈，使用内核栈执行内核处理函数</li><li>内核处理函数执行完后，调用sysret 指令从用户栈恢复寄存器内容，使用用户栈继续执行用户程序</li></ol><p>为什么执行内核代码需要调用<code>int $0x80</code>或syscall指令，而不是直接函数调用的形式执行？<br>因为系统调用状态的保存是CPU硬件实现的，CPU的两个寄存器</p><p>MSR_LSTAR：保存内核系统调用入口的地址。<br>MSR_STAR：保存用户态和内核态的代码段选择器。</p><p>在syscall指令中，寄存器保存用户栈，执行内核函数，恢复用户栈都是硬件实现的。只需要调用CPU指令。操作系统只需要配置相关寄存器然后调用指令即可。</p><p>在<code>int $0x80</code>中，寄存器保存用户栈，执行内核函数，恢复用户栈是操作系统软件实现的（性能差于syscall，现代CPU基本使用后者），操作系统把处理函数注册到中断向量表IDT的0x80位置。当进程执行int $0x80指令，CPU会自动从寄存器找到IDT地址，转向执行处理函数（IDT的地址存放在寄存器IDT 寄存器（IDTR））。“CPU从寄存器找到IDT，转向执行处理函数”这是硬件实现的。</p><h4 id="硬中断和中断向量表"><a href="#硬中断和中断向量表" class="headerlink" title="硬中断和中断向量表"></a>硬中断和中断向量表</h4><p>上面说到，系统调用可以通过发起<code>int $0x80</code>指令，CPU自动从中断向量表找到处理函数。中断向量表IDT是中断执行的核心，中断函数由操作系统注册，但无法直接执行，只能借助cpu中断表执行。中断优先级与向量号直接相关，向量号越低优先级越高。</p><p>硬中断和中断向量表，中断的对象是CPU。通过CPU引脚信号&#x2F;CPU指令来触发中断。硬中断可以抢占CPU，一般来说，如果用户态进程发生了硬中断&#x2F;异常，执行硬中断处理函数的进程和用户态进程是一个。如果硬中断不是由用户态进程产生，例如时间片用尽、磁盘网络IO中断，中断处理函数由kworker 执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  Vectors   0 ...  31 : system traps and exceptions - hardcoded events</span></span><br><span class="line"><span class="comment">*  Vectors  32 ... 127 : device interrupts</span></span><br><span class="line"><span class="comment">*  Vector  128         : legacy int80 syscall interface</span></span><br><span class="line"><span class="comment">*  Vectors 129 ... INVALIDATE_TLB_VECTOR_START-1 except 204 : device interrupts</span></span><br><span class="line"><span class="comment">*  Vectors INVALIDATE_TLB_VECTOR_START ... 255 : special interrupts</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>0-31中保存的是异常的中断向量，这些异常包括除0、断点调试、边界溢出、段错误、浮点数异常等，中断处理会转向执行查找进程对应的异常处理函数，默认是异常退出进程（向进程发SIGINT信号,程序异常退出）</p><p>为什么使用中断处理异常？因为异常是运行态的，程序编译后并不知道异常会不会执行。<strong>当CPU执行遇到异常后，不能继续执行原程序的指令。</strong> 只能去IDT执行异常函数的处理指令。</p><p>CPU转向执行异常，需要1. 停止当前指令执行; 2. 保存 CPU 状态; 3. 跳转到指定的处理程序处理。</p><p>CPU&#x2F;进程上下文切换也是通过硬中断实现，同样需要1. 停止当前进程指令执行; 2. 保存 CPU 状态; 3. 跳转转型下一个进程的指令。CPU&#x2F;进程上下文是否切换 等价于 是否出现硬中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Interrupts/Exceptions */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">X86_TRAP_DE = <span class="number">0</span>,<span class="comment">/*  0, Divide-by-zero */</span></span><br><span class="line">X86_TRAP_DB,<span class="comment">/*  1, Debug */</span></span><br><span class="line">X86_TRAP_NMI,<span class="comment">/*  2, Non-maskable Interrupt */</span></span><br><span class="line">X86_TRAP_BP,<span class="comment">/*  3, Breakpoint */</span></span><br><span class="line">X86_TRAP_OF,<span class="comment">/*  4, Overflow */</span></span><br><span class="line">X86_TRAP_BR,<span class="comment">/*  5, Bound Range Exceeded */</span></span><br><span class="line">X86_TRAP_UD,<span class="comment">/*  6, Invalid Opcode */</span></span><br><span class="line">X86_TRAP_NM,<span class="comment">/*  7, Device Not Available */</span></span><br><span class="line">X86_TRAP_DF,<span class="comment">/*  8, Double Fault */</span></span><br><span class="line">X86_TRAP_OLD_MF,<span class="comment">/*  9, Coprocessor Segment Overrun */</span></span><br><span class="line">X86_TRAP_TS,<span class="comment">/* 10, Invalid TSS */</span></span><br><span class="line">X86_TRAP_NP,<span class="comment">/* 11, Segment Not Present */</span></span><br><span class="line">X86_TRAP_SS,<span class="comment">/* 12, Stack Segment Fault */</span></span><br><span class="line">X86_TRAP_GP,<span class="comment">/* 13, General Protection Fault */</span></span><br><span class="line">X86_TRAP_PF,<span class="comment">/* 14, Page Fault */</span></span><br><span class="line">X86_TRAP_SPURIOUS,<span class="comment">/* 15, Spurious Interrupt */</span></span><br><span class="line">X86_TRAP_MF,<span class="comment">/* 16, x87 Floating-Point Exception */</span></span><br><span class="line">X86_TRAP_AC,<span class="comment">/* 17, Alignment Check */</span></span><br><span class="line">X86_TRAP_MC,<span class="comment">/* 18, Machine Check */</span></span><br><span class="line">X86_TRAP_XF,<span class="comment">/* 19, SIMD Floating-Point Exception */</span></span><br><span class="line">X86_TRAP_IRET = <span class="number">32</span>,<span class="comment">/* 32, IRET Exception */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>向量 32 到 127，分配给硬件中断和其他系统用途。硬件中断的触发，连接cpu引脚的硬件会向引脚发送信号，cpu收到信号会立即暂停当前程序处理（屏蔽中断的除外），从idt中找到硬件中断处理函数执行。</p><p>对需要较长时间处理的中断，例如网卡磁盘收发数据。为了时效性，硬件中断处理函数只是创建一个异步任务到队列就返回，任务具体的处理由后续软中断负责。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">IRQ    中断号用途</span><br><span class="line">IRQ 032系统定时器（时钟中断）</span><br><span class="line">IRQ 133键盘</span><br><span class="line">IRQ 234可编程中断控制器级联</span><br><span class="line">IRQ 335串口 2</span><br><span class="line">IRQ 436串口 1</span><br><span class="line">IRQ 537并口 2 / 声卡</span><br><span class="line">IRQ 638软盘控制器</span><br><span class="line">IRQ 739并口 1</span><br><span class="line">IRQ 840CMOS 实时时钟</span><br><span class="line">IRQ 941可用（通常用于 ACPI）</span><br><span class="line">IRQ 1042可用</span><br><span class="line">IRQ 1143可用</span><br><span class="line">IRQ 1244PS/2 鼠标</span><br><span class="line">IRQ 1345协处理器 / FPU</span><br><span class="line">IRQ 1446主 IDE 控制器</span><br><span class="line">IRQ 1547从 IDE 控制器</span><br></pre></td></tr></table></figure><p>向量 128（0x80），用于系统调用（如 int $0x80）。</p><p>向量 129 到 255，用户自定义的硬中断。例如，int 0x81：某些调试工具可能使用该中断来与内核交互；int 0xFF：某些实时系统可能定义为特殊的系统功能调用；APIC 定时器通常分配到高向量。</p><h4 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h4><p>软中断和软中断向量表，是内核软件层实现的（软中断号，处理函数）的映射，目的是异步任务延迟调度，没有直接影响到CPU，不抢占CPU。软中断和是否出现CPU&#x2F;进程上下文切换没有联系。</p><p>软中断通过内核代码调用 raise_softirq() 触发。主要可以分为1. 定时器（很重要，比如处理超时锁等待，sleep超时） 2. 网络发送接收 3. 块设备IO 4. Tasklet 等类型。Tasklet是用户注册的一种函数，该函数和软中断一起被执行。</p><p>每个cpu维护一个软中断队列，软中断的执行不会切换CPU。如果CPU软中断占用时间长，可能是网络包是大量的小包，也可能是磁盘&#x2F;网络处理慢。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">软中断号名称用途</span><br><span class="line">0HI_SOFTIRQ高优先级任务，通常用于调度紧急操作。</span><br><span class="line">1TIMER_SOFTIRQ定时器中断，用于触发周期性任务，如更新系统时间，超时唤醒等待的进程。</span><br><span class="line">2NET_TX_SOFTIRQ网络发送中断，用于网络数据的发送操作。</span><br><span class="line">3NET_RX_SOFTIRQ网络接收中断，用于处理接收到的网络数据包。</span><br><span class="line">4BLOCK_SOFTIRQ块设备中断，用于处理块设备的异步 I/O 操作。</span><br><span class="line">5IRQ_POLL_SOFTIRQ中断轮询，用于处理某些设备的中断轮询机制。</span><br><span class="line">6TASKLET_SOFTIRQTasklet 中断，用于调度较低优先级的任务。</span><br><span class="line">7SCHED_SOFTIRQ调度中断，用于进程调度器的运行队列更新。</span><br><span class="line">8HRTIMER_SOFTIRQ高精度定时器中断，用于处理精确的定时器任务。</span><br><span class="line">9RCU_SOFTIRQRCU（Read-Copy-Update）机制，用于内存管理。</span><br></pre></td></tr></table></figure><p>软中断的处理时机</p><ol><li><strong>硬中断处理完成后</strong>，内核会检查是否有挂起的软中断。如果有则执行</li><li><strong>在某些内核路径中</strong>，内核会主动调用 do_softirq() 来检查和执行挂起的软中断。例如网络协议栈处理数据包时，通过 net_rx_action() 调用软中断；高精度定时器中，触发 hrtimer 相关软中断。</li></ol><p>软中断的优先级高于普通任务。当软中断执行时间较长、内核会将剩余未处理的软中断交给专用线程 ksoftirqd 来执行。</p><h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><p>软中断和信号的区别是，软中断是CPU级别的，软中断得到的网络包、磁盘数据包需要另外拷贝到进程空间才能被进程使用。而信号是针对进程的。也就是说，操作系统为每个CPU维护一个软中断任务队列，但每个进程都维护了自己的信号任务队列。</p><p>信号执行的时机</p><ol><li>进程从系统态返回到用户态的前夕，也就是一个用户态的进程由于系统调用、硬中断（进程切换）或异常而进入系统空间，执行完后返回用户态前，处理信号</li><li>进程在进入等待队列后刚被唤醒的时候</li></ol><p>信号可以由内核发起（内核想影响某进程的执行，主要是通知某进程终止）就给该进程发个信号，虽然都是通知进程退出，但退出原因不同。退出原因可以是终端中断，中断退出，杀死，运算错误，段错误等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#define SIGHUP 1终端挂起或控制进程终止</span><br><span class="line">#define SIGINT 2终端中断(Ctrl+C 组合键)</span><br><span class="line">#define SIGQUIT 3终端退出(Ctrl+\组合键)</span><br><span class="line">#define SIGILL 4非法指令</span><br><span class="line">#define SIGTRAP 5debug 使用，有断点指令产生</span><br><span class="line">#define SIGABRT 6由 abort(3)发出的退出指令</span><br><span class="line">#define SIGIOT 6IOT 指令</span><br><span class="line">#define SIGBUS 7总线错误</span><br><span class="line">#define SIGFPE 8浮点运算错误</span><br><span class="line">#define SIGKILL 9杀死、终止进程</span><br><span class="line">#define SIGUSR1 10用户自定义信号 1</span><br><span class="line">#define SIGSEGV 11段违例(无效的内存段)</span><br><span class="line">#define SIGUSR2 12用户自定义信号 2</span><br><span class="line">#define SIGPIPE 13向非读管道写入数据</span><br><span class="line">#define SIGALRM 14闹钟</span><br><span class="line">#define SIGTERM 15软件终止</span><br><span class="line">#define SIGSTKFLT 16栈异常</span><br><span class="line">#define SIGCHLD 17子进程结束</span><br><span class="line">#define SIGCONT 18进程继续</span><br><span class="line">#define SIGSTOP 19停止进程的执行，只是暂停</span><br><span class="line">#define SIGTSTP 20停止进程的运行(Ctrl+Z 组合键)</span><br><span class="line">#define SIGTTIN 21后台进程需要从终端读取数据</span><br><span class="line">#define SIGTTOU 22后台进程需要向终端写数据</span><br><span class="line">#define SIGURG 23有&quot;紧急&quot;数据</span><br><span class="line">#define SIGXCPU 24超过 CPU 资源限制</span><br><span class="line">#define SIGXFSZ 25文件大小超额</span><br><span class="line">#define SIGVTALRM 26虚拟时钟信号</span><br><span class="line">#define SIGPROF 27时钟信号描述</span><br><span class="line">#define SIGWINCH 28窗口大小改变</span><br><span class="line">#define SIGIO 29可以进行输入/输出操作</span><br><span class="line">#define SIGPOLLSIGIO</span><br><span class="line">#define SIGPWR 30断点重启</span><br><span class="line">#define SIGSYS 31非法的系统调用</span><br><span class="line">#define SIGUNUSED 32未使用信号</span><br></pre></td></tr></table></figure><p>磁盘&#x2F;网络数据可读可写也可以通过SIGIO信号通知到进程，也就是所说的“信号驱动式IO”。但更广泛的是通过事件通知。除了信号驱动和事件通知（非阻塞IO），进程默认是阻塞等待数据可读可写，这是通过软中断实现。软中断获得数据并把数据拷贝到进程空间后，会唤醒正在睡眠的进程，将进程从等待队列转到就绪队列。</p><h4 id="事件通知"><a href="#事件通知" class="headerlink" title="事件通知"></a>事件通知</h4><p>采用阻塞IO的进程会有先进入等待队列，数据就绪后重新进入就绪队列的逻辑。如果采用非阻塞IO，进程不会进入等待队列。</p><p>linux的字符设备&#x2F;块设备&#x2F;网络IO ，在进程中可以用文件描述符fd标识。设置文件描述符为非阻塞模式（O_NONBLOCK）从而采用非阻塞IO。</p><p>文件描述符可以与多个事件关联，这些事件表示文件描述符的状态变化，例如数据可读、可写或发生错误。linux 内部采用了事件通知的模型</p><ol><li>消费者（进程）注册感兴趣的事件和事件回调函数，例如进程注册感兴趣的读写事件</li><li>软中断将数据拷贝到用户进程空间后，会匹配注册的事件，执行对应的事件处理函数。<ol><li>如果是select&#x2F;poll，事件处理函数就是把事件设置到select 列表对应的fd，等待进程轮询找到满足事件的fd</li><li>如果是epoll，事件处理函数就是从红黑树找到对应等待的文件描述符，将fd转移到就绪队列，唤醒阻塞在epoll_wait等待的进程。epoll_wait还会通过超时解除阻塞。</li></ol></li></ol><p>事件通知驱动和主动轮询驱动 对协调模块的设计，例如消息队列， 也具有很大参考意义</p><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>锁是协调多个任务对临界区的执行，锁保证，一个任务要么独占执行完临界区，要么不执行临界区，不允许临界区同时被多个任务执行。</p><p>单机锁主要有三种，自旋锁，互斥锁，读写锁。自旋锁是互斥锁一种特殊实现</p><ol><li>spinlock 主要是保护多cpu操作对象的安全，可以是cpu共享的硬件变量，为了防止死锁，加spinlock需要屏蔽当前cpu的中断。<a href="https://www.cnblogs.com/dream397/p/15902203.html">为了防止死锁，spinlock需要关中断和禁止抢占</a></li><li>mutex，存放在内存的共享变量，维护多线程的安全</li><li>读写锁，使用count实现。读锁count-1，写锁count-很大的magic number。通过count值能知道目前持有读锁还是写锁。读写锁问题是读操作不需要等待，如果对象持续被读，写会被饿死。</li></ol>]]></content>
      
      
      <categories>
          
          <category> single-machine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> single-machine </tag>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/11/05/hello-world/"/>
      <url>/2024/11/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hello </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建之旅</title>
      <link href="/2024/11/04/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E6%97%85/"/>
      <url>/2024/11/04/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<p>使用hexo 搭建博客</p><span id="more"></span><h2 id="hexo-博客搭建"><a href="#hexo-博客搭建" class="headerlink" title="hexo 博客搭建"></a>hexo 博客搭建</h2><h3 id="step1，准备node-npm环境"><a href="#step1，准备node-npm环境" class="headerlink" title="step1，准备node, npm环境"></a>step1，准备node, npm环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh | bash</span><br><span class="line">nvm install node</span><br><span class="line"></span><br><span class="line">node -v</span><br><span class="line">npm install npm -g  </span><br></pre></td></tr></table></figure><h3 id="step2，安装和部署hexo"><a href="#step2，安装和部署hexo" class="headerlink" title="step2，安装和部署hexo"></a>step2，安装和部署hexo</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装hexo</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line">npm install -g hexo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">部署hexo</span></span><br><span class="line">hexo init tech-blog</span><br><span class="line">cd tech-blog</span><br><span class="line">npm install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载主题到themes目录，这里选择maupassant主题</span></span><br><span class="line">git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant</span><br><span class="line">npm install hexo-renderer-pug --save</span><br><span class="line">npm install hexo-renderer-sass-next --save</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个页面</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行博客，本地执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><h3 id="3-配置github-pages"><a href="#3-配置github-pages" class="headerlink" title="3. 配置github pages"></a>3. 配置github pages</h3><p>在github创建{username}.github.io仓库，例如我的github用户名为larrystd，仓库名就是larrystd.github.io。仓库需要设置成public</p><p>在.&#x2F;_config.yml文件增加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:larrystd/larrystd.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>之后执行hexo g &amp;&amp; hexo d，可自动将打包后的静态文件上传到github的仓库</p><p>在larrystd.github.io仓库点击Settings-Pages，Build and deployment-source选择Deploy from branch，branch选择master &#x2F;(root)</p><h3 id="4-配置本地搜索"><a href="#4-配置本地搜索" class="headerlink" title="4. 配置本地搜索"></a>4. 配置本地搜索</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./themes/manupassant/_config.yml增加</span></span><br><span class="line">self_search: true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令行执行</span></span><br><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><h3 id="5-配置字数统计"><a href="#5-配置字数统计" class="headerlink" title="5. 配置字数统计"></a>5. 配置字数统计</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./themes/manupassant/_config.yml增加</span></span><br><span class="line">wordcount: true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令行执行</span></span><br><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><h3 id="6-配置gitalk评论插件"><a href="#6-配置gitalk评论插件" class="headerlink" title="6. 配置gitalk评论插件"></a>6. 配置gitalk评论插件</h3><p>点击<a href="https://github.com/settings/applications/new%EF%BC%8C%E7%94%B3%E8%AF%B7OAuth">https://github.com/settings/applications/new，申请OAuth</a> application。Homepage URL和Authorization callback URL均填写{username}.github.io</p><p>复制Client ID和Client secrets</p><p>github再创一个repo，例如blog</p><p>.&#x2F;themes&#x2F;manupassant&#x2F;_config.yml增加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gitalk: ## See: https://github.com/gitalk/gitalk</span><br><span class="line">  enable: true ## If you want to use Gitment comment system please set the value to true.</span><br><span class="line">  owner: $&#123;username&#125; ## Your GitHub ID, e.g. username</span><br><span class="line">  repo: blog ## The repository to store your comments, make sure you&#x27;re the repo&#x27;s owner, e.g. gitalk.github.io</span><br><span class="line">  client_id: xxx ## GitHub client ID, e.g. 75752dafe7907a897619</span><br><span class="line">  client_secret: xxx ## GitHub client secret, e.g. ec2fb9054972c891289640354993b662f4cccc50</span><br><span class="line">  admin: $&#123;username&#125; ## Github repo owner and collaborators, only these guys can initialize github issues.</span><br></pre></td></tr></table></figure><p>最终的.&#x2F;_config.yml配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Infinity</span> <span class="string">Code</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;Simplicity is the soul of efficiency.&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">infinity</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitrssHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://larrystd.github.io</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># Apply to the whole site</span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">syntax_highlighter:</span> <span class="string">highlight.js</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">prismjs:</span></span><br><span class="line">  <span class="attr">preprocess:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">mathjax2:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Metadata elements</span></span><br><span class="line"><span class="comment">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span></span><br><span class="line"><span class="attr">meta_generator:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="string">HH:mm:ss</span></span><br><span class="line"><span class="comment">## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;</span></span><br><span class="line"><span class="attr">updated_option:</span> <span class="string">&#x27;mtime&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Include / Exclude file(s)</span></span><br><span class="line"><span class="comment">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span></span><br><span class="line"><span class="attr">include:</span></span><br><span class="line"><span class="attr">exclude:</span></span><br><span class="line"><span class="attr">ignore:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">maupassant</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:larrystd/larrystd.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>themes&#x2F;maupassant&#x2F;_config.yml 配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">disqus:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment">## If you want to use Disqus comment system, please set the value to true.</span></span><br><span class="line">  <span class="attr">shortname:</span> <span class="comment">## Your disqus_shortname, e.g. username</span></span><br><span class="line">  <span class="attr">api:</span> <span class="comment">## You can visit Disqus comments in China mainland without barriers using Disqus API, e.g. https://disqus.skk.moe/disqus/</span></span><br><span class="line">  <span class="attr">apikey:</span> <span class="comment">## Your API key obtained in Disqus API Application, e.g. yk00ZB1fjYGRkrCrDDRYDUjpp26GJWJiJRZQZ5SY0r3th5FMW6pnSzQMnWH7ua7r</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="comment">## Username of your Disqus moderator, e.g. username</span></span><br><span class="line">  <span class="attr">admin_label:</span> <span class="comment">## The text of Disqus moderator badge, e.g. Mod</span></span><br><span class="line"><span class="attr">uyan:</span> <span class="comment">## Your uyan_id. e.g. 1234567</span></span><br><span class="line"><span class="attr">livere:</span> <span class="comment">## Your livere data-uid, e.g. MTAyMC8zMDAxOC78NTgz</span></span><br><span class="line"><span class="attr">changyan:</span> <span class="comment">## Your changyan appid, e.g. cyrALsXc8</span></span><br><span class="line"><span class="attr">changyan_conf:</span> <span class="comment">## Your changyan conf, e.g. prod_d8a508c2825ab57eeb43e7c69bba0e8b</span></span><br><span class="line"><span class="attr">gitalk:</span> <span class="comment">## See: https://github.com/gitalk/gitalk</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">## If you want to use Gitment comment system please set the value to true.</span></span><br><span class="line">  <span class="attr">owner:</span> <span class="string">larrystd</span> <span class="comment">## Your GitHub ID, e.g. username</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">blogtalk</span> <span class="comment">## The repository to store your comments, make sure you&#x27;re the repo&#x27;s owner, e.g. gitalk.github.io</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">xxx</span> <span class="comment">## GitHub client ID, e.g. 75752dafe7907a897619</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">xxx</span> <span class="comment">## GitHub client secret, e.g. ec2fb9054972c891289640354993b662f4cccc50</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="string">larrystd</span> <span class="comment">## Github repo owner and collaborators, only these guys can initialize github issues.</span></span><br><span class="line"><span class="attr">valine:</span> <span class="comment">## See: https://valine.js.org</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment">## If you want to use Valine comment system, please set the value to true.</span></span><br><span class="line">  <span class="attr">appid:</span> <span class="comment">## Your LeanCloud application App ID, e.g. pRBBL2JR4N7kLEGojrF0MsSs-gzGzoHsz</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="comment">## Your LeanCloud application App Key, e.g. tjczHpDfhjYDSYddzymYK1JJ</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment">## Mail notifier, see https://github.com/xCss/Valine/wiki/Valine-评论系统中的邮件提醒设置</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment">## Validation code.</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">Just</span> <span class="string">so</span> <span class="string">so</span> <span class="comment">## Comment box placeholders.</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">&quot;mm&quot;</span> <span class="comment">## Gravatar type, see https://github.com/xCss/Valine/wiki/avatar-setting-for-valine</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment">## Number of comments per page.</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment">## Attributes of reviewers.</span></span><br><span class="line"><span class="attr">minivaline:</span> <span class="comment">## See: https://github.com/MiniValine/MiniValine</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment">## If you want to use MiniValine comment system, please set the value to true.</span></span><br><span class="line">  <span class="attr">appId:</span> <span class="comment">## Your LeanCloud application App ID, e.g. pRBBL2JR4N7kLEGojrF0MsSs-gzGzoHsz</span></span><br><span class="line">  <span class="attr">appKey:</span> <span class="comment">## Your LeanCloud application App Key, e.g. tjczHpDfhjYDSYddzymYK1JJ</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">Write</span> <span class="string">a</span> <span class="string">Comment</span> <span class="comment">## Comment box placeholder.</span></span><br><span class="line">  <span class="attr">adminEmailMd5:</span> <span class="comment">## The MD5 of Admin Email to show Admin Flag.</span></span><br><span class="line">  <span class="attr">math:</span> <span class="literal">true</span> <span class="comment">## Support MathJax.</span></span><br><span class="line">  <span class="attr">md:</span> <span class="literal">true</span> <span class="comment">## Support Markdown.</span></span><br><span class="line">  <span class="comment"># MiniValine&#x27;s display language depends on user&#x27;s browser or system environment</span></span><br><span class="line">  <span class="comment"># If you want everyone visiting your site to see a uniform language, you can set a force language value</span></span><br><span class="line">  <span class="comment"># Available values: en  | zh-CN | (and many more)</span></span><br><span class="line">  <span class="comment"># More i18n info: https://github.com/MiniValine/minivaline-i18n</span></span><br><span class="line">  <span class="attr">lang:</span></span><br><span class="line"><span class="attr">waline:</span> <span class="comment">## See: https://waline.js.org/</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment">## If you want to use Waline comment system, please set the value to true.</span></span><br><span class="line">  <span class="attr">serverURL:</span> <span class="comment">## Your server url, e.g. https://your-domain.vercel.app</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="comment">## The desired number of comments shown in each page.</span></span><br><span class="line"><span class="attr">utterances:</span> <span class="comment">## See: https://utteranc.es</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment">## If you want to use Utterances comment system, please set the value to true.</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="comment">## The repository utterances will connect to, e.g. tufu9441/comments</span></span><br><span class="line">  <span class="attr">identifier:</span> <span class="string">title</span> <span class="comment">## The mapping between blog posts and GitHub issues.</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">github-light</span> <span class="comment">## Choose an Utterances theme which matches your blog.</span></span><br><span class="line"><span class="attr">twikoo:</span> <span class="comment">## See: https://twikoo.js.org</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment">## If you want to use twikoo comment system, please set the value to true.</span></span><br><span class="line">  <span class="attr">envId:</span> <span class="comment">## Tencent CloudBase envId</span></span><br><span class="line">  <span class="attr">region:</span> <span class="comment">## Tencent CloudBase region, e.g. ap-shanghai</span></span><br><span class="line">  <span class="attr">path:</span> <span class="comment">## Article path, e.g. window.location.pathname</span></span><br><span class="line"></span><br><span class="line"><span class="attr">google_search:</span> <span class="literal">false</span> <span class="comment">## Use Google search, true/false.</span></span><br><span class="line"><span class="attr">baidu_search:</span> <span class="literal">false</span> <span class="comment">## Use Baidu search, true/false.</span></span><br><span class="line"><span class="attr">swiftype:</span> <span class="comment">## Your swiftype_key, e.g. m7b11ZrsT8Me7gzApciT</span></span><br><span class="line"><span class="attr">self_search:</span> <span class="literal">true</span> <span class="comment">## Use a jQuery-based local search engine, true/false.</span></span><br><span class="line"><span class="attr">google_analytics:</span> <span class="comment">## Your Google Analytics tracking id, e.g. UA-42425684-2</span></span><br><span class="line"><span class="attr">baidu_analytics:</span> <span class="comment">## Your Baidu Analytics tracking id, e.g. 8006843039519956000</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span> <span class="comment">## If you want to use fancybox please set the value to true.</span></span><br><span class="line"><span class="attr">show_category_count:</span> <span class="literal">false</span> <span class="comment">## If you want to show the count of categories in the sidebar widget please set the value to true.</span></span><br><span class="line"><span class="attr">toc_number:</span> <span class="literal">true</span> <span class="comment">## If you want to add list number to toc please set the value to true.</span></span><br><span class="line"><span class="attr">shareto:</span> <span class="literal">false</span> <span class="comment">## If you want to use the share button please set the value to true, and you must have hexo-helper-qrcode installed.</span></span><br><span class="line"><span class="attr">busuanzi:</span> <span class="literal">false</span> <span class="comment">## If you want to use Busuanzi page views please set the value to true.</span></span><br><span class="line"><span class="attr">wordcount:</span> <span class="literal">true</span> <span class="comment">## If you want to display the word counter and the reading time expected to spend of each post please set the value to true, and you must have hexo-wordcount installed.</span></span><br><span class="line"><span class="attr">widgets_on_small_screens:</span> <span class="literal">false</span> <span class="comment">## Set to true to enable widgets on small screens.</span></span><br><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment">## If you want to use dynamic background please set the value to true, you can also fill the following parameters to customize the dynamic effect, or just leave them blank to keep the default effect.</span></span><br><span class="line">  <span class="attr">color:</span> <span class="comment">## RGB value of the color, e.g. &quot;100,99,98&quot;</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="comment">## Transparency of lines, e.g. &quot;0.7&quot;</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="comment">## The z-index property of the background, e.g. &quot;-1&quot;</span></span><br><span class="line">  <span class="attr">count:</span> <span class="comment">## Quantity of lines, e.g. &quot;150&quot;</span></span><br><span class="line"><span class="attr">donate:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment">## If you want to display the donate button after each post, please set the value to true and fill the following items on your need. You can also enable donate button in a page by adding a &quot;donate: true&quot; item to the front-matter.</span></span><br><span class="line">  <span class="attr">github:</span> <span class="comment">## GitHub URL, e.g. https://github.com/Kaiyuan/donate-page</span></span><br><span class="line">  <span class="attr">alipay_qr:</span> <span class="comment">## Path of Alipay QRcode image, e.g. /img/AliPayQR.png</span></span><br><span class="line">  <span class="attr">wechat_qr:</span> <span class="comment">## Path of Wechat QRcode image, e.g. /img/WeChatQR.png</span></span><br><span class="line">  <span class="attr">btc_qr:</span> <span class="comment">## Path of Bitcoin QRcode image, e.g. /img/BTCQR.png</span></span><br><span class="line">  <span class="attr">btc_key:</span> <span class="comment">## Bitcoin key, e.g. 1KuK5eK2BLsqpsFVXXSBG5wbSAwZVadt6L</span></span><br><span class="line">  <span class="attr">paypal_url:</span> <span class="comment">## Paypal URL, e.g. https://www.paypal.me/tufu9441</span></span><br><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">## If you want to display the copyright info after each post, please set the value to true and fill the following items on your need.</span></span><br><span class="line">  <span class="attr">author:</span> <span class="string">Infinity</span> <span class="comment">## Your author name, e.g. tufu9441</span></span><br><span class="line">  <span class="attr">copyright_text:</span> <span class="comment">## Your copyright text, e.g. The author owns the copyright, please indicate the source reproduced.</span></span><br><span class="line"><span class="attr">love:</span> <span class="literal">false</span> <span class="comment">## If you want the peach heart to appear when you click anywhere, set the value to true.</span></span><br><span class="line"><span class="attr">plantuml:</span> <span class="comment">## Using PlantUML to generate UML diagram, must install hexo-filter-plantuml (https://github.com/miao1007/hexo-filter-plantuml).</span></span><br><span class="line">  <span class="attr">render:</span> <span class="string">&quot;PlantUMLServer&quot;</span> <span class="comment">##  Local or PlantUMLServer.</span></span><br><span class="line">  <span class="attr">outputFormat:</span> <span class="string">&quot;svg&quot;</span> <span class="comment">## common options: svg/png</span></span><br><span class="line"><span class="attr">copycode:</span> <span class="literal">true</span> <span class="comment">## If you want to enable one-click copy of the code blocks, set the value to true.</span></span><br><span class="line"><span class="attr">dark:</span> <span class="literal">true</span> <span class="comment">## If you want to toggle between light/dark themes, set the value to true.</span></span><br><span class="line"><span class="attr">totop:</span> <span class="literal">true</span> <span class="comment">## If you want to use the rocketship button to return to the top, set the value to true.</span></span><br><span class="line"><span class="attr">external_css:</span> <span class="literal">false</span> <span class="comment">## If you want to load an external CSS file, set the value to true and create a file named &quot;external.css&quot; in the source/css folder.</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/images/favicon.ico</span></span><br><span class="line"></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">page:</span> <span class="string">home</span></span><br><span class="line">    <span class="attr">directory:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">page:</span> <span class="string">archive</span></span><br><span class="line">    <span class="attr">directory:</span> <span class="string">archives/</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">page:</span> <span class="string">tags</span></span><br><span class="line">    <span class="attr">directory:</span> <span class="string">tags/</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">page:</span> <span class="string">about</span></span><br><span class="line">    <span class="attr">directory:</span> <span class="string">about/</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">page:</span> <span class="string">rss</span></span><br><span class="line">    <span class="attr">directory:</span> <span class="string">atom.xml</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa-rss</span></span><br><span class="line"></span><br><span class="line"><span class="attr">widgets:</span> <span class="comment">## Six widgets in sidebar provided: search, category, tag, recent_posts, recent_comments and links.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">search</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">info</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">category</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">tag</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">recent_posts</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">recent_comments</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">links</span></span><br><span class="line"></span><br><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">/img/avatar.png</span></span><br><span class="line">  <span class="attr">discription:</span> <span class="string">To</span> <span class="string">be</span> <span class="string">a</span> <span class="string">better</span> <span class="string">man.</span></span><br><span class="line">  <span class="attr">outlinkitem:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envelope</span></span><br><span class="line">      <span class="attr">outlink:</span> <span class="string">venray.kong@outlook.com</span></span><br><span class="line">      <span class="attr">message:</span> <span class="string">Email</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">github</span></span><br><span class="line">      <span class="attr">outlink:</span> <span class="string">https://github.com/larrystd</span></span><br><span class="line">      <span class="attr">message:</span> <span class="string">Github</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">rss</span></span><br><span class="line">      <span class="attr">outlink:</span> <span class="string">/atom.xml</span></span><br><span class="line">      <span class="attr">message:</span> <span class="string">RSS</span></span><br><span class="line"></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">title:</span> <span class="string">todo</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.example1.com/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">timeline:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">num:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">word:</span> <span class="number">2014</span><span class="string">/06/12-Start</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">num:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">word:</span> <span class="number">2014</span><span class="string">/11/29-XXX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">num:</span> <span class="number">3</span></span><br><span class="line">    <span class="attr">word:</span> <span class="number">2015</span><span class="string">/02/18-DDD</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">num:</span> <span class="number">4</span></span><br><span class="line">    <span class="attr">word:</span> <span class="string">More</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Static files</span></span><br><span class="line"><span class="attr">js:</span> <span class="string">js</span></span><br><span class="line"><span class="attr">css:</span> <span class="string">css</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Theme version</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><h2 id="hexo-原理"><a href="#hexo-原理" class="headerlink" title="hexo 原理"></a>hexo 原理</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>themes&#x2F;maupassant 模板下面的目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── languages</span><br><span class="line">│   ├── de-DE.yml</span><br><span class="line">│   ├── en.yml</span><br><span class="line">│   ├── zh-CN.yml</span><br><span class="line">│   └── zh-TW.yml</span><br><span class="line">├── layout</span><br><span class="line">│   ├── archive.pug</span><br><span class="line">│   ├── base.pug</span><br><span class="line">│   ├── base-without-sidebar.pug</span><br><span class="line">│   ├── blogroll.pug</span><br><span class="line">│   ├── index.pug</span><br><span class="line">│   ├── page.pug</span><br><span class="line">│   ├── _partial</span><br><span class="line">│   ├── post.pug</span><br><span class="line">│   └── _widget</span><br><span class="line">├── LICENSE</span><br><span class="line">├── package.json</span><br><span class="line">├── README.md</span><br><span class="line">└── source</span><br><span class="line">    ├── css</span><br><span class="line">    ├── img</span><br><span class="line">    └── js</span><br><span class="line">        ├── codeblock-resizer.js</span><br><span class="line">        ├── copycode.js</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><h4 id="layout目录"><a href="#layout目录" class="headerlink" title="layout目录"></a>layout目录</h4><p>layout 目录下面的*.pug文件 是html template模板，定义了主要页面的布局</p><p>hexo的主要页面有三个</p><ol><li>post，表示文章的布局</li><li>page，表示目录的布局，如主页、archieve页，页面都是文章标题的目录</li><li>draft， 这个应用的比较少</li></ol><p>hexo 创建页面的命令<br><code>hexo new page &quot;&#123;name&#125;&quot;</code>, <code>hexo new post &quot;&#123;name&#125;&quot;</code></p><h4 id="source目录"><a href="#source目录" class="headerlink" title="source目录"></a>source目录</h4><p>source下面有三个目录,css,img, js，这三个都会被layout下面定义的模板所引用</p><h3 id="hexo-自定义内容"><a href="#hexo-自定义内容" class="headerlink" title="hexo 自定义内容"></a>hexo 自定义内容</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── db.json</span><br><span class="line">├── node_modules</span><br><span class="line">│   ├── abab</span><br><span class="line">│   ├── abbrev</span><br><span class="line">│   ├── acorn</span><br><span class="line">│   ├── acorn-globals</span><br><span class="line">├── package.json</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── public</span><br><span class="line">│   ├── 2024</span><br><span class="line">│   ├── about</span><br><span class="line">│   ├── archives</span><br><span class="line">│   ├── atom.xml</span><br><span class="line">│   ├── categories</span><br><span class="line">│   ├── css</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   ├── img</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── js</span><br><span class="line">│   ├── search.xml</span><br><span class="line">│   └── tags</span><br><span class="line">├── scaffolds</span><br><span class="line">│   ├── draft.md</span><br><span class="line">│   ├── page.md</span><br><span class="line">│   └── post.md</span><br><span class="line">├── source</span><br><span class="line">│   ├── about</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   ├── images</span><br><span class="line">│   ├── _posts</span><br><span class="line">│   │   └── hello-world.md</span><br><span class="line">│   └── tags</span><br><span class="line">├── themes</span><br><span class="line">│   └── maupassant</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure><p>node_modules 是npm install xxx –save下载到当前目录的模块</p><p>scaffolds目录定义了post，page, draft三个主要页面的构造模板</p><p>source下面是定义的页面，src&#x2F;_posts 下面是文档</p><p>public目录下是打包形成的静态文件</p>]]></content>
      
      
      <categories>
          
          <category> application </category>
          
      </categories>
      
      
        <tags>
            
            <tag> application </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
