<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Infinity Code | Simplicity is the soul of efficiency.</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Infinity Code</h1><a id="logo" href="/.">Infinity Code</a><p class="description">Simplicity is the soul of efficiency.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"><a href="/2025/04/20/C++%E5%8D%8F%E7%A8%8B%E5%92%8C%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/">C++协程和高性能编程</a></h1><div class="post-meta">2025-04-20</div><div class="post-content">

C++20协程C++20 提供了协程支持，协程可以看做任务，任务执行期间可以在某个位置暂停-继续。
C++ 提供std::coroutine_handle&lt;&gt;作为协程句柄, 协程句柄需要传入自定义的Promise类型，用来指定协程的返回值，初始化和退出行为等。promise_type 必须实现以下成员函数

std::coroutine_handle&lt;promise&gt; get_return_object() 返回coroutine_handle对象
initial_suspend()	控制协程启动时是否立即挂起，返回 suspend_always 表示协程创建后挂起, 需要调用一次resume才会执行, 返回 suspend_never表示协程创建后立即执行
final_suspend()	控制协程结束时是否挂起, 同样可以返回 suspend_always 或者 suspend_never
yield_value(value)	接受co_yield 表达式返回值, 可以处理
return_value(value)  接受co_return value返回值，可以处理
return_void() 执行co_return后执行该函数
unhandled_exception()	处理协程中未捕获的异常。

通过以上函数，可以实现协程创建后，销毁前，co_return&#x2F;co_yield之后的行为
1234567891011121314151617template&lt;typename T&gt;struct promise_type &#123;    T current_value;    // 协程挂起时的返回值    auto yield_value(T value) &#123;        current_value = value;        return std::suspend_always&#123;&#125;; // 每次生成后暂停    &#125;    // 协程初始化设置    auto initial_suspend() &#123; return std::suspend_always&#123;&#125;; &#125;    auto final_suspend() noexcept &#123; return std::suspend_always&#123;&#125;; &#125;    Generator get_return_object() &#123; return std::coroutine_handle&lt;promise_type&gt;::from_promise(*this); &#125;    void unhandled_exception() &#123; std::terminate(); &#125;    void return_void() &#123;&#125;&#125;;std::coroutine_handle&lt;promise_type&gt;;

协程一重要的关键字是co_await，表示挂起当前协程，执行流切换到其他任务。co_await 后面需要加Awaiter对象.awaiter必须要实现的三个函数

bool await_ready() const noexcept; 表示调用co_await后是否立即执行，如果返回true，则直接执行，不会挂起当前协程。
void await_suspend(std::coroutine_handle&lt;&gt; handle) noexcept; 参数为当前协程句柄, 可以将执行流切给指定的coroutine_handle
T await_resume() noexcept; 当协程处于co_await状态，调用resume时执行该函数。

12345678910struct custom_awaiter &#123;    // 判断是否直接继续执行（true=不挂起）    bool await_ready() noexcept;    // 挂起时执行（参数为当前协程句柄）    void await_suspend(std::coroutine_handle&lt;&gt; h) noexcept;    // 恢复时执行的逻辑与返回值    int await_resume() noexcept;&#125;;

协程执行例子
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;coroutine&gt;#include &lt;cstdio&gt;#include &lt;thread&gt;// 1. 定义协程返回类型 Taskstruct Task &#123;    struct promise_type &#123;        Task get_return_object() &#123;             printf (&quot;创建协程对象\n&quot;);            return Task&#123;std::coroutine_handle&lt;promise_type&gt;::from_promise(*this)&#125;;         &#125;        std::suspend_always initial_suspend() &#123; // 返回suspend_always 对象, 协程初始化后挂起            printf (&quot;初始化挂起\n&quot;);            return &#123;&#125;;         &#125;        std::suspend_always final_suspend() noexcept &#123; // 协程结束后挂起            printf (&quot;最终挂起\n&quot;);            return &#123;&#125;;         &#125;        void return_void() &#123;             printf (&quot;协程返回\n&quot;);         &#125;        void unhandled_exception() &#123;             std::terminate();         &#125;    &#125;;    std::coroutine_handle&lt;promise_type&gt; handle;    explicit Task(std::coroutine_handle&lt;promise_type&gt; h) : handle(h) &#123;&#125;    ~Task() &#123;        if (handle) handle.destroy();        printf (&quot;销毁协程\n&quot;);    &#125;    // 恢复当前协程执行    void resume() &#123;        if (!handle.done()) &#123;            printf (&quot;恢复协程执行\n&quot;);            handle.resume();        &#125;    &#125;&#125;;// 2. 定义可等待对象（Awaiter）struct AsyncOperation &#123;    bool await_ready() const &#123;         printf(&quot;检查是否就绪\n&quot;);        return false; // 总是挂起    &#125;    void await_suspend(std::coroutine_handle&lt;&gt; h) &#123;        printf (&quot;开始异步操作...\n&quot;);        // 新建额外线程, suspend不阻塞        std::thread([h] &#123;            std::this_thread::sleep_for(std::chrono::seconds(1));            printf (&quot;异步操作完成\n&quot;);            h.resume(); // 完成后恢复协程        &#125;).detach();    &#125;    void await_resume() &#123;        printf (&quot;处理操作结果\n&quot;);    &#125;&#125;;// 3. 协程函数定义Task my_coroutine() &#123;    printf (&quot;协程开始执行\n&quot;);    co_await AsyncOperation&#123;&#125;; // 等待异步操作    printf (&quot;继续执行协程体\n&quot;);    co_await std::suspend_always&#123;&#125;; // 主动挂起    printf (&quot;协程最终阶段\n&quot;);&#125;// 4. 主函数int main() &#123;    Task task = my_coroutine(); // 创建并初始化协程, 协程挂起    printf (&quot;首次恢复协程:\n&quot;);    task.resume();             // 第一次, 启动协程    printf (&quot;执行流切回主线程:\n&quot;);    sleep(5);    printf (&quot;二次恢复协程:\n&quot;);    task.resume();             // 第二次恢复        printf (&quot;\n程序结束\n&quot;);    return 0;&#125;// 执行结果创建协程对象初始化挂起首次恢复协程:恢复协程执行协程开始执行检查是否就绪开始异步操作...执行流切回主线程:异步操作完成处理操作结果继续执行协程体二次恢复协程:恢复协程执行协程最终阶段协程返回最终挂起程序结束销毁协程
执行流分析

Task task &#x3D; my_coroutine() 时，创建协程和初始化对象, 分别执行Task get_return_object() 和std::suspend_always initial_suspend()两个函数
task.resume(); 执行会启动协程，协程执行到co_await，挂起。协程挂起后，执行流交给main函数, 也就是调用resume()的函数
await_suspend 创建了新线程用来执行异步任务，异步任务执行完成后在新线程中调用h.resume()，协程继续在新线程执行，主线程这时候在sleep()
新线程继续执行协程，直到co_await std::suspend_always{}; 直接挂起（显然std::suspend_always{}; 也是一种awaiter表示无条件挂起）。这时候新线程执行完毕退出，但协程对象挂在co_await
最后主线程sleep()完执行task.resume(); 协程又继续执行, 直到协程执行完毕, 调用final_suspend由于final_suspend返回std::suspend_always{};，协程被挂起而不是销毁
主线程执行完毕, 最后调用handle.destroy();销毁协程

执行co_await 时将当前协程交给线程池异步执行, 当前协程切回协程resume的位置
12345678910111213struct ThreadPoolAwaiter &#123;    ThreadPool&amp; pool;    bool await_ready() &#123; return false; &#125;        void await_suspend(std::coroutine_handle&lt;&gt; h) &#123;        pool.enqueue([h] &#123; h.resume(); &#125;); // 提交到线程池    &#125;        void await_resume() &#123;&#125;&#125;;co_await ThreadPoolAwaiter&#123;my_thread_pool&#125;;

协程链式调用我们想要像函数调用那样实现协程调用, 也是co_awaiter一个协程, 当子协程执行完毕后, 返回给父协程继续执行。

这样的子协程是一个类, 需要实现promise_type管理协程生命周期, 也需要实现Awaiter 接受co_await调用
await_suspend函数会传父协程handle，需要把它记住。当子协程执行完毕, 需要在final_suspend()中把父协程恢复。

举例, 

每个协程函数都返回Task类型。执行co_await Task, 会调用Task的await_suspend(), 将父协程设置成子协程的nextjob, 返回当前协程(Task同时是Awaiter和协程), 表示执行当前协程
对于PromiseBase, final_suspend() 返回一个FinalAwaiter.协程销毁后会调用FinalAwaiter的await_suspend(), 执行协程的nextjob，也就是恢复父协程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869  struct FinalAwaiter &#123;    auto await_ready() const noexcept -&gt; bool &#123; return false; &#125;    template &lt;typename Promise&gt;    auto await_suspend(std::coroutine_handle&lt;Promise&gt; handle) noexcept -&gt; void    &#123;      assert(handle.done() &amp;&amp; &quot;handle should done here&quot;);      auto&amp; promise = handle.promise();      // 这一步同时更新了promise.mNextJob==nullptr, 也就是标识task执行完了      auto next = promise.mNextJob.exchange(nullptr);      if (next == nullptr) &#123;        if (promise.getState() != nullptr) [[unlikely]] &#123;          promise.getState()-&gt;store(JobState::Final, std::memory_order_release);          promise.getState()-&gt;notify_one();        &#125;      &#125; else if (next == &amp;detail::kDetachJob) &#123;        if (promise.getState() != nullptr) [[unlikely]] &#123;          promise.getState()-&gt;store(JobState::Final, std::memory_order_release);          promise.getState()-&gt;notify_one();        &#125;        promise.mThisHandle.destroy();      &#125; else if (next != &amp;detail::kEmptyJob) &#123;        // 把nextjob加入到loop, 由主线程执行(ExeOpt::prefInOne)        Proactor::get().execute(next, ExeOpt::prefInOne());      &#125;    &#125;    auto await_resume() noexcept -&gt; void &#123;&#125;  &#125;;struct PromiseBase &#123;  auto initial_suspend() noexcept -&gt; std::suspend_always &#123; return &#123;&#125;; &#125;  auto final_suspend() noexcept -&gt; FinalAwaiter &#123; return &#123;&#125;; &#125;  auto unhandled_exception() noexcept -&gt; void &#123; mExceptionPtr = std::current_exception(); &#125;  auto setNextJob(WorkerJob* next) noexcept -&gt; void &#123; mNextJob = next; &#125;  auto getNextJob() noexcept -&gt; std::atomic&lt;WorkerJob*&gt;&amp; &#123; return mNextJob; &#125;  CoroJob mThisJob&#123;this, &amp;CoroJob::run&#125;;  std::coroutine_handle&lt;&gt; mThisHandle;  std::atomic&lt;WorkerJob*&gt; mNextJob&#123;nullptr&#125;;  std::exception_ptr mExceptionPtr;&#125;;template &lt;typename T&gt;class Task &#123;public:  using promise_type = Promise&lt;T&gt;;  using coroutine_handle_type = std::coroutine_handle&lt;promise_type&gt;;  using value_type = T;  Task() noexcept = default;  explicit Task(coroutine_handle_type handle) noexcept : mHandle(handle)  &#123;    assert(mHandle != nullptr);    mHandle.promise().setCoHandle(mHandle);  &#125;  struct AwaiterBase &#123;    auto await_ready() const noexcept -&gt; bool &#123; return false; &#125;    template &lt;typename Promise&gt;    auto await_suspend(std::coroutine_handle&lt;Promise&gt; handle) noexcept -&gt; void    &#123;    // 设置为handle.promise.nextjob      mHandle.promise().setNextJob(handle.promise().getThisJob());      mHandle.promise().setState(handle.promise().getState());        // 执行当前协程      Proactor::get().execute(mHandle.promise().getThisJob(), ExeOpt::prefInOne());    &#125;    coroutine_handle_type mHandle;  &#125;;

folly库实现的协程链式调用

保存父协程promise.continuation_ &#x3D; continuation;
返回当前task的coro_handle, coro_, 执行当前task

123456789101112131415161718192021222324252627282930bool await_ready() noexcept &#123; return false; &#125;template &lt;typename Promise&gt;FOLLY_NOINLINE auto await_suspend(    coroutine_handle&lt;Promise&gt; continuation) noexcept &#123;  DCHECK(coro_);  auto&amp; promise = coro_.promise();  promise.continuation_ = continuation;  auto&amp; calleeFrame = promise.getAsyncFrame();  calleeFrame.setReturnAddress();  if constexpr (detail::promiseHasAsyncFrame_v&lt;Promise&gt;) &#123;    auto&amp; callerFrame = continuation.promise().getAsyncFrame();    folly::pushAsyncStackFrameCallerCallee(callerFrame, calleeFrame);    return coro_;  &#125; else &#123;    folly::resumeCoroutineWithNewAsyncStackRoot(coro_);    return;  &#125;&#125;T await_resume() &#123;  DCHECK(coro_);  SCOPE_EXIT &#123;    std::exchange(coro_, &#123;&#125;).destroy();  &#125;;  return std::move(coro_.promise().result()).value();&#125;

协程和异步我们可以思考链式协程模式的特点

每个协程Task既是一个挂起-恢复的协程任务，也是一个Awaiter。协程的await_suspend会记录父协程, final_suspend恢复父协程。
协程的阻塞任务, 包括申请锁, sleep, IO等都可以封装成一个Awaiter, 这个awaiter可以在suspend的时候挂起，如果需要调用read等阻塞调用，需要创建新线程执行
执行协程的线程会执行一个循环(eventloop)，这个线程用于不会阻塞。这个线程做的事情就是1. 循环遍历，如果有协程挂起并创建新线程执行异步任务，就查看异步任务是否执行完，若执行完恢复该协程的调用。 2. 如果协程全部执行完了, 线程根据链式调用, 恢复该协程父协程的执行。3. 尝试接受新的协程任务

协程锁可以通过标志和等待队列实现,

尝试申请锁时, 如果锁未被申请, 则持有锁, 协程继续执行
如果锁已被申请, 则将当前协程加入等待队列, 并挂起当前协程
释放锁时，唤醒处于等待队列的一个协程恢复它执行执行协程的线程会执行一个循环，如果无协程可执行（协程全部在挂起），线程则进入下一个循环

协程也可以实现类似golang的channel。channel 由一个ringbuffer和reader, writer两个队列组成。

reader 进入时, 如果ringbuffer为空，则挂起reader; ringbuffer不为空，则读取ringbuffer中的数, 同时唤醒等待队列的writer
writer写入时，如果ringbuffer满了，则挂起；否则写入并唤醒所有reader; reader被唤醒时，读取writer写入的数据。显然协程的一个核心是《唤醒》的实现，只需要coroutine.resume()即可, 这比线程的唤醒要简单很多。

协程可以在await_suspend中调用liburing等异步io函数，然后挂起。同时主线程循环检查liburing的cqe(complete queue entry)，对于完成的IO，唤醒对应的协程继续处理。
dpdk和spdk协程很自然的和liburing等异步调用结合, 通过轮询cqe的方式对IO完成的协程继续执行。这比基于epoll 的事件通知、中断通知更高效。
DPDK（Data Plane Development Kit）和SPDK（Storage Performance Development Kit）是两款由英特尔发起的开源项目，分别专注于提升网络数据平面和存储I&#x2F;O的性能。这两个项目在网络包和存储IO方面提供异步调用函数，可无缝接入以上轮询唤醒协程的模式。
DPDK和SPDK还增加了用户态绕过内核，零拷贝等加速性能的设计
DPDK​, 包括mTCP, 是一个用户态TCP协议栈。数据包直接从网卡读取，发给用户态组成TCP包。

​用户态网络驱动​​。绕过内核协议栈，直接在用户态处理网络包，减少数据拷贝和上下文切换。
​​零拷贝技术​​。通过大页内存（HugePage）和内存池（Memory Pool）减少内存访问开销。
轮询模式​​。使用无锁队列（Ring）和CPU轮询（Poll-mode Driver）避免中断延迟。
​多核扩展​​ 基于线程绑定（CPU affinity）和流水线模型实现高性能多核处理。


​​SPDK​​，通常和liburing 结合使用, 存储层一般还是会经过内核，走vfs接口, 利用内核的pagecache缓存和块设备抽象。

​用户态NVMe驱动​​ 完全用户态实现NVMe协议，避免内核存储栈的开销。
​异步无锁设计​​ 使用异步I&#x2F;O和事件驱动模型，减少锁竞争。
​​零拷贝访问​​ 通过内存映射（Memory-mapped I&#x2F;O）和直接访问SSD的PRP（Physical Region Page）列表提升效率。
​高并发优化​​ 支持多队列（Multi-queue）和并行I&#x2F;O请求，充分利用NVMe SSD的多核能力。

C++ 通过结合dpdk和spdk生态，以及用户态tcp协议(mTCP)和liburing，实现了网络和存储IO的高性能。再加上流行的gpu cuda高性能计算框架，使C++在高性能计算&#x2F;存储&#x2F;网络领域不可替代。
</div><p class="readmore"><a href="/2025/04/20/C++%E5%8D%8F%E7%A8%8B%E5%92%8C%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2025/02/15/leveldb(2)%E2%80%94%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/">leveldb(2)—线程模型和并发控制</a></h1><div class="post-meta">2025-02-15</div><div class="post-content"><p>leveldb前台可并发读，但只能串行写。</p>
<p>leveldb memtable通过无锁skiplist结构 支持读写并发</p>
<p>leveldb的后台线程只有一个，只处理compaction这一个任务, leveldb的minor compaction和major compaction是一起处理的</p></div><p class="readmore"><a href="/2025/02/15/leveldb(2)%E2%80%94%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2025/02/12/redis(2)%E2%80%94%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/">redis(2)——网络处理和持久化</a></h1><div class="post-meta">2025-02-12</div><div class="post-content"><p>redis 通过网络服务接收远程命令，进行处理，将执行结果返回。</p>
<p>redis 4.0版本监听网络请求，处理请求和命令都由一个主线程完成。</p>
<ol>
<li>好处是redis 主IO路径无须加锁保护。</li>
<li>缺点是redis 不可处理耗时长的命令，这在使用自定义命令和复杂lua脚本里需要注意。此外redis 无法利用多核cpu，这对部署机器的cpu单核能力有要求。</li>
</ol>
<p>redis的rdb和aof 都是经典的数据持久化&#x2F;备份手段，rdb关注数据库的数据, aof关注数据库的操作。</p></div><p class="readmore"><a href="/2025/02/12/redis(2)%E2%80%94%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2025/02/09/redis(1)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">redis(1)——数据结构</a></h1><div class="post-meta">2025-02-09</div><div class="post-content"><p>redis 是最值得学习的开源项目，</p>
<ol>
<li>它广泛应用 </li>
<li>它实现了单机缓存数据库，同时支持网络访问、复制、集群、订阅等高级特性 </li>
<li>redis依赖很少，数据结构、日志等基础库也是自行实现，有利于学习 </li>
<li>redis代码精悍、质量高，甚至很难找到优化点。</li>
</ol>
<p>本文阐释redis数据结构，redis 数据结构设计的一大特点是节省内存。原因是redis作为内存数据库需要节省内存使用(连续内存的数组能减少内存碎片)。这对架构设计同样有借鉴意义，通过节省元数据内存使用来把更多元数据&#x2F;索引放在内存上，可以大大提高处理的吞吐和延迟。</p></div><p class="readmore"><a href="/2025/02/09/redis(1)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2025/01/31/leveldb(1)%E2%80%94%E6%A6%82%E8%A7%88/">leveldb(1)—概览</a></h1><div class="post-meta">2025-01-31</div><div class="post-content"><p>leveldb 可分为五大块。db, iterator，version, memtable+log, tablefile。</p>
<p>leveldb 的架构图资料上有很多，可以参考<a target="_blank" rel="noopener" href="https://youjiali1995.github.io/storage/leveldb-architecture/">网站</a></p></div><p class="readmore"><a href="/2025/01/31/leveldb(1)%E2%80%94%E6%A6%82%E8%A7%88/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2025/01/06/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%BA%95%E5%BA%A7/">分布式存储底座</a></h1><div class="post-meta">2025-01-06</div><div class="post-content"><p>分布式存储底座包括分布式文件系统和分布式一致性KV存储。对外满足的条件 1. 提供数据可靠性，底座之上不需要担心数据损坏 2. 提供数据可用性，节点崩溃不影响数据读写 3. 集群级接口，多机节点可访问</p></div><p class="readmore"><a href="/2025/01/06/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%BA%95%E5%BA%A7/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2025/01/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(6)%E2%80%94%E7%BC%96%E8%AF%91%E3%80%81%E8%BF%90%E8%A1%8C%E5%92%8C%E8%B0%83%E8%AF%95/">编程语言(6)—编译、运行和调试</a></h1><div class="post-meta">2025-01-02</div><div class="post-content"><p>写完了代码第一件事是编译，编译失败只能根据编译器通知修改代码；编译通过了第二件事是跑UT，UT不过需要进行调试。调试包括debug和release包的调试，线上进程的运行问题有时候也需要调试，调试的主要方式是调试工具和日志（包括print大法）。为了发现问题，有时候还需要添加报警日志。</p>
<p>提高代码的健壮性，编译器、静态检查和格式化工具、调试、单元测试、日志等是开发必不可少的</p></div><p class="readmore"><a href="/2025/01/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(6)%E2%80%94%E7%BC%96%E8%AF%91%E3%80%81%E8%BF%90%E8%A1%8C%E5%92%8C%E8%B0%83%E8%AF%95/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2024/12/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(5)%E2%80%94%E6%96%87%E4%BB%B6IO%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%93/">编程语言(5)—文件IO和网络库</a></h1><div class="post-meta">2024-12-24</div><div class="post-content"><p>linux系统的文件接口是十分重要的抽象, 也就是“一切都是文件”。借助文件IO，用户程序可以读写磁盘设备、网络设备、甚至管道、内存等。</p></div><p class="readmore"><a href="/2024/12/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(5)%E2%80%94%E6%96%87%E4%BB%B6IO%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%93/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2024/12/22/%E7%BC%93%E5%AD%98%E7%AE%80%E8%B0%88/">缓存简谈</a></h1><div class="post-meta">2024-12-22</div><div class="post-content"><p>缓存存放的是临时数据，相比主存，缓存往往速度更快，容量更小。</p>
<p>缓存往往是多级的，由内而外，cpu cache -&gt; 内存 -&gt; ssd -&gt; hdd（单机） -&gt; 服务器&#x2F;多节点&#x2F;oss&#x2F;nas等</p>
<p><strong>只要有缓存就会有一致性问题</strong></p></div><p class="readmore"><a href="/2024/12/22/%E7%BC%93%E5%AD%98%E7%AE%80%E8%B0%88/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2024/12/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0/">编程语言——静态变量和静态函数</a></h1><div class="post-meta">2024-12-22</div><div class="post-content"><p>简谈编程语言中的静态变量和函数</p></div><p class="readmore"><a href="/2024/12/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0/">阅读全文</a></p></div><nav class="page-navigator"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页</a></nav><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML" async></script></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>To be a better man.</p><a class="info-icon" href="venray.kong@outlook.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/larrystd" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/application/">application</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/base/">base</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hello/">hello</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/language/">language</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/multi-machine/">multi-machine</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/single-machine/">single-machine</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/hello/" style="font-size: 15px;">hello</a> <a href="/tags/single-machine/" style="font-size: 15px;">single-machine</a> <a href="/tags/storage/" style="font-size: 15px;">storage</a> <a href="/tags/application/" style="font-size: 15px;">application</a> <a href="/tags/base/" style="font-size: 15px;">base</a> <a href="/tags/os/" style="font-size: 15px;">os</a> <a href="/tags/language/" style="font-size: 15px;">language</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/leveldb/" style="font-size: 15px;">leveldb</a> <a href="/tags/cpp/" style="font-size: 15px;">cpp</a> <a href="/tags/coroutine/" style="font-size: 15px;">coroutine</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/04/20/C++%E5%8D%8F%E7%A8%8B%E5%92%8C%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/">C++协程和高性能编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/15/leveldb(2)%E2%80%94%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/">leveldb(2)—线程模型和并发控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/12/redis(2)%E2%80%94%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/">redis(2)——网络处理和持久化</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/09/redis(1)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">redis(1)——数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/31/leveldb(1)%E2%80%94%E6%A6%82%E8%A7%88/">leveldb(1)—概览</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/06/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%BA%95%E5%BA%A7/">分布式存储底座</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(6)%E2%80%94%E7%BC%96%E8%AF%91%E3%80%81%E8%BF%90%E8%A1%8C%E5%92%8C%E8%B0%83%E8%AF%95/">编程语言(6)—编译、运行和调试</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/12/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(5)%E2%80%94%E6%96%87%E4%BB%B6IO%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%93/">编程语言(5)—文件IO和网络库</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/12/22/%E7%BC%93%E5%AD%98%E7%AE%80%E8%B0%88/">缓存简谈</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/12/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0/">编程语言——静态变量和静态函数</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="todo" target="_blank">todo</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Infinity Code.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>