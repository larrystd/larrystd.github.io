<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>redis(2)——网络处理和持久化 | Infinity Code</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">redis(2)——网络处理和持久化</h1><a id="logo" href="/.">Infinity Code</a><p class="description">Simplicity is the soul of efficiency.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">redis(2)——网络处理和持久化</h1><div class="post-meta">2025-02-12<span> | </span><span class="category"><a href="/categories/storage/">storage</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">网络处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%92%8Ceventloop-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.1.</span> <span class="toc-text">事件和eventloop 事件循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">事件处理函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fork-%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">fork 子进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-create-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">pthread_create 多线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rdb%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">rdb持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rdbsave"><span class="toc-number">3.1.</span> <span class="toc-text">rdbsave</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdbsave-%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">rdbsave 的调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdbLoadRio"><span class="toc-number">3.3.</span> <span class="toc-text">rdbLoadRio</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aof%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">aof持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#aof-rewrite"><span class="toc-number">4.1.</span> <span class="toc-text">aof rewrite</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pub-sub"><span class="toc-number">5.</span> <span class="toc-text">pub-sub</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SubscribeChannel"><span class="toc-number">5.1.</span> <span class="toc-text">SubscribeChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pubsubPublishMessage"><span class="toc-number">5.2.</span> <span class="toc-text">pubsubPublishMessage</span></a></li></ol></li></ol></div></div><div class="post-content"><p>redis 通过网络服务接收远程命令，进行处理，将执行结果返回。</p>
<p>redis 4.0版本监听网络请求，处理请求和命令都由一个主线程完成。</p>
<ol>
<li>好处是redis 主IO路径无须加锁保护。</li>
<li>缺点是redis 不可处理耗时长的命令，这在使用自定义命令和复杂lua脚本里需要注意。此外redis 无法利用多核cpu，这对部署机器的cpu单核能力有要求。</li>
</ol>
<p>redis的rdb和aof 都是经典的数据持久化&#x2F;备份手段，rdb关注数据库的数据, aof关注数据库的操作。</p>
<span id="more"></span>

<h3 id="网络处理"><a href="#网络处理" class="headerlink" title="网络处理"></a>网络处理</h3><p>redis 的网络处理类似常见的IO多路复用网络库，通过事件通知实现单线程处理大量来自不同客户端的事件。</p>
<h4 id="事件和eventloop-事件循环"><a href="#事件和eventloop-事件循环" class="headerlink" title="事件和eventloop 事件循环"></a>事件和eventloop 事件循环</h4><p>三种事件aeFileEvent（注册的网络事件），aeTimeEvent（定时事件），firedEvent用来存放epoll返回的就绪事件（即需要处理的事件）</p>
<p>网络事件通过epoll 监听fd可读可写（即网络包可读可写）触发；定时事件通过获得下一个最近事件的执行时间、定时触发；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">aeFileEvent</span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">/* File event structure */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">aeFileEvent</span> &#123;</span><br><span class="line">    <span class="type">int</span> mask; <span class="comment">/* one of AE_(READABLE|WRITABLE) */</span></span><br><span class="line">    aeFileProc *rfileProc;</span><br><span class="line">    aeFileProc *wfileProc;</span><br><span class="line">    <span class="type">void</span> *clientData;</span><br><span class="line">&#125; aeFileEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Time event structure */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">aeTimeEvent</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> id; <span class="comment">/* time event identifier. */</span></span><br><span class="line">    <span class="type">long</span> when_sec; <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">long</span> when_ms; <span class="comment">/* milliseconds */</span></span><br><span class="line">    aeTimeProc *timeProc;</span><br><span class="line">    aeEventFinalizerProc *finalizerProc;</span><br><span class="line">    <span class="type">void</span> *clientData;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">aeTimeEvent</span> *next;</span><br><span class="line">&#125; aeTimeEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A fired event */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">aeFiredEvent</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line">&#125; aeFiredEvent;</span><br></pre></td></tr></table></figure>

<p>eventloop的核心是aeProcessEvents函数，执行逻辑如下</p>
<ol>
<li>计算最近的定时事件需要等待的时间t。shortest &#x3D; aeSearchNearestTimer(eventLoop) </li>
<li>numevents &#x3D; aeApiPoll(eventLoop, tvp); 执行epoll_wait，超时时间为上述需要等待的时间t</li>
<li>遍历eventLoop-&gt;fired[j].fd获得触发的事件，根据事件读写类型执行处理函数；fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);  fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</li>
<li>处理定时事件processTimeEvents</li>
</ol>
<h4 id="事件处理函数"><a href="#事件处理函数" class="headerlink" title="事件处理函数"></a>事件处理函数</h4><ol>
<li>acceptTcpHandler<br>用来接受和建立连接，acceptTcpHandler会创建client</li>
</ol>
<p>创建Client时，同时创建对该client的fileevent 可读事件，处理函数是readQueryFromClient。linux的accept() 会从监听 socket 的已完成连接队列中取出一个客户端连接，并为其创建一个 新的 socket。该fd标志了client和filevent可读事件。</p>
<ol start="2">
<li>readQueryFromClient</li>
</ol>
<p><code>void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask)</code></p>
<ol>
<li>生成c-&gt;querybuf &#x3D; sdsMakeRoomFor(c-&gt;querybuf, readlen);</li>
<li>nread &#x3D; read(fd, c-&gt;querybuf+qblen, readlen);</li>
<li>调用processInputBuffer(c);函数</li>
</ol>
<p>processInputBuffer 内部是processCommand，主要执行两步</p>
<ol>
<li>获取命令<code>c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[0]-&gt;ptr);</code></li>
<li>处理命令call(c,CMD_CALL_FULL);</li>
</ol>
<h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>redis 4.0版本监听网络请求，处理请求和命令都由一个主线程完成。</p>
<ol>
<li>好处是redis 主IO路径无须加锁保护。</li>
<li>缺点是redis 不可处理耗时长的命令，这在使用自定义命令和复杂lua脚本里需要注意。此外redis 无法利用多核cpu，这对部署机器的cpu单核能力有要求。</li>
</ol>
<p>redis 使用多线程的地方很少，只有adb, aof后台执行，和lazyfree等操作。</p>
<h4 id="fork-子进程"><a href="#fork-子进程" class="headerlink" title="fork 子进程"></a>fork 子进程</h4><p>fork() 创建子进程，对于父进程：fork() 返回新创建子进程的进程ID（PID）。这是一个正整数。<br>对于子进程：fork() 返回0。<br>如果 fork() 失败：则返回-1，并设置 errno 以指示错误原因。</p>
<p>fork使用到的地方</p>
<ol>
<li>后台创建子进程执行rdb备份任务</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rdbSaveBackground</span><span class="params">(<span class="type">char</span> *filename, rdbSaveInfo *rsi)</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> childpid;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span> || server.rdb_child_pid != <span class="number">-1</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    server.dirty_before_bgsave = server.dirty;</span><br><span class="line">    server.lastbgsave_try = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">openChildInfoPipe</span>();</span><br><span class="line"></span><br><span class="line">    start = <span class="built_in">ustime</span>();</span><br><span class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line">        <span class="built_in">closeListeningSockets</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">redisSetProcTitle</span>(<span class="string">&quot;redis-rdb-bgsave&quot;</span>);</span><br><span class="line">        retval = <span class="built_in">rdbSave</span>(filename,rsi);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>aof 创建子进程执行rewriteAppendOnlyFile</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> childpid;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span> || server.rdb_child_pid != <span class="number">-1</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">aofCreatePipes</span>() != C_OK) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="built_in">openChildInfoPipe</span>();</span><br><span class="line">    start = <span class="built_in">ustime</span>();</span><br><span class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line">        <span class="built_in">closeListeningSockets</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">redisSetProcTitle</span>(<span class="string">&quot;redis-aof-rewrite&quot;</span>);</span><br><span class="line">        <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">&quot;temp-rewriteaof-bg-%d.aof&quot;</span>, (<span class="type">int</span>) <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">rewriteAppendOnlyFile</span>(tmpfile) == C_OK) &#123;</span><br><span class="line">            <span class="type">size_t</span> private_dirty = <span class="built_in">zmalloc_get_private_dirty</span>(<span class="number">-1</span>);</span><br><span class="line">            ....</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        server.stat_fork_time = <span class="built_in">ustime</span>()-start;</span><br><span class="line">        server.stat_fork_rate = (<span class="type">double</span>) <span class="built_in">zmalloc_used_memory</span>() * <span class="number">1000000</span> / server.stat_fork_time / (<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>); <span class="comment">/* GB per second. */</span></span><br><span class="line">        <span class="built_in">latencyAddSampleIfNeeded</span>(<span class="string">&quot;fork&quot;</span>,server.stat_fork_time/<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>server如果设置了daemonize，则当前进程退出，创建子进程执行后续任务<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">daemonize</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() != <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* parent exits */</span></span><br><span class="line">    <span class="built_in">setsid</span>(); <span class="comment">/* create a new session */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Every output goes to /dev/null. If Redis is daemonized but</span></span><br><span class="line"><span class="comment">     * the &#x27;logfile&#x27; is set to &#x27;stdout&#x27; in the configuration file</span></span><br><span class="line"><span class="comment">     * it will not log at all. */</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR, <span class="number">0</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">dup2</span>(fd, STDIN_FILENO);</span><br><span class="line">        <span class="built_in">dup2</span>(fd, STDOUT_FILENO);</span><br><span class="line">        <span class="built_in">dup2</span>(fd, STDERR_FILENO);</span><br><span class="line">        <span class="keyword">if</span> (fd &gt; STDERR_FILENO) <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>sentinelRunPendingScripts，子进程执行脚本，父进程返回<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Run pending scripts if we are not already at max number of running</span></span><br><span class="line"><span class="comment"> * scripts. */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sentinelRunPendingScripts</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listIter li;</span><br><span class="line">    <span class="type">mstime_t</span> now = <span class="built_in">mstime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find jobs that are not running and run them, from the top to the</span></span><br><span class="line"><span class="comment">     * tail of the queue, so we run older jobs first. */</span></span><br><span class="line">    <span class="built_in">listRewind</span>(sentinel.scripts_queue,&amp;li);</span><br><span class="line">    <span class="keyword">while</span> (sentinel.running_scripts &lt; SENTINEL_SCRIPT_MAX_RUNNING &amp;&amp;</span><br><span class="line">           (ln = <span class="built_in">listNext</span>(&amp;li)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sentinelScriptJob *sj = ln-&gt;value;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">        pid = fork();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">/* Parent (fork error).</span></span><br><span class="line"><span class="comment">             * We report fork errors as signal 99, in order to unify the</span></span><br><span class="line"><span class="comment">             * reporting with other kind of errors. */</span></span><br><span class="line">            <span class="built_in">sentinelEvent</span>(LL_WARNING,<span class="string">&quot;-script-error&quot;</span>,<span class="literal">NULL</span>,</span><br><span class="line">                          <span class="string">&quot;%s %d %d&quot;</span>, sj-&gt;argv[<span class="number">0</span>], <span class="number">99</span>, <span class="number">0</span>);</span><br><span class="line">            sj-&gt;flags &amp;= ~SENTINEL_SCRIPT_RUNNING;</span><br><span class="line">            sj-&gt;pid = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* Child */</span></span><br><span class="line">            <span class="built_in">execve</span>(sj-&gt;argv[<span class="number">0</span>],sj-&gt;argv,environ);</span><br><span class="line">            <span class="comment">/* If we are here an error occurred. */</span></span><br><span class="line">            _exit(<span class="number">2</span>); <span class="comment">/* Don&#x27;t retry execution. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sentinel.running_scripts++;</span><br><span class="line">            sj-&gt;pid = pid;</span><br><span class="line">            <span class="built_in">sentinelEvent</span>(LL_DEBUG,<span class="string">&quot;+script-child&quot;</span>,<span class="literal">NULL</span>,<span class="string">&quot;%ld&quot;</span>,(<span class="type">long</span>)pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="pthread-create-多线程"><a href="#pthread-create-多线程" class="headerlink" title="pthread_create 多线程"></a>pthread_create 多线程</h4><p>pthread_create创建线程被bio封装</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initialize the background system, spawning the thread. */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bioInit</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">size_t</span> stacksize;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialization of state vars and objects */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BIO_NUM_OPS; j++) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;bio_mutex[j],<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_cond_init</span>(&amp;bio_newjob_cond[j],<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_cond_init</span>(&amp;bio_step_cond[j],<span class="literal">NULL</span>);</span><br><span class="line">        bio_jobs[j] = <span class="built_in">listCreate</span>();</span><br><span class="line">        bio_pending[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the stack size as by default it may be small in some system */</span></span><br><span class="line">    <span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line">    <span class="built_in">pthread_attr_getstacksize</span>(&amp;attr,&amp;stacksize);</span><br><span class="line">    <span class="keyword">if</span> (!stacksize) stacksize = <span class="number">1</span>; <span class="comment">/* The world is full of Solaris Fixes */</span></span><br><span class="line">    <span class="keyword">while</span> (stacksize &lt; REDIS_THREAD_STACK_SIZE) stacksize *= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">pthread_attr_setstacksize</span>(&amp;attr, stacksize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ready to spawn our threads. We use the single argument the thread</span></span><br><span class="line"><span class="comment">     * function accepts in order to pass the job ID the thread is</span></span><br><span class="line"><span class="comment">     * responsible of. */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BIO_NUM_OPS; j++) &#123;</span><br><span class="line">        <span class="type">void</span> *arg = (<span class="type">void</span>*)(<span class="type">unsigned</span> <span class="type">long</span>) j;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thread,&amp;attr,bioProcessBackgroundJobs,arg) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">serverLog</span>(LL_WARNING,<span class="string">&quot;Fatal: Can&#x27;t initialize Background Jobs.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        bio_threads[j] = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bioCreateBackgroundJob</span><span class="params">(<span class="type">int</span> type, <span class="type">void</span> *arg1, <span class="type">void</span> *arg2, <span class="type">void</span> *arg3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">bio_job</span> *job = <span class="built_in">zmalloc</span>(<span class="built_in">sizeof</span>(*job));</span><br><span class="line"></span><br><span class="line">    job-&gt;time = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    job-&gt;arg1 = arg1;</span><br><span class="line">    job-&gt;arg2 = arg2;</span><br><span class="line">    job-&gt;arg3 = arg3;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;bio_mutex[type]);</span><br><span class="line">    <span class="built_in">listAddNodeTail</span>(bio_jobs[type],job);</span><br><span class="line">    bio_pending[type]++;</span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;bio_newjob_cond[type]);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;bio_mutex[type]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bioCreateBackgroundJob 使用的地方</p>
<ol>
<li>aof后台fsync</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">aof_background_fsync</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">bioCreateBackgroundJob</span>(BIO_AOF_FSYNC,(<span class="type">void</span>*)(<span class="type">long</span>)fd,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>lazyfree<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Empty a Redis DB asynchronously. What the function does actually is to</span></span><br><span class="line"><span class="comment"> * create a new empty set of hash tables and scheduling the old ones for</span></span><br><span class="line"><span class="comment"> * lazy freeing. */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">emptyDbAsync</span><span class="params">(redisDb *db)</span> </span>&#123;</span><br><span class="line">    dict *oldht1 = db-&gt;dict, *oldht2 = db-&gt;expires;</span><br><span class="line">    db-&gt;dict = <span class="built_in">dictCreate</span>(&amp;dbDictType,<span class="literal">NULL</span>);</span><br><span class="line">    db-&gt;expires = <span class="built_in">dictCreate</span>(&amp;keyptrDictType,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">atomicIncr</span>(lazyfree_objects,<span class="built_in">dictSize</span>(oldht1));</span><br><span class="line">    <span class="built_in">bioCreateBackgroundJob</span>(BIO_LAZY_FREE,<span class="literal">NULL</span>,oldht1,oldht2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="rdb持久化"><a href="#rdb持久化" class="headerlink" title="rdb持久化"></a>rdb持久化</h3><p>rdb, replicate db</p>
<p>暂只看rdbsave和rdbload</p>
<h4 id="rdbsave"><a href="#rdbsave" class="headerlink" title="rdbsave"></a>rdbsave</h4><p><code>int rdbSave(char *filename, rdbSaveInfo *rsi)</code></p>
<ol>
<li>snprintf(tmpfile,256,”temp-%d.rdb”, (int) getpid()); fp &#x3D; fopen(tmpfile,”w”);</li>
<li>rioInitWithFile(&amp;rdb,fp);</li>
<li>rdbSaveRio(&amp;rdb,&amp;error,RDB_SAVE_NONE,rsi)</li>
<li>fflush(fp) &#x3D;&#x3D; EOF fsync(fileno(fp)  fclose(fp) &#x3D;&#x3D; EOF</li>
<li>rename(tmpfile,filename)</li>
</ol>
<p>fflush是flush文件流到page cache，fsync是刷page cache到文件落盘</p>
<p>其中的rdbSaveRio 函数，rdbSaveRio(&amp;rdb,&amp;error,RDB_SAVE_NONE,rsi)</p>
<ol>
<li>写入”REDIS%04d”,RDB_VERSION</li>
<li>rdbSaveInfoAuxFields(rdb,flags,rsi)</li>
<li>遍历server.dbnum<ol>
<li>对每个db，redisDb。每个db内部其实是db-&gt;dict，</li>
<li>写入一些元数据，包括rdbSaveType(rdb,RDB_OPCODE_SELECTDB)</li>
<li>rdbSaveLen(rdb,j)</li>
<li>rdbSaveType(rdb,RDB_OPCODE_RESIZEDB) </li>
<li>rdbSaveLen(rdb,db_size)</li>
<li>rdbSaveLen(rdb,expires_size)</li>
<li>遍历db-&gt;dict，拿到sds keystr &#x3D; dictGetKey(de);，robj key, <code>*o = dictGetVal(de);</code>，执行rdbSaveKeyValuePair(rdb,&amp;key,o,expire,now)</li>
</ol>
</li>
</ol>
<h4 id="rdbsave-的调用"><a href="#rdbsave-的调用" class="headerlink" title="rdbsave 的调用"></a>rdbsave 的调用</h4><p>rdbSaveBackground执行调用childpid &#x3D; fork() 启动进程，在子进程里执行rdbSave(filename,rsi);</p>
<p>fork()的子进程初始利用写时复制共享父进程内存。写时复制情况下，父子进程修改共享内存页时，均会复制共享页到新的物理内存页。</p>
<p>写时复制保证子进程的内存始终和父进程调用fork()时的状态一致，就是说，<strong>子进程rdbSave 的dict 内容和父进程fork()时的一致，且不会因后续父进程对dict的写入而改变。。</strong>以上由操作系统保证。太6了</p>
<p>如果父进程大量修改数据（触发大量 COW），可能导致内存和 CPU 压力增大，但这属于资源问题，影响可控</p>
<p>rdbsave的定时和手动调度</p>
<p>后台执行时会设置执行的child_pid，从而判断是否后台正在执行备份<br>server.rdb_child_pid !&#x3D; -1 || server.aof_child_pid !&#x3D; -1</p>
<p>replicationCron -&gt; startBgsaveForReplication<br>replicationCron 一秒钟执行一次</p>
<p>syncCommand-&gt; startBgsaveForReplication</p>
<h4 id="rdbLoadRio"><a href="#rdbLoadRio" class="headerlink" title="rdbLoadRio"></a>rdbLoadRio</h4><p><code>int rdbLoadRio(rio *rdb, rdbSaveInfo *rsi)</code></p>
<p>从文件里读数据</p>
<ol>
<li>首先读到”REDIS\0”</li>
<li>然后是一字节版本，rdbver &#x3D; atoi(buf+5);。算法<br>从第一个非空白字符开始，取一个可选的初始加号或者减号，后跟尽可能多的十进制数字，并将它们转换为一个<code>int</code>类型的数值。</li>
<li>循环执行<ol>
<li>type &#x3D; rdbLoadType(rdb)</li>
<li>根据type 类型执行以下操作，type的类型可以是RDB_OPCODE_EOF表示结束</li>
<li>解析出key &#x3D; rdbLoadStringObject(rdb) 和val &#x3D; rdbLoadObject(type,rdb)</li>
<li>将kv写入到hash table dbAdd(db,key,val);</li>
</ol>
</li>
</ol>
<p>显然rdb会将某时刻hashtable的所有kv写入到rdb文件中。</p>
<h3 id="aof持久化"><a href="#aof持久化" class="headerlink" title="aof持久化"></a>aof持久化</h3><p>aof, append only file</p>
<p>rdb关心的是复制db的dict 的key, value，通过写kv数据恢复数据库状态。aof关心的是复制db的增删改操作，通过replay操作恢复数据库状态。</p>
<h4 id="aof-rewrite"><a href="#aof-rewrite" class="headerlink" title="aof rewrite"></a>aof rewrite</h4><p>aof 可以实现全量复制和增量复制。</p>
<p>aof 的rewrite 是将当前状态的dict的key value，全部保存为<code>set key value</code>操作，从而实现全量复制。</p>
<p>aof 增量复制通过父进程将写操作发给子进程实现。进程通信的方式是使用管道。创建管道会返回两个fd，分别给父子进程。进程利用fd和fileevent事件可以监听管道，子进程监听可写事件，父进程监听可读事件。</p>
<p>当执行aof时，父进程接收到写请求，在处理请求之外，会把写操作写入到管道。当执行rdb或aof时，redis会把执行的子进程id记录，通过判断子进程id存在可以得到是否正在执行rdb&#x2F;aof。</p>
<p>Redis 4.0 引入了 混合持久化（通过配置 aof-use-rdb-preamble yes 启用）：重写后的 AOF 文件会以 RDB 格式开头，后续追加增量 AOF 命令。<br>此时，AOF 重写过程会先生成 RDB 数据，再追加新写入的 AOF 命令。</p>
<p>子进程执行逻辑</p>
<ol>
<li>如果设置了server.aof_use_rdb_preamble，处理rdb；否则，执行rewriteAppendOnlyFileRio，遍历dict，将当前dict存放的key, value转换成SET key value 写入到aof文件</li>
<li>循环执行aofReadDiffFromParent(); 读rewrite期间父进程的写入，到server.aof_child_diff</li>
<li>执行rioWrite(&amp;aof,server.aof_child_diff,sdslen(server.aof_child_diff)，写入到rio</li>
</ol>
<p>aofReadDiffFromParent 从管道读数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function is called by the child rewriting the AOF file to read</span></span><br><span class="line"><span class="comment"> * the difference accumulated from the parent into a buffer, that is</span></span><br><span class="line"><span class="comment"> * concatenated at the end of the rewrite. */</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">aofReadDiffFromParent</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">65536</span>]; <span class="comment">/* Default pipe buffer size on most Linux systems. */</span></span><br><span class="line">    <span class="type">ssize_t</span> nread, total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((nread =</span><br><span class="line">            <span class="built_in">read</span>(server.aof_pipe_read_data_from_parent,buf,<span class="built_in">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        server.aof_child_diff = <span class="built_in">sdscatlen</span>(server.aof_child_diff,buf,nread);</span><br><span class="line">        total += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rio对应一个文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rioInitWithFile</span><span class="params">(rio *r, FILE *fp)</span> </span>&#123;</span><br><span class="line">    *r = rioFileIO;</span><br><span class="line">    r-&gt;io.file.fp = fp;</span><br><span class="line">    r-&gt;io.file.buffered = <span class="number">0</span>;</span><br><span class="line">    r-&gt;io.file.autosync = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> rio rioFileIO = &#123;</span><br><span class="line">    rioFileRead,</span><br><span class="line">    rioFileWrite,</span><br><span class="line">    rioFileTell,</span><br><span class="line">    rioFileFlush,</span><br><span class="line">    <span class="literal">NULL</span>,           <span class="comment">/* update_checksum */</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/* current checksum */</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/* bytes read or written */</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/* read/write chunk size */</span></span><br><span class="line">    &#123; &#123; <span class="literal">NULL</span>, <span class="number">0</span> &#125; &#125; <span class="comment">/* union for io-specific vars */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>主进程执行逻辑</p>
<ol>
<li>格式化数据到Buf，<code>server.expireCommand,argv[1], exarg</code></li>
<li>如果开启了aof，执行server.aof_buf &#x3D; sdscatlen(server.aof_buf,buf,sdslen(buf));</li>
<li>如果server.aof_child_pid !&#x3D; -1，表示有rewrite进程，执行aofRewriteBufferAppend((unsigned char*)buf,sdslen(buf));</li>
</ol>
<h3 id="pub-sub"><a href="#pub-sub" class="headerlink" title="pub-sub"></a>pub-sub</h3><p>pub-sub 是常用的网络服务</p>
<p>订阅-发布和关注某个up主，收到他们更新的消息，是类似的</p>
<h4 id="SubscribeChannel"><a href="#SubscribeChannel" class="headerlink" title="SubscribeChannel"></a>SubscribeChannel</h4><p>Subscribe a client to a channel. Returns 1 if the operation succeeded</p>
<p>c-&gt;pubsub_channels 是一个dict。注册的结果，key是channel，value是一个client list</p>
<h4 id="pubsubPublishMessage"><a href="#pubsubPublishMessage" class="headerlink" title="pubsubPublishMessage"></a>pubsubPublishMessage</h4><ol>
<li>利用dictFind(server.pubsub_channels,channel) 找到channel(key)，返回client list（value）</li>
<li>遍历list，对每个client，执行<code>addReply(c,shared.mbulkhdr[3]);</code>，<code>addReply(c,shared.messagebulk);</code> addReplyBulk(c,channel); addReplyBulk(c,message);</li>
</ol>
<p>addReply</p>
<ol>
<li>传入<code>robj *obj</code></li>
<li>addReplyToBuffer(c,obj-&gt;ptr,sdslen(obj-&gt;ptr)</li>
</ol>
<p>subscribeCommand</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">subscribeCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">        <span class="built_in">pubsubSubscribeChannel</span>(c,c-&gt;argv[j]);</span><br><span class="line">    c-&gt;flags |= CLIENT_PUBSUB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>publish command</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">publishCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> receivers = <span class="built_in">pubsubPublishMessage</span>(c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled)</span><br><span class="line">        <span class="built_in">clusterPropagatePublish</span>(c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        forceCommandPropagation(c,PROPAGATE_REPL);</span><br><span class="line">    <span class="built_in">addReplyLongLong</span>(c,receivers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/storage/" rel="tag">storage</a></li></ul></div><div class="post-nav"><a class="pre" href="/2025/02/15/leveldb(2)%E2%80%94%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/">leveldb(2)—线程模型和并发控制</a><a class="next" href="/2025/02/10/redis(1)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">redis(1)——数据结构</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://larrystd.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>To be a better man.</p><a class="info-icon" href="https://twitter.com/username" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:admin@domain.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/application/">application</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/compute/">compute</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hello/">hello</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/language/">language</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/storage/">storage</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/hello/" style="font-size: 15px;">hello</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/brpc/" style="font-size: 15px;">brpc</a> <a href="/tags/storage/" style="font-size: 15px;">storage</a> <a href="/tags/leveldb/" style="font-size: 15px;">leveldb</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/application/" style="font-size: 15px;">application</a> <a href="/tags/base/" style="font-size: 15px;">base</a> <a href="/tags/language/" style="font-size: 15px;">language</a> <a href="/tags/cpp/" style="font-size: 15px;">cpp</a> <a href="/tags/coroutine/" style="font-size: 15px;">coroutine</a> <a href="/tags/compute/" style="font-size: 15px;">compute</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/07/06/brpc(1)%E2%80%94bthread%E5%92%8Cbrpc/">brpc(1)—bthread和brpc</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/03/%E8%AE%A1%E7%AE%97(2)%E2%80%94GPU%E8%AE%A1%E7%AE%97%E5%92%8C%E5%A4%A7%E6%A8%A1%E5%9E%8B/">计算(2)——GPU计算和大模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/27/%E8%AE%A1%E7%AE%97(1)%E2%80%94CPU%E8%AE%A1%E7%AE%97%E5%92%8C%E5%A4%A7%E6%95%B0%E6%8D%AE/">计算(1)——CPU计算和大数据</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94C++%E5%8F%B3%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/">编程语言——C++右值和右值引用</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/20/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94C++%E5%8D%8F%E7%A8%8B%E5%92%8C%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/">编程语言——C++协程和高性能编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/07/%E5%AD%98%E5%82%A8%E2%80%94%E8%B0%88%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">存储——谈存储文件系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/15/leveldb(2)%E2%80%94%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/">leveldb(2)—线程模型和并发控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/12/redis(2)%E2%80%94%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/">redis(2)——网络处理和持久化</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/10/redis(1)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">redis(1)——数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/31/leveldb(1)%E2%80%94%E6%A6%82%E8%A7%88/">leveldb(1)—概览</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2026 <a href="/." rel="nofollow">Infinity Code.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>