<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>brpc(1)—bthread和brpc | Infinity Code</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">brpc(1)—bthread和brpc</h1><a id="logo" href="/.">Infinity Code</a><p class="description">Simplicity is the soul of efficiency.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">brpc(1)—bthread和brpc</h1><div class="post-meta">创建: 2025-07-06<span> | 更新: 2025-07-06</span><span> | </span><category class="name"></category><span class="category"><a href="/categories/network/">network</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 本文共 3.9k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 阅读需要 20</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#bthread"><span class="toc-number">1.</span> <span class="toc-text">bthread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TaskGroup"><span class="toc-number">1.1.</span> <span class="toc-text">TaskGroup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TaskControl"><span class="toc-number">1.2.</span> <span class="toc-text">TaskControl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bthread%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">bthread协程的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#brpc"><span class="toc-number">2.</span> <span class="toc-text">brpc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#channel-%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">2.1.</span> <span class="toc-text">channel 和客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#channel-Init-%E5%88%9B%E5%BB%BAshannel%EF%BC%8C%E5%8F%91%E8%B5%B7%E9%93%BE%E6%8E%A5"><span class="toc-number">2.1.1.</span> <span class="toc-text">channel::Init 创建shannel，发起链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stub-method-%E9%80%9A%E8%BF%87channel-%E5%90%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82"><span class="toc-number">2.1.2.</span> <span class="toc-text">stub.method 通过channel 向服务端发送请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Acceptor-%E5%92%8CEventDispatcher"><span class="toc-number">2.2.</span> <span class="toc-text">Acceptor 和EventDispatcher</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Acceptor-%E6%8E%A5%E5%8F%97%E9%93%BE%E6%8E%A5"><span class="toc-number">2.2.1.</span> <span class="toc-text">Acceptor 接受链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EventDispatcher"><span class="toc-number">2.2.2.</span> <span class="toc-text">EventDispatcher</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#protocol-service"><span class="toc-number">2.3.</span> <span class="toc-text">protocol service</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TODO"><span class="toc-number">3.</span> <span class="toc-text">TODO</span></a></li></ol></div></div><div class="post-content"><p>brpc 是百度开源的一个网络框架, 它几乎是开源的C++高性能网络框架的唯一选择。它是国内C++最优秀的开源作品之一，我相信国内大厂内部的闭源RPC网络库也参考过它</p>
<p>brpc的重要特性</p>
<ol>
<li>bthread，这是几乎唯一的工业级开源协程库（虽然作者不认为它是协程）,在开源界几乎没有替代品</li>
<li>标准的rpc框架和接口, 四参数service接口<br>(google::protobuf::RpcController* cntl_base,<br>               const Request* request,<br>               Response* response,<br>               google::protobuf::Closure* done)</li>
</ol>
<p>终结了rpc 各种各样的自定义调用接口问题，以后开发rpc默认使用这种接口，<br>3. 完备的可观测性；logging和trace, span; bvar 支持的监控指标</p>
<span id="more"></span>

<h2 id="bthread"><a href="#bthread" class="headerlink" title="bthread"></a>bthread</h2><p>bthread 是一种有栈协程, 使用用户栈来代表协程对象。它使用队列管理协程切换（类似goroutine），例如加协程锁时，第一个bthread进入执行，后续bthread进入等待队列，当第一个bthread执行完后，唤醒等待队列的一个bthread进入临界区。</p>
<p>bthread主要依靠TaskGroup和TaskControl两个类管理，task其实就是指bthread。</p>
<h3 id="TaskGroup"><a href="#TaskGroup" class="headerlink" title="TaskGroup"></a>TaskGroup</h3><p>taskgroup 是 Thread-local group of tasks. 代表一个pthread 上的bthread协程。taskgroup负责执行一个bthread，切换当前线程的bthread等。主要方法有：</p>
<ol>
<li><p>start_foreground 立即运行bthread</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">start_foreground</span><span class="params">(TaskGroup** pg,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">bthread_t</span>* __restrict tid,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">const</span> <span class="type">bthread_attr_t</span>* __restrict attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">void</span> * (*fn)(<span class="type">void</span>*),</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">void</span>* __restrict arg)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>start_background 将bthread加入到队列_rq，等待调度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> REMOTE&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">start_background</span><span class="params">(<span class="type">bthread_t</span>* __restrict tid,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">bthread_attr_t</span>* __restrict attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">void</span> * (*fn)(<span class="type">void</span>*),</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">void</span>* __restrict arg)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>sched(TaskGroup** pg); 从pg的队列取出一个bthread，执行。如果要切换bthread，也是调用TaskGroup::sched</p>
</li>
</ol>
<p>TaskGroup有两个任务队列， _rq和_remote_rq。_rq 是当前线程的bthread执行流加的任务, _remote_rq是其他线程向当前线程提交的任务。_rq相比_remote_rq， 始终是单线程执行，不需要加锁，性能更高。使用两个队列也是bthread对性能的优化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskGroup::sched</span><span class="params">(TaskGroup** pg)</span> </span>&#123;</span><br><span class="line">    TaskGroup* g = *pg;</span><br><span class="line">    <span class="type">bthread_t</span> next_tid = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Find next task to run, if none, switch to idle thread of the group.</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BTHREAD_FAIR_WSQ</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> popped = g-&gt;_rq.<span class="built_in">pop</span>(&amp;next_tid);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> popped = g-&gt;_rq.<span class="built_in">steal</span>(&amp;next_tid);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (!popped &amp;&amp; !g-&gt;<span class="built_in">steal_task</span>(&amp;next_tid)) &#123;</span><br><span class="line">        <span class="comment">// Jump to main task if there&#x27;s no task to run.</span></span><br><span class="line">        next_tid = g-&gt;_main_tid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sched_to</span>(pg, next_tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">steal_task</span><span class="params">(<span class="type">bthread_t</span>* tid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_remote_rq.<span class="built_in">pop</span>(tid)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BTHREAD_DONT_SAVE_PARKING_STATE</span></span><br><span class="line">        _last_pl_state = _pl-&gt;<span class="built_in">get_state</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> _control-&gt;<span class="built_in">steal_task</span>(tid, &amp;_steal_seed, _steal_offset);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>void sched_to(TaskGroup** pg, bthread_t next_tid); 立即执行指定tid的bthread任务, 也就是协程切换</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">TaskGroup::sched_to</span><span class="params">(TaskGroup** pg, <span class="type">bthread_t</span> next_tid)</span> </span>&#123;</span><br><span class="line">    TaskMeta* next_meta = <span class="built_in">address_meta</span>(next_tid);  <span class="comment">// 直接通过tid 加地址找到taskmeta</span></span><br><span class="line">    <span class="keyword">if</span> (next_meta-&gt;stack == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ContextualStack* stk = <span class="built_in">get_stack</span>(next_meta-&gt;<span class="built_in">stack_type</span>(), task_runner);</span><br><span class="line">        <span class="keyword">if</span> (stk) &#123;</span><br><span class="line">            next_meta-&gt;<span class="built_in">set_stack</span>(stk);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Update now_ns only when wait_task did yield.</span></span><br><span class="line">    <span class="built_in">sched_to</span>(pg, next_meta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskGroup::sched_to</span><span class="params">(TaskGroup** pg, TaskMeta* next_meta)</span> </span>&#123;</span><br><span class="line">    TaskGroup* g = *pg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save errno so that errno is bthread-specific.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> saved_errno = errno;</span><br><span class="line">    <span class="type">void</span>* saved_unique_user_ptr = tls_unique_user_ptr;</span><br><span class="line"></span><br><span class="line">    TaskMeta* <span class="type">const</span> cur_meta = g-&gt;_cur_meta;</span><br><span class="line">    <span class="type">const</span> <span class="type">int64_t</span> now = butil::<span class="built_in">cpuwide_time_ns</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">int64_t</span> elp_ns = now - g-&gt;_last_run_ns;</span><br><span class="line">    g-&gt;_last_run_ns = now;</span><br><span class="line">    cur_meta-&gt;stat.cputime_ns += elp_ns;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Switch to the task</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(next_meta != cur_meta, <span class="number">1</span>)) &#123;</span><br><span class="line">        g-&gt;_cur_meta = next_meta;</span><br><span class="line">        <span class="comment">// Switch tls_bls</span></span><br><span class="line">        cur_meta-&gt;local_storage = tls_bls;</span><br><span class="line">        tls_bls = next_meta-&gt;local_storage;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Logging must be done after switching the local storage, since the logging lib</span></span><br><span class="line">        <span class="comment">// use bthread local storage internally, or will cause memory leak.</span></span><br><span class="line">        <span class="keyword">if</span> ((cur_meta-&gt;attr.flags &amp; BTHREAD_LOG_CONTEXT_SWITCH) ||</span><br><span class="line">            (next_meta-&gt;attr.flags &amp; BTHREAD_LOG_CONTEXT_SWITCH)) &#123;</span><br><span class="line">            <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Switch bthread: &quot;</span> &lt;&lt; cur_meta-&gt;tid &lt;&lt; <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">                      &lt;&lt; next_meta-&gt;tid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur_meta-&gt;stack != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (next_meta-&gt;stack != cur_meta-&gt;stack) &#123;</span><br><span class="line">                <span class="built_in">CheckBthreadScheSafety</span>();</span><br><span class="line">                <span class="built_in">jump_stack</span>(cur_meta-&gt;stack, next_meta-&gt;stack);</span><br><span class="line">                <span class="comment">// probably went to another group, need to assign g again.</span></span><br><span class="line">                g = <span class="built_in">BAIDU_GET_VOLATILE_THREAD_LOCAL</span>(tls_task_group);</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>int usleep(TaskGroup** pg, uint64_t timeout_us); void yield(TaskGroup** pg);</li>
</ol>
<p>sleep加一个定时任务，然后切换协程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TaskGroup::usleep</span><span class="params">(TaskGroup** pg, <span class="type">uint64_t</span> timeout_us)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == timeout_us) &#123;</span><br><span class="line">        <span class="built_in">yield</span>(pg);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TaskGroup* g = *pg;</span><br><span class="line">    <span class="comment">// We have to schedule timer after we switched to next bthread otherwise</span></span><br><span class="line">    <span class="comment">// the timer may wake up(jump to) current still-running context.</span></span><br><span class="line">    SleepArgs e = &#123; timeout_us, g-&gt;<span class="built_in">current_tid</span>(), g-&gt;<span class="built_in">current_task</span>(), g &#125;;</span><br><span class="line">    g-&gt;<span class="built_in">set_remained</span>(_add_sleep_event, &amp;e);</span><br><span class="line">    <span class="built_in">sched</span>(pg);</span><br><span class="line">    g = *pg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskGroup::yield</span><span class="params">(TaskGroup** pg)</span> </span>&#123;</span><br><span class="line">    TaskGroup* g = *pg;</span><br><span class="line">    ReadyToRunArgs args = &#123;  g-&gt;_cur_meta, <span class="literal">false</span> &#125;;</span><br><span class="line">    g-&gt;<span class="built_in">set_remained</span>(ready_to_run_in_worker, &amp;args);</span><br><span class="line">    <span class="built_in">sched</span>(pg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="TaskControl"><a href="#TaskControl" class="headerlink" title="TaskControl"></a>TaskControl</h3><p>TaskControl管理Taskgroup</p>
<ol>
<li>创建TaskGroup, 调用_add_group(group, tag)</li>
</ol>
<p>TaskControl使用<code>std::vector&lt;TaggedGroups&gt; _tagged_groups;</code>管理TaskGroup, 增加TaskGroup 使用<code>_tagged_groups[tag][ngroup] = g;</code></p>
<p>taskControl的每个tag对应若干taskgroup</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Create a TaskGroup in this control.</span></span><br><span class="line">    <span class="function">TaskGroup* <span class="title">create_group</span><span class="params">(<span class="type">bthread_tag_t</span> tag)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">TaskGroup* <span class="title">TaskControl::create_group</span><span class="params">(<span class="type">bthread_tag_t</span> tag)</span> </span>&#123;</span><br><span class="line">    TaskGroup* g = <span class="built_in">new</span> (std::nothrow) <span class="built_in">TaskGroup</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == g) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Fail to new TaskGroup&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (g-&gt;<span class="built_in">init</span>(FLAGS_task_group_runqueue_capacity) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Fail to init TaskGroup&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span> g;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_add_group(g, tag) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> g;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> TaskControl::_add_group(TaskGroup* g, <span class="type">bthread_tag_t</span> tag) &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;butil::Mutex&gt; <span class="title">mu</span><span class="params">(_modify_group_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (_stop) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g-&gt;<span class="built_in">set_tag</span>(tag);</span><br><span class="line">    g-&gt;<span class="built_in">set_pl</span>(&amp;_pl[tag][butil::<span class="built_in">fmix64</span>(<span class="built_in">pthread_numeric_id</span>()) % PARKING_LOT_NUM]);</span><br><span class="line">    <span class="type">size_t</span> ngroup = _tagged_ngroup[tag].<span class="built_in">load</span>(butil::memory_order_relaxed);</span><br><span class="line">    <span class="keyword">if</span> (ngroup &lt; (<span class="type">size_t</span>)BTHREAD_MAX_CONCURRENCY) &#123;</span><br><span class="line">        _tagged_groups[tag][ngroup] = g;</span><br><span class="line">        _tagged_ngroup[tag].<span class="built_in">store</span>(ngroup + <span class="number">1</span>, butil::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">    mu.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::array&lt;TaskGroup*, BTHREAD_MAX_CONCURRENCY&gt; TaggedGroups;</span><br><span class="line">std::vector&lt;butil::atomic&lt;<span class="type">size_t</span>&gt;&gt; _tagged_ngroup;</span><br><span class="line">std::vector&lt;TaggedGroups&gt; _tagged_groups;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>bool steal_task(bthread_t* tid, size_t* seed, size_t offset);</code>  TaskControl从当前线程的taskgroup拿一个bthread执行。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TaskControl::steal_task</span><span class="params">(<span class="type">bthread_t</span>* tid, <span class="type">size_t</span>* seed, <span class="type">size_t</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前线程的taskgroup, tls_task_group。</span></span><br><span class="line">    <span class="comment">// tls_task_group 定义为每个线程的内部变量</span></span><br><span class="line">    <span class="keyword">auto</span> tag = tls_task_group-&gt;<span class="built_in">tag</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> ngroup = <span class="built_in">tag_ngroup</span>(tag).<span class="built_in">load</span>(butil::memory_order_acquire<span class="comment">/*1*/</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == ngroup) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Don&#x27;t return inside `for&#x27; iteration since we need to update |seed|</span></span><br><span class="line">    <span class="type">bool</span> stolen = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">size_t</span> s = *seed;</span><br><span class="line">    <span class="keyword">auto</span>&amp; groups = <span class="built_in">tag_group</span>(tag);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ngroup; ++i, s += offset) &#123;</span><br><span class="line">        TaskGroup* g = groups[s % ngroup];</span><br><span class="line">        <span class="comment">// g is possibly NULL because of concurrent _destroy_group</span></span><br><span class="line">        <span class="keyword">if</span> (g) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g-&gt;_rq.<span class="built_in">steal</span>(tid)) &#123;</span><br><span class="line">                stolen = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (g-&gt;_remote_rq.<span class="built_in">pop</span>(tid)) &#123;</span><br><span class="line">                stolen = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *seed = s;</span><br><span class="line">    <span class="keyword">return</span> stolen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>TaskControl::signal_task(int num_task, bthread_tag_t tag)</code> 唤醒tag对应的taskgroup</li>
</ol>
<p>值得注意的是, signal 借助ParkingLot 类， 通过futex_wait_private和futex_wake_private封装了一种信号量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskControl::signal_task</span><span class="params">(<span class="type">int</span> num_task, <span class="type">bthread_tag_t</span> tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num_task &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num_task &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        num_task = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span>&amp; pl = <span class="built_in">tag_pl</span>(tag);</span><br><span class="line">    <span class="type">int</span> start_index = butil::<span class="built_in">fmix64</span>(<span class="built_in">pthread_numeric_id</span>()) % PARKING_LOT_NUM;</span><br><span class="line">    num_task -= pl[start_index].<span class="built_in">signal</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (num_task &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; PARKING_LOT_NUM &amp;&amp; num_task &gt; <span class="number">0</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++start_index &gt;= PARKING_LOT_NUM) &#123;</span><br><span class="line">                start_index = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num_task -= pl[start_index].<span class="built_in">signal</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>TaskGroup* choose_one_group(bthread_tag_t tag);</code> 随机选择一个tag对应的TaskGroup</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TaskGroup* <span class="title">TaskControl::choose_one_group</span><span class="params">(<span class="type">bthread_tag_t</span> tag)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">CHECK</span>(tag &gt;= BTHREAD_TAG_DEFAULT &amp;&amp; tag &lt; FLAGS_task_group_ntags);</span><br><span class="line">    <span class="keyword">auto</span>&amp; groups = <span class="built_in">tag_group</span>(tag);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> ngroup = <span class="built_in">tag_ngroup</span>(tag).<span class="built_in">load</span>(butil::memory_order_acquire);</span><br><span class="line">    <span class="keyword">if</span> (ngroup != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> groups[butil::<span class="built_in">fast_rand_less_than</span>(ngroup)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="literal">false</span>) &lt;&lt; <span class="string">&quot;Impossible: ngroup is 0&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bthread协程的实现原理"><a href="#bthread协程的实现原理" class="headerlink" title="bthread协程的实现原理"></a>bthread协程的实现原理</h3><p>bthread是无栈协程，在创建协程时，会在线程空间创建协程栈，并装载协程函数；运行协程是运行协程栈的函数，类似线程栈的函数入栈出栈；切换协程是保存协程上下文到协程栈；退出协程则会销毁协程栈。</p>
<p>协程实现包括bthread_make_fcontext 创建协程栈、bthread_jump_fcontext 切换协程栈 函数，在context.cpp文件里。</p>
<p>协程实现原理还可以参考：<a target="_blank" rel="noopener" href="https://sf-zhou.github.io/brpc/brpc_01_bthread.html">https://sf-zhou.github.io/brpc/brpc_01_bthread.html</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>bthread 提供了工业级的协程实现，让brpc的函数可以在bthread中执行。bthread提供sleep, yield, join等常用调用。</p>
<p>taskcontrol是管理和调度bthread的类, 还提供steal_task方法从某个线程中拿取bthread，这个接口可以用来优化线程load的均衡。</p>
<p>用户可以通过以下步骤管理协程</p>
<ol>
<li>taskcontrol.init(int nconcurrency) 创建指定数量的线程</li>
<li>taskcontrol.create_group(tag) 创建taskgroup, taskgroup会由固定的一个线程负责， 返回taskgroup</li>
<li>taskgroup.start_background, 在taskgroup启动一个bthread任务并执行, 可以实现《在指定线程创建协程》这个灵活操作</li>
</ol>
<h2 id="brpc"><a href="#brpc" class="headerlink" title="brpc"></a>brpc</h2><p>brpc 是一个网络库，下层接socket、event和网络包，上层接http&#x2F;proto网络协议和service。同时提供name service根据域名获取下游机器组和lb 负载均衡选择下游机器。</p>
<h3 id="channel-和客户端"><a href="#channel-和客户端" class="headerlink" title="channel 和客户端"></a>channel 和客户端</h3><p>channel通道，是网络中相当常见的概念。在brpc中，专门指客户端发起的通道。A Channel represents a communication line to one server or multiple servers which can be used to call that Server’s services. Servers may be running on another machines. Normally, you should not call a Channel directly, but instead construct a stub Service wrapping it.</p>
<p>channel 主要是两个接口</p>
<h4 id="channel-Init-创建shannel，发起链接"><a href="#channel-Init-创建shannel，发起链接" class="headerlink" title="channel::Init 创建shannel，发起链接"></a>channel::Init 创建shannel，发起链接</h4><ol>
<li>int Init(const char* server_addr_and_port, const ChannelOptions* options); 初始化channel，也就是创建发起一个连接</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Channel::Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* server_addr, <span class="type">int</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> ChannelOptions* options)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">GlobalInitializeOrDie</span>();</span><br><span class="line">    butil::EndPoint point;</span><br><span class="line">    <span class="type">const</span> AdaptiveProtocolType&amp; ptype = (options ? options-&gt;protocol : _options.protocol);</span><br><span class="line">    <span class="type">const</span> Protocol* protocol = <span class="built_in">FindProtocol</span>(ptype);</span><br><span class="line">    <span class="keyword">if</span> (protocol == <span class="literal">NULL</span> || !protocol-&gt;<span class="built_in">support_client</span>()) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Channel does not support the protocol&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (protocol-&gt;parse_server_address != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!protocol-&gt;<span class="built_in">parse_server_address</span>(&amp;point, server_addr)) &#123;</span><br><span class="line">            <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Fail to parse address=`&quot;</span> &lt;&lt; server_addr &lt;&lt; <span class="string">&#x27;\&#x27;&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        point.port = port;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">str2endpoint</span>(server_addr, port, &amp;point) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            <span class="built_in">hostname2endpoint</span>(server_addr, port, &amp;point) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">InitSingle</span>(point, server_addr, options, port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Channel::InitSingle 函数</p>
<p>a. GlobalInitializeOrDie();<br>b. InitChannelOptions(options)<br>c. CreateSocketSSLContext(_options, &amp;ssl_ctx)<br>d. SocketMapInsert(SocketMapKey(server_addr_and_port, sig),</p>
<p>显然核心函数在SocketMapInsert, SocketMap::Insert(const SocketMapKey&amp; key, SocketId* id,</p>
<p>a.  <code>SingleConnection* sc = _map.seek(key);</code> 如果链接已经有了，返回<br>b. <code>_options.socket_creator-&gt;CreateSocket(opt, &amp;tmp_id)</code> 创建链接<br>c. <code>_map[key] = new_sc</code>; 链接加入到map</p>
<p>Socket::OnCreated</p>
<p>a. 配置成员变量，如_remote_side，_local_side 等<br>b. DoConnect(options.connect_abstime, NULL, NULL); 创建和发起socket链接</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Socket::DoConnect</span><span class="params">(<span class="type">const</span> timespec* abstime,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">int</span> (*on_connect)(<span class="type">int</span>, <span class="type">int</span>, <span class="type">void</span>*), <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_conn) &#123;</span><br><span class="line">        <span class="keyword">return</span> _conn-&gt;<span class="built_in">Connect</span>(<span class="keyword">this</span>, abstime, on_connect, data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="comment">// 会重新创建socket，然后::connect</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Connect</span>(abstime, on_connect, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="stub-method-通过channel-向服务端发送请求"><a href="#stub-method-通过channel-向服务端发送请求" class="headerlink" title="stub.method 通过channel 向服务端发送请求"></a>stub.method 通过channel 向服务端发送请求</h4><p>客户端调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 初始化channel</span></span><br><span class="line">    brpc::Channel channel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the channel, NULL means using default options.</span></span><br><span class="line">    brpc::ChannelOptions options;</span><br><span class="line">    options.protocol = FLAGS_protocol;</span><br><span class="line">    options.connection_type = FLAGS_connection_type;</span><br><span class="line">    options.timeout_ms = FLAGS_timeout_ms<span class="comment">/*milliseconds*/</span>;</span><br><span class="line">    options.max_retry = FLAGS_max_retry;</span><br><span class="line">    <span class="keyword">if</span> (channel.<span class="built_in">Init</span>(FLAGS_server.<span class="built_in">c_str</span>(), FLAGS_load_balancer.<span class="built_in">c_str</span>(), &amp;options) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Fail to initialize channel&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">example::EchoService_Stub <span class="title">stub</span><span class="params">(&amp;channel)</span></span>;</span><br><span class="line">	</span><br><span class="line">	example::EchoRequest request;</span><br><span class="line">	example::EchoResponse response;</span><br><span class="line">	brpc::Controller cntl;</span><br><span class="line"></span><br><span class="line">	request.<span class="built_in">set_message</span>(g_request);</span><br><span class="line">	cntl.<span class="built_in">set_log_id</span>(log_id++);  <span class="comment">// set by user</span></span><br><span class="line"></span><br><span class="line">	cntl.<span class="built_in">request_attachment</span>().<span class="built_in">append</span>(g_attachment);</span><br><span class="line"></span><br><span class="line">	stub.<span class="built_in">Echo</span>(&amp;cntl, &amp;request, &amp;response, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过channel-&gt;CallMethod 发送数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EchoService_Stub::Echo</span><span class="params">(::PROTOBUF_NAMESPACE_ID::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> ::example::EchoRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ::example::EchoResponse* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ::google::protobuf::Closure* done)</span> </span>&#123;</span><br><span class="line">  channel_-&gt;<span class="built_in">CallMethod</span>(<span class="built_in">descriptor</span>()-&gt;<span class="built_in">method</span>(<span class="number">0</span>),</span><br><span class="line">                       controller, request, response, done);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Channel::CallMethod</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::CallMethod</span><span class="params">(<span class="type">const</span> google::protobuf::MethodDescriptor* method,</span></span></span><br><span class="line"><span class="params"><span class="function">                         google::protobuf::RpcController* controller_base,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> google::protobuf::Message* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                         google::protobuf::Message* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                         google::protobuf::Closure* done)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int64_t</span> start_send_real_us = butil::<span class="built_in">gettimeofday_us</span>();</span><br><span class="line">    Controller* cntl = <span class="built_in">static_cast</span>&lt;Controller*&gt;(controller_base);</span><br><span class="line">    cntl-&gt;<span class="built_in">OnRPCBegin</span>(start_send_real_us);</span><br><span class="line">    ...</span><br><span class="line">    cntl-&gt;_response = response;</span><br><span class="line">    cntl-&gt;_done = done;</span><br><span class="line">    cntl-&gt;_pack_request = _pack_request;</span><br><span class="line">    cntl-&gt;_method = method;</span><br><span class="line">    cntl-&gt;_auth = _options.auth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SingleServer</span>()) &#123;</span><br><span class="line">        cntl-&gt;_single_server_id = _server_id;</span><br><span class="line">        cntl-&gt;_remote_side = _server_address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Share the lb with controller.</span></span><br><span class="line">    cntl-&gt;_lb = _lb;</span><br><span class="line"></span><br><span class="line">    _serialize_request(&amp;cntl-&gt;_request_buf, cntl, request);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cntl-&gt;<span class="built_in">IssueRPC</span>(start_send_real_us);</span><br><span class="line">    <span class="keyword">if</span> (done == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// done如果是nullptr，同步等待</span></span><br><span class="line">        <span class="built_in">Join</span>(correlation_id);</span><br><span class="line">        <span class="keyword">if</span> (cntl-&gt;_span) &#123;</span><br><span class="line">            cntl-&gt;<span class="built_in">SubmitSpan</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cntl-&gt;<span class="built_in">OnRPCEnd</span>(butil::<span class="built_in">gettimeofday_us</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cntl-&gt;IssueRPC</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Controller::IssueRPC</span><span class="params">(<span class="type">int64_t</span> start_realtime_us)</span> </span>&#123;</span><br><span class="line">    _current_call.begin_time_us = start_realtime_us;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pick a target server for sending RPC</span></span><br><span class="line">    _current_call.need_feedback = <span class="literal">false</span>;</span><br><span class="line">    _current_call.enable_circuit_breaker = <span class="built_in">has_enabled_circuit_breaker</span>();</span><br><span class="line">    SocketUniquePtr tmp_sock;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SingleServer</span>()) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> rc = Socket::<span class="built_in">Address</span>(_single_server_id, &amp;tmp_sock);</span><br><span class="line">        </span><br><span class="line">        _current_call.peer_id = _single_server_id;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用lb选择下游服务器</span></span><br><span class="line">        LoadBalancer::SelectIn sel_in =</span><br><span class="line">            &#123; start_realtime_us, <span class="literal">true</span>,</span><br><span class="line">              <span class="built_in">has_request_code</span>(), _request_code, _accessed &#125;;</span><br><span class="line">        <span class="function">LoadBalancer::SelectOut <span class="title">sel_out</span><span class="params">(&amp;tmp_sock)</span></span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> rc = _lb-&gt;<span class="built_in">SelectServer</span>(sel_in, &amp;sel_out);</span><br><span class="line">        <span class="keyword">if</span> (rc != <span class="number">0</span>) &#123;</span><br><span class="line">            std::ostringstream os;</span><br><span class="line">            DescribeOptions opt;</span><br><span class="line">            opt.verbose = <span class="literal">false</span>;</span><br><span class="line">            _lb-&gt;<span class="built_in">Describe</span>(os, opt);</span><br><span class="line">            <span class="built_in">SetFailed</span>(rc, <span class="string">&quot;Fail to select server from %s&quot;</span>, os.<span class="built_in">str</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">HandleSendFailed</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _current_call.need_feedback = sel_out.need_feedback;</span><br><span class="line">        _current_call.peer_id = tmp_sock-&gt;<span class="built_in">id</span>();</span><br><span class="line"></span><br><span class="line">        _remote_side = tmp_sock-&gt;<span class="built_in">remote_side</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make request</span></span><br><span class="line">    butil::IOBuf packet;</span><br><span class="line">    SocketMessage* user_packet = <span class="literal">NULL</span>;</span><br><span class="line">    _pack_request(&amp;packet, &amp;user_packet, cid.value, _method, <span class="keyword">this</span>,</span><br><span class="line">                  _request_buf, using_auth);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> PackRequest may accept SocketMessagePtr&lt;&gt;?</span></span><br><span class="line">    SocketMessagePtr&lt;&gt; <span class="built_in">user_packet_guard</span>(user_packet);</span><br><span class="line">    Socket::WriteOptions wopt;</span><br><span class="line">    wopt.id_wait = cid;</span><br><span class="line">    wopt.abstime = pabstime;</span><br><span class="line">    wopt.pipelined_count = _pipelined_count;</span><br><span class="line">    wopt.auth_flags = _auth_flags;</span><br><span class="line">    wopt.ignore_eovercrowded = <span class="built_in">has_flag</span>(FLAGS_IGNORE_EOVERCROWDED);</span><br><span class="line">    wopt.write_in_background = <span class="built_in">write_to_socket_in_background</span>();</span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line">    <span class="type">size_t</span> packet_size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 写数据到socket</span></span><br><span class="line">    <span class="keyword">if</span> (user_packet_guard) &#123;</span><br><span class="line">        <span class="keyword">if</span> (span) &#123;</span><br><span class="line">            packet_size = user_packet_guard-&gt;<span class="built_in">EstimatedByteSize</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        rc = _current_call.sending_sock-&gt;<span class="built_in">Write</span>(user_packet_guard, &amp;wopt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        packet_size = packet.<span class="built_in">size</span>();</span><br><span class="line">        rc = _current_call.sending_sock-&gt;<span class="built_in">Write</span>(&amp;packet, &amp;wopt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (using_auth) &#123;</span><br><span class="line">        _current_call.sending_sock-&gt;<span class="built_in">SetAuthentication</span>(rc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Acceptor-和EventDispatcher"><a href="#Acceptor-和EventDispatcher" class="headerlink" title="Acceptor 和EventDispatcher"></a>Acceptor 和EventDispatcher</h3><p>brpc 的rpc 客户端是通过channel 创建链接和向链接发送请求。类似channel的两个特点, 服务端的基础就是从socket accpet链接和接收数据。完成这个的分别是acceptor和EventDispatcher</p>
<h4 id="Acceptor-接受链接"><a href="#Acceptor-接受链接" class="headerlink" title="Acceptor 接受链接"></a>Acceptor 接受链接</h4><p>Acceptor 是server的成员变量，在server.Start()里调用Acceptor::StartAccept</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Acceptor* _am;</span><br><span class="line">Acceptor* _internal_am;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// listen socket</span></span><br><span class="line">_listen_addr = endpoint;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> port = port_range.min_port; port &lt;= port_range.max_port; ++port) &#123;</span><br><span class="line">    _listen_addr.port = port;</span><br><span class="line">    <span class="function">butil::fd_guard <span class="title">sockfd</span><span class="params">(tcp_listen(_listen_addr))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (_listen_addr.port == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// port=0 makes kernel dynamically select a port from</span></span><br><span class="line">        <span class="comment">// https://en.wikipedia.org/wiki/Ephemeral_port</span></span><br><span class="line">        _listen_addr.port = <span class="built_in">get_port_from_fd</span>(sockfd);    </span><br><span class="line">...</span><br><span class="line"><span class="comment">// Pass ownership of `sockfd&#x27; to `_am&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (_am-&gt;<span class="built_in">StartAccept</span>(sockfd, _options.idle_timeout_sec,</span><br><span class="line">                        _default_ssl_ctx,</span><br><span class="line">                        _options.force_ssl) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Fail to start acceptor&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Acceptor::StartAccept 会把 sockfd 注册可读事件给EventDispatcher，回调函数是OnNewConnections，也就是创建新链接。</p>
<p>显然EventDispatcher 是一个epoll模型的程序, 不停的触发网络事件，并发送给对应注册事件的线程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::OnNewConnections</span><span class="params">(Socket* acception)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> progress = Socket::PROGRESS_INIT;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">OnNewConnectionsUntilEAGAIN</span>(acception);</span><br><span class="line">        <span class="keyword">if</span> (acception-&gt;<span class="built_in">Failed</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (acception-&gt;<span class="built_in">MoreReadEvents</span>(&amp;progress));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::OnNewConnectionsUntilEAGAIN</span><span class="params">(Socket* acception)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_storage</span> in_addr;</span><br><span class="line">        <span class="built_in">bzero</span>(&amp;in_addr, <span class="built_in">sizeof</span>(in_addr));</span><br><span class="line">        <span class="type">socklen_t</span> in_len = <span class="built_in">sizeof</span>(in_addr);</span><br><span class="line">        <span class="function">butil::fd_guard <span class="title">in_fd</span><span class="params">(accept(acception-&gt;fd(), (sockaddr*)&amp;in_addr, &amp;in_len))</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (in_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Acceptor* am = <span class="built_in">dynamic_cast</span>&lt;Acceptor*&gt;(acception-&gt;<span class="built_in">user</span>());</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == am) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        SocketId socket_id;</span><br><span class="line">        SocketOptions options;</span><br><span class="line">        options.keytable_pool = am-&gt;_keytable_pool;</span><br><span class="line">        options.fd = in_fd;</span><br><span class="line">        butil::<span class="built_in">sockaddr2endpoint</span>(&amp;in_addr, in_len, &amp;options.remote_side);</span><br><span class="line">        options.user = acception-&gt;<span class="built_in">user</span>();</span><br><span class="line">        options.force_ssl = am-&gt;_force_ssl;</span><br><span class="line">        options.initial_ssl_ctx = am-&gt;_ssl_ctx;</span><br><span class="line">            options.on_edge_triggered_events = InputMessenger::OnNewMessages;</span><br><span class="line">        &#125;</span><br><span class="line">        options.use_rdma = am-&gt;_use_rdma;</span><br><span class="line">        options.bthread_tag = am-&gt;_bthread_tag;</span><br><span class="line">        <span class="keyword">if</span> (Socket::<span class="built_in">Create</span>(options, &amp;socket_id) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Fail to create Socket&quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SocketUniquePtr sock;</span><br><span class="line">        <span class="keyword">if</span> (Socket::<span class="built_in">AddressFailedAsWell</span>(socket_id, &amp;sock) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">bool</span> is_running = <span class="literal">true</span>;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">BAIDU_SCOPED_LOCK</span>(am-&gt;_map_mutex);</span><br><span class="line">                is_running = (am-&gt;<span class="built_in">status</span>() == RUNNING);</span><br><span class="line">                am-&gt;_socket_map.<span class="built_in">insert</span>(socket_id, <span class="built_in">ConnectStatistics</span>());</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="EventDispatcher"><a href="#EventDispatcher" class="headerlink" title="EventDispatcher"></a>EventDispatcher</h4><p>EventDispatcher 可以配置，一般每个tag tasakgroup配置一个dispather，也就是一个线程一个, 以bthread的形式运行</p>
<p>循环执行epoll_wait -&gt; CallInputEventCallback。 epoll_wait不会阻塞整个线程?  epoll_wait时线程阻塞，但有事件到来继续执行时，该线程会创建多个bthread处理。这里需要详细分析brpc 线程切换的行为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitializeGlobalDispatchers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    g_edisp = <span class="keyword">new</span> EventDispatcher[FLAGS_task_group_ntags * FLAGS_event_dispatcher_num];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; FLAGS_task_group_ntags; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; FLAGS_event_dispatcher_num; ++j) &#123;</span><br><span class="line">            <span class="type">bthread_attr_t</span> attr =</span><br><span class="line">                FLAGS_usercode_in_pthread ? BTHREAD_ATTR_PTHREAD : BTHREAD_ATTR_NORMAL;</span><br><span class="line">            attr.tag = (BTHREAD_TAG_DEFAULT + i) % FLAGS_task_group_ntags;</span><br><span class="line">            <span class="comment">// dispatcher.Start</span></span><br><span class="line">            <span class="built_in">CHECK_EQ</span>(<span class="number">0</span>, g_edisp[i * FLAGS_event_dispatcher_num + j].<span class="built_in">Start</span>(&amp;attr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">EventDispatcher::Start</span><span class="params">(<span class="type">const</span> <span class="type">bthread_attr_t</span>* consumer_thread_attr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_event_dispatcher_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;epoll was not created&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_tid != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Already started this dispatcher(&quot;</span> &lt;&lt; <span class="keyword">this</span> </span><br><span class="line">                   &lt;&lt; <span class="string">&quot;) in bthread=&quot;</span> &lt;&lt; _tid;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="type">int</span> rc = <span class="built_in">bthread_start_background</span>(&amp;_tid, &amp;epoll_thread_attr, RunThis, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Fail to create epoll thread: &quot;</span> &lt;&lt; <span class="built_in">berror</span>(rc);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bthread运行EventDispatcher::Run</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventDispatcher::Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!_stop) &#123;</span><br><span class="line">        epoll_event e[<span class="number">32</span>];</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = <span class="built_in">epoll_wait</span>(_event_dispatcher_fd, e, <span class="built_in">ARRAY_SIZE</span>(e), <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (_stop) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (EINTR == errno) &#123;</span><br><span class="line">                <span class="comment">// We&#x27;ve checked _stop, no wake-up will be missed.</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">PLOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Fail to epoll_wait epfd=&quot;</span> &lt;&lt; _event_dispatcher_fd;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e[i].events &amp; (EPOLLIN | EPOLLERR | EPOLLHUP)</span><br><span class="line">                ) &#123;</span><br><span class="line">                <span class="comment">// We don&#x27;t care about the return value.</span></span><br><span class="line">                <span class="built_in">CallInputEventCallback</span>(e[i].data.u64, e[i].events, _thread_attr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e[i].events &amp; (EPOLLOUT | EPOLLERR | EPOLLHUP)) &#123;</span><br><span class="line">                <span class="comment">// We don&#x27;t care about the return value.</span></span><br><span class="line">                <span class="built_in">CallOutputEventCallback</span>(e[i].data.u64, e[i].events, _thread_attr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="protocol-service"><a href="#protocol-service" class="headerlink" title="protocol service"></a>protocol service</h3><p>上层应用层协议</p>
<p>EventDispatcher的CallOutputEventCallback 首先调用InputMessenger::OnNewMessages 从socket读数据，然后调用InputMessenger::CutInputMessage 确认协议类型。</p>
<p>确定协议类型的办法</p>
<ol>
<li>遍历_handlers</li>
<li>执行<code> _handlers[cur_index].parse(&amp;m-&gt;_read_buf, m, read_eof, _handlers[cur_index].arg);</code></li>
<li>如果成功，找到Index；如果失败，继续下一轮尝试<br>这个一个个的解析尝试的办法，肯定会影响性能把</li>
</ol>
<p>handle类型就是协议类型，确认了协议类型就调用对应的handle解析协议了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Protocol http_protocol = &#123; ParseHttpMessage,</span><br><span class="line">                           SerializeHttpRequest, PackHttpRequest,</span><br><span class="line">                           ProcessHttpRequest, ProcessHttpResponse,</span><br><span class="line">                           VerifyHttpRequest, ParseHttpServerAddress,</span><br><span class="line">                           GetHttpMethodName,</span><br><span class="line">                           CONNECTION_TYPE_POOLED_AND_SHORT,</span><br><span class="line">                           <span class="string">&quot;http&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">RegisterProtocol</span>(PROTOCOL_HTTP, http_protocol) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以protocol rpc service为例，数据从socket读取到msg后， 存放在InputMessageBase</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任何网络包都可以解析成header+data两部分</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BAIDU_CACHELINE_ALIGNMENT</span> MostCommonMessage : <span class="keyword">public</span> InputMessageBase &#123;</span><br><span class="line">    butil::IOBuf meta;</span><br><span class="line">    butil::IOBuf payload;</span><br><span class="line">    PipelinedInfo pi;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">static</span> MostCommonMessage* <span class="title">Get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> butil::<span class="built_in">get_object</span>&lt;MostCommonMessage&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>ParsePbFromIOBuf(&amp;meta, msg-&gt;meta)</p>
</li>
<li><p>将msg-&gt;payload解析到messages-&gt;Request()msg-&gt;payload.cutn(&amp;req_buf, body_without_attachment_size); ParseFromCompressedData(req_buf, messages-&gt;Request(), req_cmp_type)</p>
</li>
<li><p><code>std::unique_ptr&lt;Controller&gt; cntl(new (std::nothrow) Controller);</code> </p>
</li>
<li><p>设置google::protobuf::Closure* done &#x3D; ::brpc::NewCallback&lt;<br>     int64_t, Controller*, RpcPBMessages*,<br>     const Server*, MethodStatus*, int64_t&gt;(&amp;SendRpcResponse,</p>
</li>
<li><p>获得service<br>const Server::MethodProperty* mp &#x3D;<br> server_accessor.FindMethodPropertyByFullName(<br> svc_name, request_meta.method_name());<br> svc &#x3D; mp-&gt;service;<br>拿到service对象</p>
</li>
<li><p>svc-&gt;CallMethod(method, cntl.release(),<br>            messages-&gt;Request(),<br>            messages-&gt;Response(), done);</p>
</li>
</ol>
<p>CallMethod具体的实现在pb.h中</p>
<ol start="7">
<li>执行完service函数, 最后SendRpcResponse(meta.correlation_id(),<br>             cntl.release(), messages,<br>             server, method_status,<br>             msg-&gt;received_us());</li>
</ol>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>brpc的线程模型和切换</p>
<p>brpc的使用和性能资源分析</p>
<p>brpc和butil实现上的优秀、值得借鉴的地方</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>brpc(1)—bthread和brpc</p><p><span>文章作者：</span>Infinity</p><p><span>发布时间：</span>2025-07-06</p><p><span>最后更新：</span>2025-07-06</p><p><span>原始链接：</span><a href="/2025/07/06/brpc(1)—bthread和brpc/">https://larrystd.github.io/2025/07/06/brpc(1)%E2%80%94bthread%E5%92%8Cbrpc/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://larrystd.github.io/2025/07/06/brpc(1)%E2%80%94bthread%E5%92%8Cbrpc/"></i></span></p><p><span>版权声明：</span>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p></div><br><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/brpc/" rel="tag">brpc</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/" rel="tag">network</a></li></ul></div><div class="post-nav"><a class="next" href="/2025/05/03/%E8%AE%A1%E7%AE%97(2)%E2%80%94GPU%E8%AE%A1%E7%AE%97%E5%92%8C%E5%A4%A7%E6%A8%A1%E5%9E%8B/">计算(2)——GPU计算和大模型</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="https://unpkg.com/blueimp-md5/js/md5.js"></script><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: 'Ov23lifIyMlBwTu1yQhW',
  clientSecret: '8a6951b810e0f8c75acc7af48be63e53e7d6b5ad',
  repo: 'blogtalk',
  owner: 'larrystd',
  admin: ['larrystd'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>To be a better man.</p><a class="info-icon" href="venray.kong@outlook.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/larrystd" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/application/">application</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/compute/">compute</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hello/">hello</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/language/">language</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/storage/">storage</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/hello/" style="font-size: 15px;">hello</a> <a href="/tags/storage/" style="font-size: 15px;">storage</a> <a href="/tags/application/" style="font-size: 15px;">application</a> <a href="/tags/base/" style="font-size: 15px;">base</a> <a href="/tags/language/" style="font-size: 15px;">language</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/leveldb/" style="font-size: 15px;">leveldb</a> <a href="/tags/cpp/" style="font-size: 15px;">cpp</a> <a href="/tags/coroutine/" style="font-size: 15px;">coroutine</a> <a href="/tags/compute/" style="font-size: 15px;">compute</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/brpc/" style="font-size: 15px;">brpc</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/07/06/brpc(1)%E2%80%94bthread%E5%92%8Cbrpc/">brpc(1)—bthread和brpc</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/03/%E8%AE%A1%E7%AE%97(2)%E2%80%94GPU%E8%AE%A1%E7%AE%97%E5%92%8C%E5%A4%A7%E6%A8%A1%E5%9E%8B/">计算(2)——GPU计算和大模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/27/%E8%AE%A1%E7%AE%97(1)%E2%80%94CPU%E8%AE%A1%E7%AE%97%E5%92%8C%E5%A4%A7%E6%95%B0%E6%8D%AE/">计算(1)——CPU计算和大数据</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94C++%E5%8F%B3%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/">编程语言——C++右值和右值引用</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/20/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94C++%E5%8D%8F%E7%A8%8B%E5%92%8C%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/">编程语言——C++协程和高性能编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/07/%E5%AD%98%E5%82%A8%E2%80%94%E8%B0%88%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">存储——谈存储文件系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/15/leveldb(2)%E2%80%94%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/">leveldb(2)—线程模型和并发控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/12/redis(2)%E2%80%94%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/">redis(2)——网络处理和持久化</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/10/redis(1)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">redis(1)——数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/31/leveldb(1)%E2%80%94%E6%A6%82%E8%A7%88/">leveldb(1)—概览</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="todo" target="_blank">todo</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Infinity Code.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>