<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Infinity Code</title>
  
  <subtitle>Simplicity is the soul of efficiency.</subtitle>
  <link href="https://larrystd.github.io/atom.xml" rel="self"/>
  
  <link href="https://larrystd.github.io/"/>
  <updated>2025-01-04T01:19:31.264Z</updated>
  <id>https://larrystd.github.io/</id>
  
  <author>
    <name>infinity</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>编程语言(5)—并发编程和函数</title>
    <link href="https://larrystd.github.io/2025/01/04/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(5)%E2%80%94%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/"/>
    <id>https://larrystd.github.io/2025/01/04/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(5)%E2%80%94%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/</id>
    <published>2025-01-03T16:00:00.000Z</published>
    <updated>2025-01-04T01:19:31.264Z</updated>
    
    <content type="html"><![CDATA[<p>并发编程是提高程序处理能力的重要手段，也是编程语言必备的能力。并发的单位是函数，函数作为任务被多个并发计算对象执行。并发执行的函数任务可分为一次性任务和定时任务两种。任务可以由主线程直接分发给多线程，也可以借助线程安全的任务&#x2F;消息队列分发任务。</p><span id="more"></span><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><h4 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h4><p>C语言中的多线程编程一般使用pthread库, pthread在linux系统调用上二次开发，实现了posix标准的线程接口。由于linux不区分线程和进程，线程只是一种共享内存、fd等资源的特殊进程，因此pthread本身也是多进程编程接口。</p><p>pthread支持的接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程创建，线程创建后立即执行，函数用void函数指针类型void *(*start_routine) (void *) 传参</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="comment">// 使当前线程退出，并返回一个状态。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span></span>;</span><br><span class="line"><span class="comment">// 主线程等待子线程执行完毕。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span></span>;</span><br><span class="line"><span class="comment">// 返回当前线程的Id</span></span><br><span class="line"><span class="function"><span class="type">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化互斥锁, attr通常为NULL</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">// 申请互斥锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 释放互斥锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 销毁互斥锁, 互斥锁释放内存前需手动销毁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化条件变量, attr通常为NULL</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">// 阻塞当前线程，等待条件变量通知。线程唤醒后立即尝试申请锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 唤醒一个等待条件变量的线程。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">// 唤醒所有等待条件变量的线程。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">// 销毁条件变量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化线程属性对象</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">// 设置线程PTHREAD_CREATE_DETACHED（分离线程）或 PTHREAD_CREATE_JOINABLE（可等待的线程）。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span></span>;</span><br><span class="line"><span class="comment">// 销毁线程等待对象</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将线程绑定到指定的 CPU 核心上。cpu_set_t 是一个位图类型，每一位表示一个 CPU 核心。可以用CPU_SET(cpu, cpuset)将指定的 CPU 核心（cpu）添加到 cpuset 中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setaffinity_np</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">size_t</span> cpusetsize, <span class="type">const</span> <span class="type">cpu_set_t</span> *cpuset)</span></span>;</span><br><span class="line"><span class="comment">// 获取cpu亲和性</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_getaffinity_np</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">size_t</span> cpusetsize, <span class="type">cpu_set_t</span> *cpuset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程的调度策略和优先级</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setschedparam</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">int</span> policy, <span class="type">const</span> <span class="keyword">struct</span> sched_param *param)</span></span>;</span><br><span class="line"><span class="comment">// 获取线程的调度策略和优先级。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_getschedparam</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">int</span> *policy, <span class="keyword">struct</span> sched_param *param)</span></span>;</span><br></pre></td></tr></table></figure><p>pthread利用锁和条件变量实现生产者消费者模型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 10  <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义缓冲区和相关变量</span></span><br><span class="line"><span class="type">int</span> buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">int</span> in = <span class="number">0</span>;  <span class="comment">// 指向缓冲区的生产者插入位置</span></span><br><span class="line"><span class="type">int</span> out = <span class="number">0</span>; <span class="comment">// 指向缓冲区的消费者取出位置</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;  <span class="comment">// 互斥锁</span></span><br><span class="line"><span class="type">pthread_cond_t</span> empty;   <span class="comment">// 条件变量，表示缓冲区非空</span></span><br><span class="line"><span class="type">pthread_cond_t</span> full;    <span class="comment">// 条件变量，表示缓冲区非满</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">producer</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        item = <span class="built_in">rand</span>() % <span class="number">100</span>;  <span class="comment">// 生成一个随机项</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);  <span class="comment">// 加锁，访问共享缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果缓冲区满了，等待消费者消费</span></span><br><span class="line">        <span class="keyword">while</span> ((in + <span class="number">1</span>) % BUFFER_SIZE == out) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;empty, &amp;mutex);  <span class="comment">// 等待缓冲区有空位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将项放入缓冲区</span></span><br><span class="line">        buffer[in] = item;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Producer produced: %d\n&quot;</span>, item);</span><br><span class="line">        in = (in + <span class="number">1</span>) % BUFFER_SIZE;  <span class="comment">// 更新生产者插入位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒消费者线程</span></span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;full);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);  <span class="comment">// 解锁</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);  <span class="comment">// 模拟生产的时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">consumer</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);  <span class="comment">// 加锁，访问共享缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果缓冲区为空，等待生产者生产</span></span><br><span class="line">        <span class="keyword">while</span> (in == out) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;full, &amp;mutex);  <span class="comment">// 等待缓冲区有数据</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从缓冲区取出项</span></span><br><span class="line">        item = buffer[out];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Consumer consumed: %d\n&quot;</span>, item);</span><br><span class="line">        out = (out + <span class="number">1</span>) % BUFFER_SIZE;  <span class="comment">// 更新消费者取出位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒生产者线程</span></span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;empty);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);  <span class="comment">// 解锁</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);  <span class="comment">// 模拟消费的时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> producer_thread, consumer_thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁和条件变量</span></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;empty, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;full, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建生产者和消费者线程</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;producer_thread, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;consumer_thread, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(producer_thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(consumer_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁和条件变量</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;empty);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;full);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Producer produced: <span class="number">83</span></span><br><span class="line">Consumer consumed: <span class="number">83</span></span><br><span class="line">Producer produced: <span class="number">86</span></span><br><span class="line">Consumer consumed: <span class="number">86</span></span><br><span class="line">Producer produced: <span class="number">77</span></span><br><span class="line">Producer produced: <span class="number">15</span></span><br><span class="line">Consumer consumed: <span class="number">77</span></span><br><span class="line">Producer produced: <span class="number">93</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>线程cpu绑核，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_function</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> mask;</span><br><span class="line">    <span class="type">pthread_t</span> thread = <span class="built_in">pthread_self</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程的 CPU 亲和性</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">pthread_getaffinity_np</span>(thread, <span class="built_in">sizeof</span>(<span class="type">cpu_set_t</span>), &amp;mask);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pthread_getaffinity_np&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出当前线程可以运行的 CPU 核心</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CPU_SETSIZE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CPU_ISSET</span>(i, &amp;mask)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Thread can run on CPU core: %d\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpuset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;thread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程绑定到 CPU 核心 0 和 1</span></span><br><span class="line">    <span class="built_in">CPU_ZERO</span>(&amp;cpuset);</span><br><span class="line">    <span class="built_in">CPU_SET</span>(<span class="number">0</span>, &amp;cpuset);  <span class="comment">// 允许线程在 CPU 核心 0 上运行</span></span><br><span class="line">    <span class="built_in">CPU_SET</span>(<span class="number">1</span>, &amp;cpuset);  <span class="comment">// 允许线程在 CPU 核心 1 上运行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程的 CPU 亲和性</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">pthread_setaffinity_np</span>(thread, <span class="built_in">sizeof</span>(<span class="type">cpu_set_t</span>), &amp;cpuset);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pthread_setaffinity_np&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Thread can run on CPU core: <span class="number">0</span></span><br><span class="line">Thread can run on CPU core: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>线程调度策略, SCHED_FIFO：先来先服务(First-In-First-Out)实时调度, SCHED_RR：轮转调度（Round-Robin）实时调度，SCHED_OTHER默认的操作系统决定调度线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_function</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread running\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sched_param</span> param;</span><br><span class="line">    <span class="type">int</span> policy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;thread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置调度策略为 SCHED_FIFO，并设置优先级为 10</span></span><br><span class="line">    param.sched_priority = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">pthread_setschedparam</span>(thread, SCHED_FIFO, &amp;param);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并输出当前线程的调度策略和优先级</span></span><br><span class="line">    <span class="built_in">pthread_getschedparam</span>(thread, &amp;policy, &amp;param);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread policy: %d, Priority: %d\n&quot;</span>, policy, param.sched_priority);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(thread, <span class="literal">NULL</span>);  <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Thread policy: <span class="number">1</span>, Priority: <span class="number">10</span></span><br><span class="line">Thread running</span><br></pre></td></tr></table></figure><h4 id="原子类型"><a href="#原子类型" class="headerlink" title="原子类型"></a>原子类型</h4><p>c语言可以直接使用gcc提供的内建原子操作函数, 这些函数保证操作的原子性、顺序性和可见性。</p><p>__sync_fetch_and_add：原子地将一个值加到目标变量，并返回加之前的值。</p><p>__sync_fetch_and_sub：原子地从目标变量减去一个值，并返回减之前的值。</p><p>__sync_lock_test_and_set：原子地设置一个值，并返回设置之前的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;  <span class="comment">// 用于计数的共享变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">increment</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        __sync_fetch_and_add(&amp;counter, <span class="number">1</span>);  <span class="comment">// 原子地增加 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 10 个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>, increment, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Counter value: %d\n&quot;</span>, counter);  <span class="comment">// 输出最终值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出10000</span></span><br></pre></td></tr></table></figure><p>__thread, 是gcc提供的线程局部存储，只能用于全局和静态变量</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><h4 id="C-11的并发类"><a href="#C-11的并发类" class="headerlink" title="C++11的并发类"></a>C++11的并发类</h4><p>std::thread线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::thread(Func&amp;&amp; f, Args&amp;&amp;... args)：创建一个线程并开始执行传入的函数 构造函数</span></span><br><span class="line"><span class="comment">// std::thread::join()：等待线程执行完毕。</span></span><br><span class="line"><span class="comment">// std::thread::detach()：将线程与主线程分离。</span></span><br><span class="line"><span class="comment">// std::thread::get_id()， 返回线程id</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_thread_id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::thread::id this_id = std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; this_id &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(print_thread_id)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Main thread ID: <span class="number">140509241898816</span></span><br><span class="line">Thread ID: <span class="number">140509241894656</span></span><br></pre></td></tr></table></figure><p>线程同步</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::mutex::lock()</span></span><br><span class="line"><span class="comment">// std::mutex::unlock()</span></span><br><span class="line"><span class="comment">// std::mutex::try_lock()：尝试锁定互斥量</span></span><br><span class="line"><span class="comment">// std::lock_guard&lt;std::mutex&gt; guard(mtx); 自动加锁和释放锁</span></span><br><span class="line"><span class="comment">// std::unique_lock&lt;std::mutex&gt; lck(mtx); 可手动释放锁，若未手动释放则自动释放锁</span></span><br><span class="line"><span class="comment">// std::condition_variable::wait() 阻塞当前线程</span></span><br><span class="line"><span class="comment">// std::condition_variable::notify_one()：通知一个等待的线程。</span></span><br><span class="line"><span class="comment">// std::condition_variable::notify_all()：通知所有等待的线程。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;              <span class="comment">// 共享缓冲区</span></span><br><span class="line">std::mutex mtx;                      <span class="comment">// 互斥锁，保护缓冲区</span></span><br><span class="line">std::condition_variable cv;          <span class="comment">// 条件变量，通知生产者或消费者</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_BUFFER_SIZE = <span class="number">5</span>;       <span class="comment">// 缓冲区最大大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));  <span class="comment">// 模拟生产耗时</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果缓冲区已满，生产者等待</span></span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>() &lt; MAX_BUFFER_SIZE; &#125;);</span><br><span class="line">        buffer.<span class="built_in">push</span>(i);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">150</span>));  <span class="comment">// 模拟消费耗时</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果缓冲区为空，消费者等待</span></span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> !buffer.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">        <span class="type">int</span> item = buffer.<span class="built_in">front</span>();</span><br><span class="line">        buffer.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建生产者和消费者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">producer_thread</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer_thread</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程执行完毕</span></span><br><span class="line">    producer_thread.<span class="built_in">join</span>();</span><br><span class="line">    consumer_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Produced: <span class="number">0</span></span><br><span class="line">Consumed: <span class="number">0</span></span><br><span class="line">Produced: <span class="number">1</span></span><br><span class="line">Consumed: <span class="number">1</span></span><br><span class="line">Produced: <span class="number">2</span></span><br><span class="line">Produced: <span class="number">3</span></span><br><span class="line">Consumed: <span class="number">2</span></span><br><span class="line">Produced: <span class="number">4</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>异步任务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::async 启动异步任务，返回std::future</span></span><br><span class="line"><span class="comment">// std::future&lt;int&gt; result = std::async(std::launch::async, calculate_square, 5);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// std::future, 调用 get() 方法会阻塞等待异步任务执行完成，返回任务的结果。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// std::promise，用于在线程之间传递数据</span></span><br></pre></td></tr></table></figure><ol><li><p>std::future和std::promise联用，用于线程间传递数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    p.<span class="built_in">set_value</span>(<span class="number">42</span>);  <span class="comment">// 设置 promise 的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 promise 和 future 对象</span></span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f = p.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(set_value, std::ref(p))</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Doing some work in the main thread...\n&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 promise 设置的结果，调用 get() 会阻塞直到线程设置值</span></span><br><span class="line">    <span class="type">int</span> result = f.<span class="built_in">get</span>();  <span class="comment">// 阻塞，直到获取结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The result from promise is: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Doing some work in the main thread...</span><br><span class="line">The result from promise is: <span class="number">42</span></span><br></pre></td></tr></table></figure></li><li><p>std::future和std::async联用，获取异步任务执行完成后的返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate_square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::async 启动异步任务，返回一个 std::future 对象</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(std::launch::async, calculate_square, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Doing other work in main thread...\n&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取异步任务的结果，调用 get() 会阻塞，直到结果计算完成</span></span><br><span class="line">    <span class="type">int</span> square = result.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The square of 5 is: &quot;</span> &lt;&lt; square &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="C-线程局部变量"><a href="#C-线程局部变量" class="headerlink" title="C++线程局部变量"></a>C++线程局部变量</h4><p>全局变量，静态变量，局部变量只要是可能被多线程同时访问的，都是线程共享变量。thread_local 是 C++11 引入的关键字, 可以使用thread_local声明线程局部变量。相比__thread, thread_local可用于局部变量、全局变量、类成员变量等</p><p>线程局部变量没有数据竞争，其他线程对变量的修改也不会影响当前线程的变量值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> thread_local_var = <span class="number">0</span>;  <span class="comment">// 声明线程局部变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_function</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    thread_local_var++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld: thread_local_var = %d\n&quot;</span>, (<span class="type">long</span>)arg, thread_local_var);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建多个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>, thread_function, (<span class="type">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Thread <span class="number">0</span>: thread_local_var = <span class="number">1</span></span><br><span class="line">Thread <span class="number">1</span>: thread_local_var = <span class="number">1</span></span><br><span class="line">Thread <span class="number">2</span>: thread_local_var = <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="C-11-的原子类"><a href="#C-11-的原子类" class="headerlink" title="C++11 的原子类"></a>C++11 的原子类</h4><p>std::atomic提供了线程安全的原子操作。std::atomic 是一个模板类，支持不同的数据类型（如整数、指针）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load() 读取原子变量的值。</span></span><br><span class="line"><span class="comment">// store(x) 写入值到原子变量</span></span><br><span class="line"><span class="comment">// fetch_add(x) 和 fetch_sub(x) 原子加减法操作</span></span><br><span class="line"><span class="comment">// exchange(x) 将原子对象的值替换为给定值，并返回原始值。</span></span><br><span class="line"><span class="comment">// compare_exchange_weak(expected, desired) 和 compare_exchange_strong(expected, desired) 执行原子比较并交换（CAS，Compare and Swap）操作。expected是当前期望的值，desired是期望修改后的值。返回true表示更新成功，false表示未更新</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> expected = counter.<span class="built_in">load</span>();</span><br><span class="line">        <span class="keyword">while</span> (!counter.<span class="built_in">compare_exchange_strong</span>(expected, expected + <span class="number">1</span>)) &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">yield</span>();  <span class="comment">// 如果失败，主动让出 CPU</span></span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; incremented counter to &quot;</span> &lt;&lt; counter.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter value: &quot;</span> &lt;&lt; counter.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Thread <span class="number">1</span> incremented counter to <span class="number">2</span></span><br><span class="line">Thread <span class="number">1</span> incremented counter to <span class="number">3</span></span><br><span class="line">Thread <span class="number">1</span> incremented counter to <span class="number">4</span></span><br><span class="line">Thread <span class="number">1</span> incremented counter to <span class="number">5</span></span><br><span class="line">Thread <span class="number">1</span> incremented counter to <span class="number">6</span></span><br><span class="line">Thread <span class="number">1</span> incremented counter to <span class="number">7</span></span><br></pre></td></tr></table></figure><p>内存序。内存序是为了保证多线程在多核CPU的可见性，是一种内存屏障。作用和JAVA的volatile类似。<strong>既然是可见性，就肯定是有的线程写，有的线程读。</strong>如果只有写线程，没必要保证可见性。</p><ol><li>memory_order_seq_cst 是默认的内存顺序，相当于JAVA的volatile，对原子类的修改操作会立刻刷到内存。</li><li>memory_order_acquire和load连用，memory_order_release和store连用。这个保证，如果某线程执行了store+memory_order_release的操作，在其他线程执行load+memory_order_acquire时，是可见的<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">memory_order_relaxed：不保证任何顺序， 只提供原子性，只有写没有读可以使用</span><br><span class="line">memory_order_consume：保证在该原子操作之后的所有依赖操作的顺序。</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面四个常用</span></span><br><span class="line">memory_order_acquire：保证该操作之前的所有操作在该操作后执行。</span><br><span class="line">memory_order_release：保证该操作之后的所有操作在该操作前执行。</span><br><span class="line">memory_order_acq_rel：结合了 acquire 和 release 的效果。</span><br><span class="line">memory_order_seq_cst：保证严格的顺序一致性，即原子类变量多线程并发执行和单线程循环执行顺序完全一致</span><br></pre></td></tr></table></figure></li></ol><p>内存序本身不提供“线程必须等待其他线程写了数据，才可以读”这样的同步语义，需要使用一个load循环，直到load数据。它能保证的是，只要某个线程store了数据，其他线程立刻可以load到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data.<span class="built_in">store</span>(<span class="number">42</span>, std::memory_order_relaxed);  <span class="comment">// 写入数据</span></span><br><span class="line">    ready.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);  <span class="comment">// 通知消费者</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!ready.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;  <span class="comment">// 等待生产者通知</span></span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>();  <span class="comment">// cpu从当前线程切走, 但线程不会进入等待队列，后面还可能被cpu调度</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Consumer read data: &quot;</span> &lt;&lt; data.<span class="built_in">load</span>(std::memory_order_relaxed) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-的lambda表达式和函数类型"><a href="#C-的lambda表达式和函数类型" class="headerlink" title="C++的lambda表达式和函数类型"></a>C++的lambda表达式和函数类型</h4><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><h4 id="JAVA-并发类"><a href="#JAVA-并发类" class="headerlink" title="JAVA 并发类"></a>JAVA 并发类</h4><p>Thread类，继承 Thread 类并重写其 run() 方法，实现多线程。不需要import 库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread is running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现 Runnable 接口并重写 run() 方法, 实现多线程。不需要import 库</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> implements Runnable &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;Runnable thread is running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="keyword">new</span> <span class="built_in">MyRunnable</span>());</span><br><span class="line">        t<span class="number">1.</span><span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Callable和FutureTask接口，与 Runnable 类似，但可以返回结果和抛出异常。需要import java.util.concurrent.Callable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;  <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Result: &quot;</span> + futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池类, Executor 和 ExecutorService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        executor.execute(() -&gt; System.out.println(<span class="string">&quot;Task 1&quot;</span>));</span><br><span class="line">        executor.execute(() -&gt; System.out.println(<span class="string">&quot;Task 2&quot;</span>));</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Task <span class="number">1</span></span><br><span class="line">Task <span class="number">2</span></span><br></pre></td></tr></table></figure><p>CountDownLatch, 倒计时计数器，用于等待其他线程完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; finished task&quot;</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line"></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;All tasks finished&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal，线程独立变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            threadLocal.set(threadLocal.get() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; value: &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized 锁, Java 内置的关键字，可用于方法或代码块, 用于线程同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is executing&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同步代码块</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is executing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) counter.increment();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) counter.increment();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + counter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="并发安全结构"><a href="#并发安全结构" class="headerlink" title="并发安全结构"></a>并发安全结构</h4><p>JAVA提供了一些并发安全的数据结构，位于java.util.concurrent包中</p><ol><li>ConcurrentHashMap<br>线程安全的哈希表实现，支持高效的并发读写。它将内部数据分割为多个段，以减少锁竞争。</li><li>CopyOnWriteArrayList<br>线程安全的 List 实现</li><li>BlockingQueue<br>线程安全的队列接口，通常用于生产者-消费者模型。</li></ol><p>java.util中的HashMap，ArrayList，LinkedList等都是非并发安全的</p><h4 id="JAVA多线程和虚拟机"><a href="#JAVA多线程和虚拟机" class="headerlink" title="JAVA多线程和虚拟机"></a>JAVA多线程和虚拟机</h4><p>相比C&#x2F;C++ 多线程通过pthread直接在linux操作系统中起进程，JAVA的多线程需要经过JAVA虚拟机这一层。</p><p>java虚拟机维护了JavaThread结构，JVM是C++实现的。所以JavaThread是C++定义的类。JavaThread维护了线程的状态，一个指针指向java.lang.Thread创建的对象(oop)，另一个指针指向对应的操作系统创建的OSThread</p><p>java线程模型的实现取决于jvm虚拟机，只要jvm愿意，可以选择类似go使用协程来实现线程。但以市场占有率最大的HotSpot虚拟机举例，一个java线程都是直接映射到操作系统的原生线程来实现的，所有的线程调度都是由操作系统完成的。</p><h4 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h4><p>volatile 关键字可以实现变量的可见性，但不提供原子性。</p><p>JAVA常见的原子类有 AtomicInteger、AtomicLong、AtomicBoolean、AtomicReference</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 设置值</span></span><br><span class="line">        atomicInt.set(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 获取值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Value: &quot;</span> + atomicInt.get());</span><br><span class="line">        <span class="comment">// 原子加操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Incremented: &quot;</span> + atomicInt.incrementAndGet());</span><br><span class="line">        <span class="comment">// 比较并交换</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> atomicInt.compareAndSet(<span class="number">15</span>, <span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;CAS Success: &quot;</span> + success + <span class="string">&quot;, New Value: &quot;</span> + atomicInt.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Value: <span class="number">10</span></span><br><span class="line">Incremented: <span class="number">11</span></span><br><span class="line">CAS Success: <span class="literal">false</span>, New Value: <span class="number">11</span></span><br></pre></td></tr></table></figure><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><h4 id="并发实现"><a href="#并发实现" class="headerlink" title="并发实现"></a>并发实现</h4><p>Golang 在语言层面使用协程实现并发，Go内置协程调度器，能自动在协程阻塞时将协程挂起。Golang的线程是无阻塞的，这意味Golang线程不能使用线程阻塞的系统调用。</p><p>go 关键字自动启动一个协程运行函数任务。golang提供sync.WaitGroup等待协程运行完。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>, wg sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">item := rand.Intn(<span class="number">100</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;Produced:&quot;</span>, item)</span><br><span class="line">ch &lt;- item              <span class="comment">// 发送数据到channel</span></span><br><span class="line">time.Sleep(time.Second) <span class="comment">// 模拟生产过程的延迟</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">int</span>, wg sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> item := <span class="keyword">range</span> ch &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Consumed:&quot;</span>, item)</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">// 模拟消费过程的延迟</span></span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="comment">// 创建一个缓冲区大小为 5 的channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动多个消费者</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> consumer(ch, wg)</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动一个生产者</span></span><br><span class="line"><span class="keyword">go</span> producer(ch, wg)</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主程序运行一段时间后退出</span></span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Produced: <span class="number">63</span></span><br><span class="line">Consumed: <span class="number">63</span></span><br><span class="line">Produced: <span class="number">47</span></span><br><span class="line">Consumed: <span class="number">47</span></span><br><span class="line">Produced: <span class="number">47</span></span><br><span class="line">Consumed: <span class="number">47</span></span><br><span class="line">Produced: <span class="number">99</span></span><br><span class="line">Consumed: <span class="number">99</span></span><br><span class="line">Produced: <span class="number">51</span></span><br><span class="line">Consumed: <span class="number">51</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>select 语句可以等待接收多个channel的数据，只要有一个channel写入了数据，select就会执行处理函数并退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch &lt;- <span class="number">42</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg := &lt;-ch:</span><br><span class="line">fmt.Println(<span class="string">&quot;Received:&quot;</span>, msg)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second): <span class="comment">// 1秒后超时, select执行fmt.Println(&quot;Timeout!&quot;)</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Timeout!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Received: <span class="number">42</span></span><br></pre></td></tr></table></figure><p>sync.Mutex，互斥锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">counter <span class="type">int</span></span><br><span class="line">mu      sync.Mutex <span class="comment">// 创建一个互斥锁</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加计数器的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">counter++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动多个 goroutine 来增加计数器</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">increment()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待所有 goroutine 执行完毕</span></span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Final counter:&quot;</span>, counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync.RWMutex 读写锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">data   <span class="type">int</span></span><br><span class="line">rwMutex sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">rwMutex.RLock()</span><br><span class="line"><span class="keyword">defer</span> rwMutex.RUnlock()</span><br><span class="line"><span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(value <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">rwMutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> rwMutex.Unlock()</span><br><span class="line">data = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动多个读 goroutine</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Printf(<span class="string">&quot;Reader %d: data = %d\n&quot;</span>, i, read())</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动一个写 goroutine</span></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">write(<span class="number">42</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;Writer: data updated&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">wg.Wait() <span class="comment">// 等待所有 goroutine 完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync.Once 是用来确保函数只执行一次，无论是多次调用还是多线程多次执行</p><p>sync.Cond 包提供了条件变量，执行条件变量wait前需要持有锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func</span> (b *Buffer) <span class="built_in">Produce</span>(item <span class="type">int</span>) &#123;</span><br><span class="line">b.lock.<span class="built_in">Lock</span>()</span><br><span class="line">defer b.lock.<span class="built_in">Unlock</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">for</span> <span class="title">len</span><span class="params">(b.data)</span> </span>== bufferSize &#123;</span><br><span class="line">b.cond.<span class="built_in">Wait</span>()</span><br><span class="line">&#125;</span><br><span class="line">b.data = <span class="built_in">append</span>(b.data, item)</span><br><span class="line">fmt.<span class="built_in">Println</span>(<span class="string">&quot;Produced:&quot;</span>, item)</span><br><span class="line"></span><br><span class="line">b.cond.<span class="built_in">Signal</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p>sync&#x2F;atomic 包提供了多种原子操作函数，</p><p>AddInt32：原子地将一个 int32 值加上一个指定的值。</p><p>CompareAndSwapInt32：原子地比较并交换 int32 值。如果当前值等于预期值，则将其更改为新值。</p><p>LoadInt32：原子地加载一个 int32 值。</p><p>StoreInt32：原子地存储一个 int32 值。</p><h4 id="Context-信息传递"><a href="#Context-信息传递" class="headerlink" title="Context 信息传递"></a>Context 信息传递</h4><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><h4 id="多线程和多进程"><a href="#多线程和多进程" class="headerlink" title="多线程和多进程"></a>多线程和多进程</h4><p>Python 的 Cpython有一个全局解释器锁（GIL）。这意味着在任何时刻，只有一个线程可以执行 Python 字节码。Python的多线程实际是单核的并行。</p><p>multiprocessing 和threading 模块使用。Python多进程的问题是，多进程之间是独立的地址空间，难以共享变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_numbers</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程</span></span><br><span class="line">thread1 = threading.Thread(target=print_numbers)</span><br><span class="line">thread2 = threading.Thread(target=print_numbers)</span><br><span class="line"><span class="comment"># 创建进程</span></span><br><span class="line">process1 = multiprocessing.Process(target=print_numbers)</span><br><span class="line">process2 = multiprocessing.Process(target=print_numbers)</span><br><span class="line"></span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line">process1.start()</span><br><span class="line">process2.start()</span><br><span class="line"></span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line">process1.join()</span><br><span class="line">process2.join()</span><br></pre></td></tr></table></figure><p>线程池</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_square</span>(<span class="params">number</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Square of <span class="subst">&#123;number&#125;</span> is <span class="subst">&#123;number * number&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个线程池，最多允许 5 个线程同时执行</span></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="comment"># 提交任务给线程池</span></span><br><span class="line">    executor.submit(print_square, <span class="number">2</span>)</span><br><span class="line">    executor.submit(print_square, <span class="number">3</span>)</span><br><span class="line">    executor.submit(print_square, <span class="number">4</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>线程锁，lock &#x3D; threading.Lock()</p><h4 id="生成器和协程"><a href="#生成器和协程" class="headerlink" title="生成器和协程"></a>生成器和协程</h4><p>生成器。python生成器是一种无栈协程，可以实现手动切换执行流。普通函数可以 yield 语句返回生成器，普通函数执行到yield后会转向执行接收yield返回值的函数，当再执行next()，线程回到原先的函数继续执行。</p><p>使用next() 和 send() 方法可以控制生成器的执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">simple_gen</span>():</span><br><span class="line">    value = <span class="keyword">yield</span> <span class="string">&quot;Ready&quot;</span>  <span class="comment"># 初始返回值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Received:&quot;</span>, value)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;End&quot;</span></span><br><span class="line"></span><br><span class="line">gen = simple_gen()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 第一次执行生成器，收到&quot;Ready&quot;</span></span><br><span class="line"><span class="built_in">print</span>(gen.send(<span class="number">42</span>))  <span class="comment"># 执行流再次切换到simple_gen，simple_gen执行到&quot;End</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Ready</span><br><span class="line">(<span class="string">&#x27;Received:&#x27;</span>, <span class="number">42</span>)</span><br><span class="line">End</span><br></pre></td></tr></table></figure><p>asyncio 是python3提供的无栈协程模块，async 用于定义协程函数，await 用于暂停协程并等待另一个协程完成。async定义的协程函数中不能调用可能导致线程阻塞或者等待的函数，包括阻塞读写、线程锁、sleep等。</p><p>await 后面跟的是io耗时的操作，表示把线程从当前协程切换走；同时await会注册事件通知，当耗时的操作执行完时，调度器会回来再执行当前协程</p><p>await 同时维护了执行的先后顺序，对于async函数A await aysnc函数B，则必须等待B执行完函数A才会继续执行。这个执行逻辑避免了回调地狱，即<strong>对于回调函数链路A-&gt;B-&gt;C，可以直接在A里面写await B, B里面写 await C</strong>，代码更加简洁易懂</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task_1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Task 1 starts&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Task 1 ends&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task_2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Task 2 starts&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> task_1()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Task 2 ends&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并发执行两个任务</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(task_1(), task_2())  <span class="comment"># 需等待所有task执行完</span></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Task <span class="number">1</span> starts</span><br><span class="line">Task <span class="number">2</span> starts</span><br><span class="line">Task <span class="number">1</span> starts</span><br><span class="line">Task <span class="number">1</span> ends</span><br><span class="line">Task <span class="number">1</span> ends</span><br><span class="line">Task <span class="number">2</span> ends</span><br></pre></td></tr></table></figure><p>golang协程是有栈协程，同时不需要显示指定await进行协程切换，调度器会自动发现io阻塞的调用并自动切换协程。golang执行回调函数只需要对无脑的执行<code>go func()</code>，缺点是降低了灵活性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;并发编程是提高程序处理能力的重要手段，也是编程语言必备的能力。并发的单位是函数，函数作为任务被多个并发计算对象执行。并发执行的函数任务可分为一次性任务和定时任务两种。任务可以由主线程直接分发给多线程，也可以借助线程安全的任务&amp;#x2F;消息队列分发任务。&lt;/p&gt;</summary>
    
    
    
    <category term="base" scheme="https://larrystd.github.io/categories/base/"/>
    
    
    <category term="language" scheme="https://larrystd.github.io/tags/language/"/>
    
  </entry>
  
  <entry>
    <title>编程语言(6)—文件IO和网络库</title>
    <link href="https://larrystd.github.io/2025/01/04/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(6)%E2%80%94%E6%96%87%E4%BB%B6IO%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%93/"/>
    <id>https://larrystd.github.io/2025/01/04/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(6)%E2%80%94%E6%96%87%E4%BB%B6IO%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%93/</id>
    <published>2025-01-03T16:00:00.000Z</published>
    <updated>2025-01-04T01:19:35.376Z</updated>
    
    <content type="html"><![CDATA[<p>IO和网络库支持程序访问文件和网络，包括标准输入输出IO、文件IO、网络IO</p><span id="more"></span><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><p>C语言的文件IO位于<code>#include &lt;stdio.h&gt;</code>库，主要包含如下几个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span></span>;</span><br><span class="line"><span class="comment">// mode</span></span><br><span class="line"><span class="comment">// &quot;r&quot;：以只读方式打开文件，文件必须存在。</span></span><br><span class="line"><span class="comment">// &quot;w&quot;：以只写方式打开文件，如果文件已存在，会清空文件内容；如果文件不存在，会创建新文件。</span></span><br><span class="line"><span class="comment">// &quot;a&quot;：以追加模式打开文件，数据写入到文件末尾，文件不存在时会创建。</span></span><br><span class="line"><span class="comment">// &quot;r+&quot;：以读写模式打开文件，文件必须存在。</span></span><br><span class="line"><span class="comment">// &quot;w+&quot;：以读写模式打开文件，文件不存在时会创建，已存在时会清空文件内容。</span></span><br><span class="line"><span class="comment">// &quot;a+&quot;：以读写模式打开文件，数据写入文件末尾，文件不存在时会创建。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="comment">// 从文件中读取一个字符。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fgetc</span><span class="params">(FILE *stream)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从文件中读取一行，最多读取 num-1 个字符。</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fgets</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> num, FILE *stream)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从文件中读取多个ptr对象（如结构体、数组等），每个对象大小为 size，读取 count 个对象。</span></span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *stream)</span></span>;</span><br><span class="line"><span class="type">int</span> numbers[<span class="number">5</span>];</span><br><span class="line"><span class="type">size_t</span> n = <span class="built_in">fread</span>(numbers, <span class="built_in">sizeof</span>(<span class="type">int</span>), <span class="number">5</span>, file);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line"><span class="comment">// 将字符 c 写入文件</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fputc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将字符串 str 写入文件，自动加上字符串的结束符 \0</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, FILE *stream)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 写入多个对象到文件，每个对象大小为 size，写入 count 个对象。</span></span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *stream)</span></span>;</span><br><span class="line"><span class="type">int</span> numbers[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">size_t</span> n = <span class="built_in">fwrite</span>(numbers, <span class="built_in">sizeof</span>(<span class="type">int</span>), <span class="number">5</span>, file);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件定位</span></span><br><span class="line"><span class="comment">// 设置文件指针的位置。offset 是偏移量，whence 是参考位置。</span></span><br><span class="line"><span class="comment">// SEEK_SET：从文件开头开始偏移。</span></span><br><span class="line"><span class="comment">// SEEK_CUR：从当前位置开始偏移</span></span><br><span class="line"><span class="comment">// SEEK_END：从文件末尾开始偏移</span></span><br><span class="line"><span class="built_in">fseek</span>(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)：</span><br><span class="line"><span class="comment">// 获取当前文件指针的位置</span></span><br><span class="line"><span class="built_in">ftell</span>(FILE *stream)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查文件是否已读到末尾</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">feof</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准输入输出</span></span><br><span class="line"><span class="comment">// %d：输出10进制整数; %f：输出浮点数; %s：输出字符串; %c：输出字符;%x：输出十六进制整数。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a); </span><br><span class="line"><span class="comment">// 从标准输入读取一个字符。</span></span><br><span class="line"><span class="built_in">getchar</span>()</span><br><span class="line"><span class="comment">// 将一个字符输出到标准输出</span></span><br><span class="line"><span class="built_in">putchar</span>() </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件中按指定的格式读取数据，并将读取的数据存储到变量。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="comment">// fprintf() 向文件中写入格式化的数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sprintf() 将格式化的数据写入字符串。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="built_in">sprintf</span>(buffer, <span class="string">&quot;Number: %d, Pi: %.2f&quot;</span>, num, pi);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sscanf() 函数用于从字符串中按指定格式读取数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>C语言网络socket 直接使用linux相关系统调用</p><p>服务端，绑定（bind）到指定端口。监听（listen）端口，等待客户端连接。接受（accept）客户端的连接请求。进行数据通信（send，recv, read, write），关闭 Socket（close）。</p><p>客户端，创建 Socket。连接（connect）到服务器端。发送和接收数据。关闭 Socket。</p><p>涉及到的系统调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建socket</span></span><br><span class="line"><span class="comment">// domain：指定协议族，常用的有：</span></span><br><span class="line"><span class="comment">// AF_INET：IPv4协议。</span></span><br><span class="line"><span class="comment">// AF_INET6：IPv6协议。</span></span><br><span class="line"><span class="comment">// AF_UNIX：Unix 域协议，用于同一机器上的进程间通信。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// type：指定套接字类型，常见的有：</span></span><br><span class="line"><span class="comment">// SOCK_STREAM：面向连接的流式套接字，通常用于 TCP。</span></span><br><span class="line"><span class="comment">// SOCK_DGRAM：数据报套接字，通常用于 UDP。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// protocol：指定协议，通常为 0，表示由操作系统自动选择合适的协议。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind() 用于将套接字与本地IP 地址和端口号绑定。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 绑定到任意IP地址</span></span><br><span class="line">server_addr.sin_port = <span class="built_in">htons</span>(PORT);        <span class="comment">// 设置端口号</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;Bind failed&quot;</span>);</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// backlog：等待连接队列的最大长度，表示操作系统在拒绝新连接之前，最多允许排队的连接请求数。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// accept() 用于接受一个传入的连接请求。该函数会阻塞，直到有客户端连接。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// connect() 用于客户端请求与服务器建立连接</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从socket fd获得数据</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"><span class="comment">// 向socket fd发送数据</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭一个打开的套接字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">// shutdown() 可用于关闭连接的一部分（如读或写）</span></span><br><span class="line"><span class="comment">// how：关闭方式，可能的值有：SHUT_RD：关闭读取。SHUT_WR：关闭写入。SHUT_RDWR：关闭读取和写入。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>C++ 没有提供网络库，只提供文件IO库</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ifstream：用于从文件中读取数据。</span></span><br><span class="line"><span class="comment">// ofstream：用于向文件中写入数据。</span></span><br><span class="line"><span class="comment">// fstream：用于从文件中读取和向文件中写入数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可用文件流类的构造函数或者 open() 方法来打开文件。mode可以选择</span></span><br><span class="line"><span class="comment">// ios::in：以读取模式打开文件（默认）。</span></span><br><span class="line"><span class="comment">// ios::out：以写入模式打开文件。</span></span><br><span class="line"><span class="comment">// ios::app：以追加模式打开文件（写入内容会被追加到文件末尾）。</span></span><br><span class="line"><span class="comment">// ios::binary：以二进制模式打开文件。</span></span><br><span class="line"><span class="comment">// ios::trunc：如果文件已经存在，截断文件为零长度</span></span><br><span class="line"><span class="function">std::ofstream <span class="title">outfile</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>, std::ios::out | std::ios::trunc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查文件流状态</span></span><br><span class="line"><span class="built_in">is_open</span>()  <span class="comment">// 检查文件是否成功打开。</span></span><br><span class="line"><span class="built_in">eof</span>()  <span class="comment">// 检查是否已经到达文件末尾。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件指针定位</span></span><br><span class="line"><span class="built_in">seekg</span>(offset, direction)  <span class="comment">// 设置读取位置。</span></span><br><span class="line"><span class="built_in">seekp</span>(offset, direction)  <span class="comment">// 设置写入位置。</span></span><br><span class="line"><span class="built_in">tellg</span>()  <span class="comment">// 返回当前读取位置。</span></span><br><span class="line"><span class="built_in">tellp</span>()  <span class="comment">// 返回当前写入位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cout 是 C++ 标准输出流对象，是一个 ostream 类型的对象</span></span><br><span class="line"><span class="comment">// C++标准输入输出很反人类，建议直接用C库</span></span><br></pre></td></tr></table></figure><p>按行读取文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!infile) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open file.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(infile, line)) &#123;</span><br><span class="line">        std::cout &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    infile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><h4 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h4><p>JAVA文件流分为两种主要类型：字节流和字符流。字节流用于处理所有类型的文件（包括图像、音频等二进制文件），字符流则专门用于处理字符文件（如文本文件）。</p><p>字节流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FileInputStream：从文件读取字节数据</span></span><br><span class="line"><span class="comment">// FileOutputStream：向文件写入字节数据</span></span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteFileRead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">int</span> content;</span><br><span class="line">            <span class="keyword">while</span> ((content = fileInputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>) content);  <span class="comment">// 将读取的字节转换为字符并打印</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteFileWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">            fileOutputStream.write(data.getBytes());  <span class="comment">// 将字符串数据转换为字节并写入文件</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符流，专门用来处理字符数据、文本文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FileReader：从文件读取字符数据</span></span><br><span class="line"><span class="comment">// FileWriter：向文件写入字符数据</span></span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharFileRead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;input.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">int</span> content;</span><br><span class="line">            <span class="keyword">while</span> ((content = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>) content);  <span class="comment">// 将读取的字符打印到控制台</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharFileWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">            fileWriter.write(data);  <span class="comment">// 直接写入字符数据</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓冲流, 提供了一个缓冲区，可以减少对硬盘的读取次数，从而提高性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferedReader：缓冲字符输入流，用于提高读取效率。</span></span><br><span class="line"><span class="comment">// BufferedWriter：缓冲字符输出流，用于提高写入效率。</span></span><br><span class="line"><span class="comment">// BufferedInputStream：缓冲字节输入流。</span></span><br><span class="line"><span class="comment">// BufferedOutputStream：缓冲字节输出流。</span></span><br></pre></td></tr></table></figure><p>RandomAccessFile，随机访问文件。这个类似C语言的FILE指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomAccessFileExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>)) &#123;</span><br><span class="line">            file.writeUTF(<span class="string">&quot;Hello, World!&quot;</span>);  <span class="comment">// 写入字符串</span></span><br><span class="line">            file.seek(<span class="number">0</span>);  <span class="comment">// 将文件指针移动到文件开头</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> file.readUTF();  <span class="comment">// 读取字符串</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Read from file: &quot;</span> + data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h4><p>System.out 是 Java 中标准输出流，是 PrintStream 类型的对象</p><p>System.in 是 Java 中标准输入流, 是 InputStream 类型的对象，读取的是字节数据。对于字符数据，通常会使用 Scanner 或 BufferedReader 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScannerInput</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;Enter your name:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.nextLine();  <span class="comment">// 读取一行字符串</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Enter your age:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + name + <span class="string">&quot;, Age: &quot;</span> + age);</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>格式化输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(String format, Object... args);</span><br></pre></td></tr></table></figure><h4 id="网络库"><a href="#网络库" class="headerlink" title="网络库"></a>网络库</h4><p>java.net 包提供了构建网络应用的基础类和接口</p><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><h4 id="文件IO-1"><a href="#文件IO-1" class="headerlink" title="文件IO"></a>文件IO</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">os.Open  <span class="comment">// 用于打开一个文件，只读模式。</span></span><br><span class="line">os.Create  <span class="comment">// 用于创建一个新文件，如果文件已存在，则会覆盖它</span></span><br><span class="line">os.OpenFile  <span class="comment">// 指定模式打开文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (*File, <span class="type">error</span>)</span><br><span class="line">file, err := os.OpenFile(<span class="string">&quot;example.txt&quot;</span>, os.O_APPEND|os.O_WRONLY, <span class="number">0644</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动文件指针位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Seek(offset <span class="type">int64</span>, whence <span class="type">int</span>) (ret <span class="type">int64</span>, err <span class="type">error</span>)</span><br><span class="line">position, err := file.Seek(<span class="number">0</span>, io.SeekCurrent)  <span class="comment">// 返回文件当前位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按字节读取文件, 一次最多读取len(p)字节到buf</span></span><br><span class="line">Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">// 指定offset读取</span></span><br><span class="line">ReadAt(p []<span class="type">byte</span>, off <span class="type">int64</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">n, err := file.Read(buf)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ioutil.ReadFile 读取整个文件</span></span><br><span class="line">content, err := ioutil.ReadFile(<span class="string">&quot;example.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入字符串到文件</span></span><br><span class="line">_, err = file.WriteString(<span class="string">&quot;Hello, Golang file I/O!&quot;</span>)</span><br><span class="line"><span class="comment">// 写入字节序列到文件</span></span><br><span class="line">data := []<span class="type">byte</span>(<span class="string">&quot;Hello, Golang byte data!&quot;</span>)</span><br><span class="line">_, err = file.Write(data)</span><br><span class="line"><span class="comment">// 在offset随机写文件</span></span><br><span class="line">WriteAt(p []<span class="type">byte</span>, off <span class="type">int64</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>golang 格式化参数有所特别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">%v值的默认格式表示</span><br><span class="line">%+v带字段名的结构体表示</span><br><span class="line"></span><br><span class="line">%c对应 Unicode 码点的字符</span><br><span class="line">%d十进制表示</span><br><span class="line">%x十六进制（小写字母）</span><br><span class="line">%X十六进制（大写字母）</span><br><span class="line"></span><br><span class="line">%s字符串</span><br><span class="line">%.nf: 指定小数点后 n 位</span><br><span class="line">%m.nf 设置宽度和小数位数</span><br></pre></td></tr></table></figure><h4 id="标准输入输出-1"><a href="#标准输入输出-1" class="headerlink" title="标准输入输出"></a>标准输入输出</h4><p>golang提供fmt包用于标准输入输出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出</span></span><br><span class="line">fmt.Print(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"><span class="comment">// 格式化输出</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;My name is %s and I am %d years old.\n&quot;</span>, name, age)</span><br><span class="line"><span class="comment">// fmt.Fprint() 将格式化的输出写入到指定的 io.Writer</span></span><br><span class="line">fmt.Fprint(os.Stdout, <span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">fmt.Fprintf(file, <span class="string">&quot;Hello, file!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// fmt.Scanf() 标准输入</span></span><br><span class="line">fmt.Scanf(<span class="string">&quot;%s %d&quot;</span>, &amp;name, &amp;age)</span><br><span class="line">fmt.Scanln(&amp;name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串格式化</span></span><br><span class="line">result := fmt.Sprintf(<span class="string">&quot;Name: %s, Age: %d&quot;</span>, name, age)</span><br><span class="line">fmt.Sscanf(input, <span class="string">&quot;%s %d&quot;</span>, &amp;name, &amp;age)</span><br></pre></td></tr></table></figure><h4 id="网络库-1"><a href="#网络库-1" class="headerlink" title="网络库"></a>网络库</h4><p>Go提供了 net 包 用于网络编程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 连接到 TCP 服务器</span></span><br><span class="line">conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error dialing:&quot;</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向服务器发送数据</span></span><br><span class="line">_, err = conn.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello, Server!&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error sending message:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取服务器响应</span></span><br><span class="line">buffer := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">n, err := conn.Read(buffer)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error reading response:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印接收到的响应</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Received: %s\n&quot;</span>, <span class="type">string</span>(buffer[:n]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 在本地启动一个 TCP 服务器，监听端口 8080</span></span><br><span class="line">listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error starting server:&quot;</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listen.Close()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Server started, waiting for connections...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受客户端连接</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := listen.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error accepting connection:&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取客户端消息</span></span><br><span class="line">buffer := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">n, err := conn.Read(buffer)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error reading from connection:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出接收到的消息</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Received: %s\n&quot;</span>, <span class="type">string</span>(buffer[:n]))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向客户端发送响应</span></span><br><span class="line">_, err = conn.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello, Client!&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error sending response:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="命令行库"><a href="#命令行库" class="headerlink" title="命令行库"></a>命令行库</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义命令行参数</span></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> isAdmin <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 flag 包解析命令行标志</span></span><br><span class="line">flag.StringVar(&amp;name, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Guest&quot;</span>, <span class="string">&quot;Your name&quot;</span>)</span><br><span class="line">flag.IntVar(&amp;age, <span class="string">&quot;age&quot;</span>, <span class="number">18</span>, <span class="string">&quot;Your age&quot;</span>)</span><br><span class="line">flag.BoolVar(&amp;isAdmin, <span class="string">&quot;admin&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;Is admin?&quot;</span>)</span><br><span class="line"></span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;Name: %s\n&quot;</span>, name)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Age: %d\n&quot;</span>, age)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Is Admin: %v\n&quot;</span>, isAdmin)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行, go run main.go -name=John -age=30 -admin=true</span></span><br></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><h4 id="文件IO-2"><a href="#文件IO-2" class="headerlink" title="文件IO"></a>文件IO</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line"><span class="comment"># 文件打开模式</span></span><br><span class="line"><span class="comment"># &#x27;r&#x27;：只读模式，文件必须存在。</span></span><br><span class="line"><span class="comment"># &#x27;w&#x27;：写入模式，若文件已存在则覆盖，不存在则创建。</span></span><br><span class="line"><span class="comment"># &#x27;a&#x27;：追加模式，在文件末尾追加内容，若文件不存在，则创建。</span></span><br><span class="line"><span class="comment"># &#x27;b&#x27;：二进制模式（如读取或写入图片、音频等）</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;filename&#x27;</span>, mode=<span class="string">&#x27;r&#x27;</span>, buffering=-<span class="number">1</span>, encoding=<span class="literal">None</span>, errors=<span class="literal">None</span>, newline=<span class="literal">None</span>, closefd=<span class="literal">True</span>, opener=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    content = file.read()  <span class="comment"># 读取全部内容</span></span><br><span class="line">    <span class="built_in">print</span>(content)</span><br><span class="line">    </span><br><span class="line">    file.seek(<span class="number">0</span>)  <span class="comment"># 文件指针移动到开头</span></span><br><span class="line">    first_10_chars = file.read(<span class="number">10</span>)  <span class="comment"># 读取前10个字符</span></span><br><span class="line">    <span class="built_in">print</span>(first_10_chars)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(file.tell())  <span class="comment"># 输出文件指针当前位置</span></span><br><span class="line"></span><br><span class="line">    file.write(<span class="string">&quot;Hello, World!\n&quot;</span>)  <span class="comment"># 写入内容</span></span><br><span class="line"></span><br><span class="line">    lines = [<span class="string">&#x27;Line 1\n&#x27;</span>, <span class="string">&#x27;Line 2\n&#x27;</span>, <span class="string">&#x27;Line 3\n&#x27;</span>]</span><br><span class="line">    file.writelines(lines)  <span class="comment"># 写入多行</span></span><br><span class="line">    file.flush()  <span class="comment"># 立即写入数据</span></span><br></pre></td></tr></table></figure><p>os 文件操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">os.remove(<span class="string">&#x27;example.txt&#x27;</span>)  <span class="comment"># 删除文件</span></span><br><span class="line"><span class="comment"># 获取文件状态信息</span></span><br><span class="line">stat_info = os.stat(<span class="string">&#x27;example.txt&#x27;</span>)</span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">os.mkdir(<span class="string">&#x27;new_directory&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="标准输入输出-2"><a href="#标准输入输出-2" class="headerlink" title="标准输入输出"></a>标准输入输出</h4><p>print() 函数用于标准输出, 同时也支持格式化输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Alice&quot;</span></span><br><span class="line">age = <span class="number">25</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;My name is <span class="subst">&#123;name&#125;</span>, and I am <span class="subst">&#123;age&#125;</span> years old.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is &#123;&#125;, and I am &#123;&#125; years old.&quot;</span>.<span class="built_in">format</span>(name, age))</span><br></pre></td></tr></table></figure><p>input()用于标准输入， input读到的类型都是字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;Enter your name: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter your age: &quot;</span>))</span><br></pre></td></tr></table></figure><h4 id="网络库-2"><a href="#网络库-2" class="headerlink" title="网络库"></a>网络库</h4><p>socket编程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 TCP 套接字</span></span><br><span class="line">server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 绑定服务器地址和端口</span></span><br><span class="line">server_address = (<span class="string">&#x27;localhost&#x27;</span>, <span class="number">65432</span>)</span><br><span class="line">server_socket.bind(server_address)</span><br><span class="line">server_socket.listen(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Waiting for a connection...&quot;</span>)</span><br><span class="line">connection, client_address = server_socket.accept()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Connection from <span class="subst">&#123;client_address&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    data = connection.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Received: <span class="subst">&#123;data.decode()&#125;</span>&quot;</span>)</span><br><span class="line">    message = <span class="string">&quot;Hello, Client!&quot;</span></span><br><span class="line">    connection.sendall(message.encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    connection.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server_address = (<span class="string">&#x27;localhost&#x27;</span>, <span class="number">65432</span>)  <span class="comment"># 服务器地址和端口</span></span><br><span class="line">client_socket.connect(server_address)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    message = <span class="string">&#x27;Hello, Server!&#x27;</span></span><br><span class="line">    client_socket.sendall(message.encode())  <span class="comment"># 发送数据（注意要编码成字节）</span></span><br><span class="line">    data = client_socket.recv(<span class="number">1024</span>)  <span class="comment"># 接收数据（最多 1024 字节）</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Received from server: <span class="subst">&#123;data.decode()&#125;</span>&quot;</span>)  <span class="comment"># 解码并打印数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 关闭连接</span></span><br><span class="line">    client_socket.close()</span><br></pre></td></tr></table></figure><h4 id="argparse-命令行输入"><a href="#argparse-命令行输入" class="headerlink" title="argparse 命令行输入"></a>argparse 命令行输入</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 ArgumentParser 对象</span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&quot;A simple command-line tool&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加参数</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;name&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot;Your name&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;age&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&quot;Your age&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--admin&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&quot;Are you an admin?&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析命令行参数</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Name: <span class="subst">&#123;args.name&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Age: <span class="subst">&#123;args.age&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Admin: <span class="subst">&#123;args.admin&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="json-序列化"><a href="#json-序列化" class="headerlink" title="json 序列化"></a>json 序列化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="string">&quot;city&quot;</span>: <span class="string">&quot;New York&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件并写入 JSON 数据</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">    json.dump(data, json_file, indent=<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 从文件中读取 JSON 数据</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">    data = json.load(json_file)</span><br><span class="line"><span class="comment"># 对象编码</span></span><br><span class="line">json_string = json.dumps(data, indent=<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 对象解码</span></span><br><span class="line">data = json.loads(json_string)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;IO和网络库支持程序访问文件和网络，包括标准输入输出IO、文件IO、网络IO&lt;/p&gt;</summary>
    
    
    
    <category term="base" scheme="https://larrystd.github.io/categories/base/"/>
    
    
    <category term="language" scheme="https://larrystd.github.io/tags/language/"/>
    
  </entry>
  
  <entry>
    <title>静态变量和函数</title>
    <link href="https://larrystd.github.io/2025/01/02/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0/"/>
    <id>https://larrystd.github.io/2025/01/02/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0/</id>
    <published>2025-01-01T16:00:00.000Z</published>
    <updated>2025-01-04T01:18:52.708Z</updated>
    
    <content type="html"><![CDATA[<p>简谈编程语言中的静态变量和函数</p><span id="more"></span><h3 id="C-的静态变量-函数"><a href="#C-的静态变量-函数" class="headerlink" title="C++的静态变量&#x2F;函数"></a>C++的静态变量&#x2F;函数</h3><p>C++中，静态变量生命周期贯穿程序，在程序开始运行时分配内存并初始化，程序结束运行时释放内存。</p><ol><li>在继承结构中，如果子类未定义同名静态变量，父类和子类引用相同的静态变量，父类和子类静态变量地址一样；如果子类定义了同名的静态变量，那么父类和子类具有独立的静态变量。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count; <span class="comment">// 静态变量声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::count = <span class="number">0</span>; <span class="comment">// 静态变量定义和初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">// 派生类可以访问静态变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base::count = <span class="number">5</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Base::count: &quot;</span> &lt;&lt; Base::count &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Derived::count: &quot;</span> &lt;&lt; Derived::count &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Base::count address: &quot;</span> &lt;&lt; &amp;Base::count &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Derived::count address: &quot;</span> &lt;&lt; &amp;Derived::count &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Base::count: <span class="number">5</span></span><br><span class="line">Derived::count: <span class="number">5</span></span><br><span class="line">Base::count address: <span class="number">0x55a3f58cf154</span></span><br><span class="line">Derived::count address: <span class="number">0x55a3f58cf154</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>全局静态变量在.cpp文件级别声明，只在定义它的文件中可见，其他.cpp无法通过extern声名引用。除了静态变量，C++全局变量的生命周期也和程序相同，全局变量可以被其他.cpp文件引用，链接时会使相关.cpp文件引用相同的全局变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> global_var = <span class="number">10</span>; <span class="comment">// 文件级静态变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Global variable: &quot;</span> &lt;&lt; global_var &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// extern int global_var; // 错误，无法访问 file1.cpp 的静态变量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// display(); // 如果 display 定义在 file1.cpp，可以调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>C++静态函数和上面的静态变量类似，</p><ol><li>如果子类未定义同名静态函数，父类和子类引用相同的静态函数，父类和子类静态变量地址一样；如果子类定义了同名的静态函数，那么父类和子类具有独立的静态函数。</li><li>全局静态函数在.cpp文件级别声明，只在定义它的文件中可见，其他.cpp无法通过extern声名引用。C++全局函数的生命周期也和程序相同，全局函数可以被其他.cpp文件引用，链接时会使相关.cpp文件引用相同的全局变量。</li></ol></li></ol><p>静态变量&#x2F;函数的符号未被导出，其他文件无法直接引用它。这是静态函数的设计初衷，用来实现模块化和封装。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base static function&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 派生类继承了 Base 的静态函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过基类调用</span></span><br><span class="line">    Base::<span class="built_in">display</span>(); <span class="comment">// 输出：Base static function</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Base::display address: &quot;</span> &lt;&lt;<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;Base::display) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过派生类调用</span></span><br><span class="line">    Derived::<span class="built_in">display</span>(); <span class="comment">// 输出：Base static function</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Derived::display address: &quot;</span> &lt;&lt;<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;Derived::display) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 通过派生类的对象调用</span></span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">display</span>(); <span class="comment">// 输出：Base static function</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Base <span class="type">static</span> function</span><br><span class="line">Base::display address: <span class="number">0x55a1967b42bf</span></span><br><span class="line">Base <span class="type">static</span> function</span><br><span class="line">Derived::display address: <span class="number">0x55a1967b42bf</span></span><br><span class="line">Base <span class="type">static</span> function</span><br></pre></td></tr></table></figure><ol start="4"><li>C++静态函数不能配置成虚函数virtual, const和volatile<ol><li>static函数目的是编译时绑定，而virtual函数要求运行时绑定，二者不可兼容。虚函数表里也不会记录static函数</li><li>const 类成员函数表示该函数不能被修改类成员变量，static函数不属于对象，本质通过类名调用，不能配置成const函数</li><li>静态变量可以被const, volatile修饰</li></ol></li></ol><h3 id="JAVA的静态变量和函数"><a href="#JAVA的静态变量和函数" class="headerlink" title="JAVA的静态变量和函数"></a>JAVA的静态变量和函数</h3><p>JAVA 静态变量和函数的逻辑和C++类似，不一样的使JAVA的类加载机制。JAVA除了静态变量和静态函数的概念，还有静态代码块的概念。<strong>类加载时，会初始化静态变量和执行静态代码块内容</strong>。</p><p>但不是每个类都会被加载，有两种加载类的条件</p><ol><li>主动使用类时，如：创建类实例（new操作）。调用类的静态方法。访问类的静态字段。使用Class.forName()加载类。</li><li>子类初始化时，父类会被初始化。</li></ol><p>C++不需要加载类，因为编译完C++代码就没有类的信息了，更不用说加载类。</p><p>通过子类引用父类的静态字段： 只会初始化父类，而不会初始化子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent initialized.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child initialized.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Child.value); <span class="comment">// 只输出 Parent initialized.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Parent initialized.</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure><p><strong>常量在编译期已确定，不会触发类加载。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Example initialized.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONSTANT</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Example.CONSTANT); <span class="comment">// 不会触发类加载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure><p>JAVA类函数默认所有实例方法都是虚函数，支持多态，final、static、private方法除外。但静态函数不支持多态。</p><h3 id="Golang-的全局函数-变量"><a href="#Golang-的全局函数-变量" class="headerlink" title="Golang 的全局函数&#x2F;变量"></a>Golang 的全局函数&#x2F;变量</h3><p>Go语言中，没有像C&#x2F;C++或Java中明确的“静态变量”概念。</p><p>全局变量在Go中可以用于实现类似静态变量的功能。全局变量, 作用域为整个包。如下函数中，它的值在每次调用 increment 函数后都会保留。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter <span class="type">int</span> <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    counter++</span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(increment()) </span><br><span class="line">    fmt.Println(increment()) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>Go的标准库提供了 sync.Once，可以确保某段代码只执行一次（类似静态初始化）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"><span class="keyword">var</span> config <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initConfig</span><span class="params">()</span></span> &#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Initializing config...&quot;</span>)</span><br><span class="line">        config = <span class="string">&quot;LoadedConfig&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    initConfig()</span><br><span class="line">    fmt.Println(config)</span><br><span class="line"></span><br><span class="line">    initConfig() <span class="comment">// 不会再初始化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Initializing config...</span><br><span class="line">LoadedConfig</span><br></pre></td></tr></table></figure><p>组合对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌入结构体</span></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">Person   <span class="comment">// 匿名字段（嵌入字段）</span></span><br><span class="line">Position <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">per := Person&#123;Name: <span class="string">&quot;Alice&quot;</span>, Age: <span class="number">20</span>&#125;</span><br><span class="line">emp := Employee&#123;</span><br><span class="line">Person:   per,</span><br><span class="line">Position: <span class="string">&quot;Developer&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(emp.Name)</span><br><span class="line">fmt.Println(emp.Age)</span><br><span class="line">fmt.Println(emp.Position)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Alice</span><br><span class="line"><span class="number">20</span></span><br><span class="line">Developer</span><br></pre></td></tr></table></figure><h3 id="Python的类函数和静态函数"><a href="#Python的类函数和静态函数" class="headerlink" title="Python的类函数和静态函数"></a>Python的类函数和静态函数</h3><p>Python 没有对变量的静态修饰，只有对函数的classmethod和staticmethod修饰</p><p>类函数的第一个参数是 cls，表示调用该方法的类本身，而不是实例。类函数可以访问类的属性和方法，不能直接操作实例属性。类函数通过类名调用</p><p>Python在类内部直接定义的变量是类变量，比如下面的static_var，self定义的变量是实例变量。前者可以通过cls访问。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    static_var = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        MyClass.static_var += <span class="number">1</span>  <span class="comment"># 每次创建实例时修改类变量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_static_var</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">return</span> cls.static_var</span><br><span class="line"></span><br><span class="line">a = MyClass()</span><br><span class="line">b = MyClass()</span><br><span class="line"><span class="built_in">print</span>(MyClass.static_var)  <span class="comment"># 输出: 2</span></span><br><span class="line"><span class="built_in">print</span>(a.get_static_var())  <span class="comment"># 输出: 2</span></span><br></pre></td></tr></table></figure><p>静态方法不需要传递 self 或 cls 参数。不能访问类或实例的属性，只能执行独立的功能。同样通过类名调用。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">static_method</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This is a static method.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用</span></span><br><span class="line">MyClass.static_method()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;简谈编程语言中的静态变量和函数&lt;/p&gt;</summary>
    
    
    
    <category term="base" scheme="https://larrystd.github.io/categories/base/"/>
    
    
    <category term="language" scheme="https://larrystd.github.io/tags/language/"/>
    
  </entry>
  
  <entry>
    <title>编程语言(4)—数据结构和算法</title>
    <link href="https://larrystd.github.io/2025/01/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(4)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    <id>https://larrystd.github.io/2025/01/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(4)%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</id>
    <published>2025-01-01T16:00:00.000Z</published>
    <updated>2025-01-04T01:16:02.784Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构和算法库是程序编写最基础的库之一。字符串是人类语言的记录，是计算机处理的主要对象，因此字符串数据和算法是重中之重。</p><span id="more"></span><h3 id="C和C"><a href="#C和C" class="headerlink" title="C和C++"></a>C和C++</h3><p>由于C语言不提供数据结构和算法库，这里专指C++的STL stand template library。</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>vector 是一个动态数组，随机访问时间O(1)，可以快速地在末尾插入或删除元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出：1 2 3 4 5 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; vec[<span class="number">2</span>] &lt;&lt; std::endl;  <span class="comment">// 访问元素 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>list 是双向链表，能高效插入或删除元素，但不提供随机访问接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; lst = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    lst.<span class="built_in">push_back</span>(<span class="number">6</span>);  <span class="comment">// 在末尾插入元素</span></span><br><span class="line">    lst.<span class="built_in">push_front</span>(<span class="number">0</span>); <span class="comment">// 在头部插入元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : lst) &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出：0 1 2 3 4 5 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>deque 是双端队列，头部和尾部可以进行高效的插入和删除操作。<strong>deque也提供随机访问接口</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; deq = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    deq.<span class="built_in">push_back</span>(<span class="number">6</span>);   <span class="comment">// 在尾部添加元素</span></span><br><span class="line">    deq.<span class="built_in">push_front</span>(<span class="number">0</span>);  <span class="comment">// 在头部添加元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : deq) &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出：0 1 2 3 4 5 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set 是一个集合，自动排序且不允许重复元素。unordered_set 是一个不排序的集合，元素根据哈希值存储，允许快速查找和插入。</p><p>map 是一个映射，存储键值对（key-value），并根据键进行排序。unordered_map 是一个无序映射，存储键值对，使用哈希表进行存储。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::string&gt; um = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="number">3</span>, <span class="string">&quot;three&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : um) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器，C++ STL使用迭代器来标识容器中的元素，以及实现容器中元素的访问。迭代器支持<code>*</code>和<code>-&gt;</code>运算符来解引用或访问元素成员变量</p><ol><li>随机访问迭代器 (Random Access Iterator)，类似指针，通过加减算数提供随机访问。对应容器<code>std::vector、std::deque、std::array</code>。支持随机访问迭代器作为参数的算法函数，一般也支持指针作为参数。</li><li>双向迭代器(Bidirectional Iterator)，允许在容器中向前和向后移动。对应容器<code>std::list、std::set、std::map。</code></li></ol><p>迭代器是使用继承结构组织的，随机访问迭代器也是一种双向迭代器</p><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>std::sort：对容器中的元素进行排序，默认升序。需要传入随机访问迭代器作为参数</p><p>std::sort是不稳定的，std::stable_sort提供稳定排序，即保证相同元素的相对顺序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());  <span class="comment">// 升序排序</span></span><br><span class="line">std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;  <span class="comment">// 降序</span></span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>std::find：查找容器中的某个元素，返回第一个匹配元素的迭代器。传入双向迭代器即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// 找到了元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::lower_bound，传入排序好的数组，返回第一个大于或等于指定元素的迭代器。<br>std::upper_bound：返回指向已排序数组中第一个大于指定元素的迭代器。</p><p>需要传入随机访问迭代器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">lower_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">upper_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>std::reverse：反转容器中的元素顺序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">reverse</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>std::fill：将容器中的所有元素设置为指定值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>std::transform：对容器中的每个元素应用指定的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">transform</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), vec.<span class="built_in">begin</span>(), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;);</span><br></pre></td></tr></table></figure><p>std::copy：将容器中的元素复制到另一个容器。std::swap：交换两个容器的内容。std::move：移动容器的元素，避免复制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">copy</span>(vec, dest);</span><br><span class="line">std::<span class="built_in">swap</span>(vec, dest);</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; new_vec = std::<span class="built_in">move</span>(vec);</span><br></pre></td></tr></table></figure><p>std::count：统计容器中某个元素出现的次数。std::count_if：统计符合特定条件的元素的数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = std::<span class="built_in">count</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> count = std::<span class="built_in">count_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br></pre></td></tr></table></figure><p>std::accumulate：对容器中的元素进行累加。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = std::<span class="built_in">accumulate</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>std::min_element：返回容器中最小元素的迭代器。std::max_element：返回容器中最大元素的迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> min_it = std::<span class="built_in">min_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">auto</span> max_it = std::<span class="built_in">max_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h4 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h4><p>由于C++兼容C语言，因此支持C风格和C++风格的字符串处理算法。C风格字符串函数参数是指针，C++风格是随机访问迭代器。</p><p>C风格的字符串处理函数, 在C++中，执行<code>#include &lt;cstring&gt;</code>，C语言的字符串处理函数作为std namespace的全局函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strcpy(dest, src), strncpy(dest, src, n), 字符串拷贝</span></span><br><span class="line"><span class="type">char</span> src[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">char</span> dest[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">strcpy</span>(dest, src);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">strncpy</span>(dest, src, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// strcat(str1, str2) 将str2拼接到str1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">strcat</span>(str1, str2); </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">strncat</span>(str1, str2, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// strlen(str)，返回 C 风格字符串的长度（不包括 \0 终止符）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// strcmp(str1, str2), strncmp(str1, str2, n) 如果str1 &gt; str2, 返回大于0</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">strcmp</span>(str1, str2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// strchr(str, c)，查找字符c在字符串str中第一次出现的位置。如果找到了，返回指向该字符的指针；如果没找到，返回 nullptr。</span></span><br><span class="line"><span class="type">char</span>* ptr = <span class="built_in">std</span>::<span class="built_in">strchr</span>(str, <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// strstr(str, sub), 查找子字符串sub在字符串str中的第一次出现。如果找到了，返回指向子字符串的指针；如果没找到，返回 nullptr。</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* sub = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="type">char</span>* ptr = <span class="built_in">std</span>::<span class="built_in">strstr</span>(str, sub);</span><br><span class="line"></span><br><span class="line"><span class="comment">// memset(str, c, n) 按字节为单位对内存初始化</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">memset</span>(str, <span class="string">&#x27;*&#x27;</span>, <span class="number">5</span>);  <span class="comment">// 将前 5 个字符设置为 &#x27;*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(dest, src, n) 从src拷贝n个字节到dest</span><br><span class="line"><span class="type">char</span> src[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> dest[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">memcpy</span>(dest, src, <span class="number">6</span>); </span><br></pre></td></tr></table></figure><p>C++ string是动态字符串，如果希望字符串不可变，可以使用const修饰。string支持的函数如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// size() 或 length() 获取字符串长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// append(string)，将内容追加</span></span><br><span class="line">std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">str.<span class="built_in">append</span>(<span class="string">&quot;, World!&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// push_back(c)，添加一个字符</span></span><br><span class="line">str.<span class="built_in">push_back</span>(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert(index, string), 指定位置插入字符串</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">5</span>, <span class="string">&quot;, World&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// erase(index, length), 删除指定位置区间的字符串</span></span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">5</span>, <span class="number">7</span>);  <span class="comment">// 从位置 5 开始删除 7 个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// replace(index, length, newstring), 替换字符串中的指定部分。</span></span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">7</span>, <span class="number">5</span>, <span class="string">&quot;C++&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// resize(size) 改变字符串的大小，如果增加字符则填充，减少字符则截断。</span></span><br><span class="line">str.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::find(string) 查找子字符串首次出现的位置。如果找不到返回 std::string::npos。rfind, 从字符串末尾向前查找字符串</span></span><br><span class="line"><span class="type">size_t</span> pos = str.<span class="built_in">find</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// find_first_of(),find_last_of()</span></span><br><span class="line"><span class="type">size_t</span> pos = str.<span class="built_in">find_first_of</span>(<span class="string">&quot;o&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// substr(index, length) 提取子字符串</span></span><br><span class="line">std::string sub = str.<span class="built_in">substr</span>(<span class="number">7</span>, <span class="number">5</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// compare 字符串比较</span></span><br><span class="line">std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">std::string str2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="type">int</span> result = str<span class="number">1.</span><span class="built_in">compare</span>(str2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// stoi(), stol(), stoll() 字符串转为整型</span></span><br><span class="line"><span class="type">int</span> num = std::<span class="built_in">stoi</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// to_string()，转为字符串</span></span><br><span class="line">std::string str = std::<span class="built_in">to_string</span>(num);</span><br><span class="line"></span><br><span class="line"><span class="comment">// c_str(), data() 返回 C 风格字符串（const char*）。</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cstr = str.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></figure><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><p>ArrayList，等于C++的vector，动态数组。JAVA的List是一个接口，包括动态数组和链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line">System.out.println(list);  <span class="comment">// 输出: [Apple, Banana, Cherry]</span></span><br></pre></td></tr></table></figure><p>LinkedList，双向链表，相当于C++的list</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>HashSet, 基于哈希表实现，不保证元素的顺序。</p><p>LinkedHashSet, 基于哈希表和链表实现，能够保证元素的插入顺序。</p><p>TreeSet, 基于红黑树实现，元素按自然顺序或自定义顺序排列。</p><p>HashMap，基于哈希表实现，允许 null 键和值。</p><p>LinkedHashMap，基于哈希表和链表实现，保持插入顺序（或访问顺序）</p><p>TreeMap，基于红黑树实现，键按自然顺序或自定义顺序排序。</p><p>PriorityQueue，基于堆实现的队列，元素按优先级顺序排列</p><p>LinkedList 也可以实现 Queue 接口，支持双端队列操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">queue.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">queue.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">queue.add(<span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line">System.out.println(queue.poll());  <span class="comment">// 输出: Apple（出队）</span></span><br><span class="line">System.out.println(queue);  <span class="comment">// 输出: [Banana, Cherry]</span></span><br></pre></td></tr></table></figure><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><p>Arrays.sort() 用于对数组进行排序，数组是基本类型数组<code>int[] arr </code>，或对象数组<code>new Integer[10]</code></p><p>Collections.sort() 用于对集合（如 List）进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);  <span class="comment">// 输出: [1, 2, 3, 5, 8]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Arrays.binarySearch()，数组查找；Collections.binarySearch()在容器查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearchExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Collections.binarySearch(list, <span class="number">5</span>);</span><br><span class="line">        System.out.println(index);  <span class="comment">// 输出: 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Arrays.fill(), Collections.fill() 填充</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    Collections.fill(list, <span class="number">10</span>);</span><br><span class="line">    System.out.println(list);  <span class="comment">// 输出: [10, 10, 10, 10, 10]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Collections.shuffle() 用于随机打乱 List 中元素的顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    Collections.shuffle(list);</span><br><span class="line">    System.out.println(list);  <span class="comment">// 输出: 随机打乱后的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 字符串字面量</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 使用构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// length() 获得长度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str.length();</span><br><span class="line"></span><br><span class="line">s.charAt(<span class="number">0</span>)  <span class="comment">// 访问字符</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(<span class="number">0</span>, <span class="number">5</span>);  <span class="comment">// 切片</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> s1 + <span class="string">&quot; &quot;</span> + s2;  <span class="comment">// 使用 + 拼接</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();  <span class="comment">// 利用StringBuilder</span></span><br><span class="line">sb.append(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">trimmed</span> <span class="operator">=</span> s.trim();  <span class="comment">// 去除两端空白字符</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> s.indexOf(<span class="string">&quot;World&quot;</span>);  <span class="comment">// 查找子字符串的索引位置</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">upper</span> <span class="operator">=</span> s.toUpperCase();  <span class="comment">// 转为大写</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">formatted</span> <span class="operator">=</span> String.format(<span class="string">&quot;My name is %s and I am %d years old.&quot;</span>, name, age);  <span class="comment">// 字符串格式化</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;apple,banana,cherry&quot;</span>;</span><br><span class="line">String[] fruits = s.split(<span class="string">&quot;,&quot;</span>);  <span class="comment">// 按逗号分割字符串</span></span><br></pre></td></tr></table></figure><p>JAVA的String是不可变的（String类被声明成final），String 字符串每次拼接都会创建新的对象。</p><p>StringBuilder 和 StringBuffer 是用于可变字符串的类。StringBuilder只能用于单线程环境，StringBuffer则是线程安全的。</p><p>修改字符串某位置的字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 字符串不可修改某位置字符，可以利用stringBuilder</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">sb.setCharAt(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">System.out.println(sb.toString());  <span class="comment">// 输出: Hallo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符数组可以修改某位置字符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>[] charArray = str.toCharArray();</span><br><span class="line">charArray[<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">modifiedStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line">System.out.println(modifiedStr);  <span class="comment">// 输出: Hallo</span></span><br></pre></td></tr></table></figure><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><h4 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h4><p>golang 用语言关键字提供了容器，不必额外导入包</p><p>数组, 固定大小的同一类型的元素。Go 数组的大小在声明时确定并且内容不可更改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="type">int</span> <span class="comment">// 定义一个长度为 5 的整型数组</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">fmt.Println(arr) <span class="comment">// 输出: [1 2 0 0 0]</span></span><br></pre></td></tr></table></figure><p>切片slice，动态数组。[]byte表示动态字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建切片</span></span><br><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>map，哈希表实现的容器，允许通过键来快速查找和存储值，无序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myMap := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">    <span class="string">&quot;apple&quot;</span>:  <span class="number">5</span>,</span><br><span class="line">    <span class="string">&quot;banana&quot;</span>: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入或更新元素</span></span><br><span class="line">myMap[<span class="string">&quot;orange&quot;</span>] = <span class="number">7</span></span><br></pre></td></tr></table></figure><p>链表，使用container&#x2F;list</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;container/list&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    l := list.New()</span><br><span class="line">    l.PushBack(<span class="number">1</span>) <span class="comment">// 在链表尾部插入</span></span><br><span class="line">    l.PushFront(<span class="number">0</span>) <span class="comment">// 在链表头部插入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> e := l.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">        fmt.Println(e.Value) <span class="comment">// 输出: 0 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>channel，channel可认为是一个线程安全的协程间消息&#x2F;任务队列</p><h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><p>排序，import “sort”标准库</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">numbers := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">sort.Ints(numbers) <span class="comment">// 排序，可以选择Ints, Strings, Stable等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型排序</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByAge []Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> a[i].Age &lt; a[j].Age &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Swap(i, j <span class="type">int</span>)      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">people := []Person&#123;</span><br><span class="line">&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">20</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort.Sort(ByAge(people)) <span class="comment">// 排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串处理函数-1"><a href="#字符串处理函数-1" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h4><p>Go中，string是不可变的 UTF-8 编码字符串, 无法原地修改字符串（编译失败）。[]byte是字符序列切片，可原地修改字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">b := []<span class="type">byte</span>(s) <span class="comment">// 将 string 转换为 []byte</span></span><br><span class="line"></span><br><span class="line">b := []<span class="type">byte</span>&#123;<span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>&#125;</span><br><span class="line">s := <span class="type">string</span>(b) <span class="comment">// 将 []byte 转换为 string</span></span><br></pre></td></tr></table></figure><p>字符串处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="built_in">len</span>(str)  <span class="comment">// 返回长度</span></span><br><span class="line">str[<span class="number">1</span>]  <span class="comment">// 根据索引查看字符</span></span><br><span class="line"></span><br><span class="line">str1 := <span class="string">&quot;Hello&quot;</span></span><br><span class="line">str2 := <span class="string">&quot;World&quot;</span></span><br><span class="line">result := str1 + <span class="string">&quot;, &quot;</span> + str2  <span class="comment">// + 拼接字符串</span></span><br><span class="line"></span><br><span class="line">strings.Index(str, <span class="string">&quot;World&quot;</span>)  <span class="comment">// 查找字符串</span></span><br><span class="line">strings.Contains(str, <span class="string">&quot;World&quot;</span>)</span><br><span class="line"></span><br><span class="line">strings.Split(str, <span class="string">&quot;,&quot;</span>)  <span class="comment">// 字符串分割，返回字符串数组</span></span><br><span class="line">strings.TrimSpace(str)  <span class="comment">// 去掉两侧空白</span></span><br><span class="line"></span><br><span class="line">strings.ToUpper(str)  <span class="comment">// 字符串大小写</span></span><br><span class="line">strings.ToLower(str)</span><br><span class="line"></span><br><span class="line">strings.HasPrefix(str, <span class="string">&quot;go&quot;</span>)  <span class="comment">// 字符串前后缀</span></span><br><span class="line">strings.HasSuffix(str, <span class="string">&quot;.org&quot;</span>)</span><br><span class="line"></span><br><span class="line">result := fmt.Sprintf(<span class="string">&quot;Name: %s, Age: %d&quot;</span>, name, age) <span class="comment">// 格式化生成字符串</span></span><br><span class="line"></span><br><span class="line">strconv.Atoi(numStr) <span class="comment">// 字符串转整数</span></span><br></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><h4 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h4><p>列表，动态数组。和go一样，python列表支持切片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">my_list[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">my_list.append(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>元组Tuple，不可变，只可被访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">a, b, c = my_tuple</span><br></pre></td></tr></table></figure><p>字典dict, 无序（Python 3.7 及以上版本中插入有序）、键值对、键唯一</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_dict = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>&#125;</span><br><span class="line">my_dict[<span class="string">&quot;age&quot;</span>] = <span class="number">30</span></span><br></pre></td></tr></table></figure><p>集合set，无序、不重复。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">my_set.add(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>有序字典, 保留键值对插入顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">ordered_dict = OrderedDict()</span><br><span class="line">ordered_dict[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">ordered_dict[<span class="string">&quot;b&quot;</span>] = <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h4><p>排序</p><p>sorted(iterable, key&#x3D;None, reverse&#x3D;False), 返回一个新的排序列表，不改变原列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(nums))  <span class="comment"># 升序: [1, 2, 5, 9]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(nums, reverse=<span class="literal">True</span>))  <span class="comment"># 降序: [9, 5, 2, 1]</span></span><br><span class="line"></span><br><span class="line">words = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(words, key=<span class="built_in">len</span>))  <span class="comment"># 按字符串长度排序: [&#x27;apple&#x27;, &#x27;cherry&#x27;, &#x27;banana&#x27;]</span></span><br></pre></td></tr></table></figure><p>list.sort(), 原地排序，直接修改列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>]</span><br><span class="line">nums.sort()</span><br></pre></td></tr></table></figure><p>字典排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_dict = &#123;<span class="string">&quot;b&quot;</span>: <span class="number">2</span>, <span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;c&quot;</span>: <span class="number">3</span>&#125;</span><br><span class="line">sorted_keys = <span class="built_in">sorted</span>(my_dict)  <span class="comment"># 按键排序</span></span><br><span class="line">sorted_items = <span class="built_in">sorted</span>(my_dict.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>])  <span class="comment"># 按值排序</span></span><br></pre></td></tr></table></figure><h4 id="字符串处理-1"><a href="#字符串处理-1" class="headerlink" title="字符串处理"></a>字符串处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="built_in">len</span>(s)</span><br><span class="line">s[<span class="number">1</span>]</span><br><span class="line">s[-<span class="number">1</span>]</span><br><span class="line">s[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">s + <span class="string">&quot; &quot;</span>  <span class="comment"># 拼接</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;My name is <span class="subst">&#123;name&#125;</span> and I am <span class="subst">&#123;age&#125;</span> years old.&quot;</span>)  <span class="comment"># 格式化输出, python3支持</span></span><br><span class="line">s.upper()，s.lower()</span><br><span class="line">s.strip()  <span class="comment"># 去除空格</span></span><br><span class="line">s.find(<span class="string">&quot;World&quot;</span>)</span><br><span class="line">s.replace(<span class="string">&quot;World&quot;</span>, <span class="string">&quot;Python&quot;</span>)</span><br><span class="line"></span><br><span class="line">s.split(<span class="string">&quot;,&quot;</span>)</span><br></pre></td></tr></table></figure><p>对于python2, 还有个编码的问题。处理办法是，对于u开头的字符串或者unicode类型的字符串，都使用encode(“utf-8”) 编码为str类型后，再使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line">unicode_str = <span class="string">u&quot;中文&quot;</span>  <span class="comment"># Unicode 字符串</span></span><br><span class="line">byte_str = <span class="string">&quot;byte&quot;</span>  <span class="comment"># 字节字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(unicode_str))  <span class="comment"># &lt;type &#x27;unicode&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(byte_str))  <span class="comment"># &lt;type &#x27;str&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(unicode_str.encode(<span class="string">&quot;utf-8&quot;</span>)))  <span class="comment"># &lt;type &#x27;str&#x27;&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;数据结构和算法库是程序编写最基础的库之一。字符串是人类语言的记录，是计算机处理的主要对象，因此字符串数据和算法是重中之重。&lt;/p&gt;</summary>
    
    
    
    <category term="base" scheme="https://larrystd.github.io/categories/base/"/>
    
    
    <category term="language" scheme="https://larrystd.github.io/tags/language/"/>
    
  </entry>
  
  <entry>
    <title>编程语言(3)—变量和作用域</title>
    <link href="https://larrystd.github.io/2025/01/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(3)%E2%80%94%E5%8F%98%E9%87%8F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>https://larrystd.github.io/2025/01/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(3)%E2%80%94%E5%8F%98%E9%87%8F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/</id>
    <published>2024-12-31T16:00:00.000Z</published>
    <updated>2025-01-04T01:15:55.916Z</updated>
    
    <content type="html"><![CDATA[<p>对于静态语言，类型是编译期确定的。变量在运行期，有创建、初始化、使用、销毁四个生命周期状态。</p><span id="more"></span><h3 id="C语言和C"><a href="#C语言和C" class="headerlink" title="C语言和C++"></a>C语言和C++</h3><h4 id="变量创建和销毁"><a href="#变量创建和销毁" class="headerlink" title="变量创建和销毁"></a>变量创建和销毁</h4><p>运行期局部变量在栈上创建，全局变量和静态变量在静态区创建，new 产生的变量在堆上创建。栈变量的作用域等于函数作用域，全局变量和静态变量的作用域是进程执行期，new产生的堆变量可能逃逸，需要用户自行管理生命周期和内存释放。<strong>堆变量内存未释放会导致内粗泄露，内存重复释放会导致进程崩溃。</strong></p><p>为了避免堆变量的遗忘释放或重复释放，C++标准库提供智能指针帮助管理对象的释放。原则上C++一切堆变量都应该使用智能指针。</p><ol><li>std::unique_ptr，独占所有权，不可复制，只能移动。</li><li>std::shared_ptr，共享所有权，使用引用计数（reference count）管理资源的释放。</li><li>std::weak_ptr，弱引用，不增加引用计数；依赖于 std::shared_ptr，用于解决循环引用问题</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; *ptr1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;int&gt; ptr2 = ptr1;                  // 错误：不能复制</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = std::<span class="built_in">move</span>(ptr1);          <span class="comment">// 转移所有权</span></span><br><span class="line">    std::cout &lt;&lt; *ptr2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sp = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">30</span>);</span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; wp = sp;                          <span class="comment">// 创建weak_ptr</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Use count: &quot;</span> &lt;&lt; sp.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> sp2 = wp.<span class="built_in">lock</span>()) &#123;                           <span class="comment">// 检weak_ptr检查资源是否有效</span></span><br><span class="line">        std::cout &lt;&lt; *sp2 &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp.<span class="built_in">reset</span>();                                           <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (wp.<span class="built_in">lock</span>() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resource no longer exists&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">Use count: <span class="number">1</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line">Resource no longer exists</span><br></pre></td></tr></table></figure><h4 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h4><ol><li>局部变量，未初始化的为不确定值（即垃圾值）</li><li>静态变量，自动初始化为 0 或 NULL（指针类型），静态变量初始化只执行一次</li><li>全局变量，自动初始化为 0 或 NULL</li></ol><p>C++类变量规则</p><ol><li>普通成员变量, 必须在构造函数中显式初始化，未初始化的普通成员变量值是未定义的（包含随机值）</li><li>静态成员变量是类级别的，需要在类外初始化，自动初始化为 0 或 NULL（指针类型），静态变量初始化只执行一次</li><li>const变量必须在构造函数的初始化列表中初始化，初始化后不可修改</li><li>C++11 允许为 非静态成员变量 提供类内初始值。<strong>静态成员变量仍需在类外初始化。</strong></li><li>成员变量按 声明的顺序 初始化，与初始化列表的顺序无关。</li></ol><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>全局变量跨.cpp文件，链接多文件共享；静态变量只能被当前.cpp文件访问；局部变量作用域为函数；类成员变量需要在类内或对象中访问，随着对象的销毁而销毁。</p><h4 id="变量修饰"><a href="#变量修饰" class="headerlink" title="变量修饰"></a>变量修饰</h4><p>static, 静态变量</p><p>const，表示常量，不可改变量。修饰函数表示函数不可能修改类成员变量</p><p>volatile，告诉编译器不要对该变量进行优化。常用于 多线程编程 或 硬件编程，避免编译器对变量的访问进行优化。</p><p>extern，声明变量或函数在其他文件中定义。它不分配存储空间，只是告诉编译器该变量在其他地方定义过。链接时全局变量在多个文件共享。</p><p>mutable 用来修饰类中的成员变量，即使类的对象是 const 类型，成员变量仍然可以被修改。</p><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><p><strong>JAVA所有变量和函数都是写到类</strong>中，类名和文件名相同。main函数是在主类中定义的static函数。JAVA没有全局变量，因为所有变量都是在类中。</p><p>JAVA基本类型变量存储在栈中，引用类型变量存储在堆中。引用类型变量使用new创建，jvm的垃圾回收模块负责对象回收。</p><p>JAVA的变量都会初始化，不会有随机值。</p><p>类静态变量和静态模块随着类加载而初始化和执行，<strong>如果某类无须被加载，则不会执行该类中的静态变量和静态块。</strong></p><ol><li>类的加载通常是在访问类的静态成员（如静态字段、静态方法）或创建类的实例时触发的。</li><li>类加载器会在需要时加载类，不会提前加载。</li></ol><h4 id="变量访问控制"><a href="#变量访问控制" class="headerlink" title="变量访问控制"></a>变量访问控制</h4><p>Java中，如果需要使用其他包中的类，必须利用import显式地导入它们。import 语句只能导入类，而不能导入方法、字段</p><p>Java 的访问控制包括四种权限：</p><ol><li>public：类或成员可以被任何类访问。</li><li>protected：类或成员可以被同一个包中的类或子类访问。</li><li>default（无修饰符）：类或成员只能被同一个包中的类访问。</li><li>private：类或成员只能在当前类内部访问。</li></ol><p>包名通常采用 小写字母，以避免与类名的命名冲突。</p><p>包名通常使用 反向域名，例如 com.example.myapp。这种做法避免了不同公司或组织的包名冲突。</p><h4 id="变量修饰-1"><a href="#变量修饰-1" class="headerlink" title="变量修饰"></a>变量修饰</h4><p>除了类，java的变量和函数也有访问修饰符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public：变量可以被任何其他类访问，无论它们在同一包中还是不同的包中。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> x;</span><br><span class="line"><span class="comment">// protected：变量可以被同一包中的类或继承自该类的子类访问</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> y;</span><br><span class="line"><span class="comment">// default（无修饰符）：变量的默认访问权限是包级访问（包私有）。</span></span><br><span class="line"><span class="type">int</span> z; </span><br><span class="line"><span class="comment">// private：变量只能在当前类内部访问</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> a;</span><br></pre></td></tr></table></figure><p>static，声明为 static 为静态变量，属于类。</p><p>final，声明为 final 的变量是常量，初始化之后不能再修改。final修饰函数表示该函数不能被重写</p><p>volatile 变量会告诉 Java 虚拟机（JVM）每次访问该变量时都要从内存中读取，而不是从缓存中读取。它通常用于多线程编程中，确保变量的可见性。</p><p>synchronized 主要用于方法，确保同一时刻只有一个线程能执行该方法。</p><p>native 关键字用于声明本地方法，这些方法通过 JNI（Java Native Interface）调用非 Java 语言（如 C、C++）编写的代码。native通常用于方法声明。</p><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p>栈变量指局部变量、以及值语义的数据结构(int, float, bool, struct)。当变量的生命周期仅限于当前函数时，Go 会尽量将其分配到栈上。</p><p>堆内存，通常分配给引用类型(slice, map, channel, pointer)或者使用new创建变量且变量的地址被传递到函数外部。</p><p>Go 变量的访问控制。全局定义的小写字母只能包内访问，大写字母可以跨包访问。访问其他包的变量需要先import。</p><p>堆分配的变量由GC的垃圾回收模块负责回收。</p><p>Go变量相关的关键字，</p><ol><li>var：声明变量</li><li>:&#x3D;：简短声明变量</li><li>const：声明常量</li></ol><p>Go不提供继承，不提供静态变量</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>Python的变量有自己的特别之处，比如，<strong>Python局部变量区域可以访问全局变量，但无法修改全局变量</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>():</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">my_function()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>():</span><br><span class="line">    <span class="comment"># 修改全局变量需要在局部变量区加 global x</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    x=<span class="number">20</span></span><br><span class="line"></span><br><span class="line">my_function()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">UnboundLocalError: local variable <span class="string">&#x27;x&#x27;</span> referenced before assignment</span><br></pre></td></tr></table></figure><p><code>if __name__ == &quot;__main__&quot;</code>函数里可以正常修改全局变量（其余函数不行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>():</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    x=<span class="number">20</span></span><br><span class="line">    my_function()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><p>python无法对变量进行修饰，但可以通过@注解对函数进行修饰。例如@staticmethod，@classmethod</p><p>常见@注解</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@classmethod 装饰器定义类方法，允许方法访问类本身，而不是实例。</span><br><span class="line">@staticmethod 装饰器定义静态方法，静态方法不能访问实例和类本身</span><br><span class="line">@property 用于将类的方法变成一个只读属性</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于静态语言，类型是编译期确定的。变量在运行期，有创建、初始化、使用、销毁四个生命周期状态。&lt;/p&gt;</summary>
    
    
    
    <category term="base" scheme="https://larrystd.github.io/categories/base/"/>
    
    
    <category term="language" scheme="https://larrystd.github.io/tags/language/"/>
    
  </entry>
  
  <entry>
    <title>编程语言(2)—类型和运算符</title>
    <link href="https://larrystd.github.io/2024/12/30/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(2)%E2%80%94%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://larrystd.github.io/2024/12/30/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(2)%E2%80%94%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2024-12-29T16:00:00.000Z</published>
    <updated>2025-01-04T01:15:44.956Z</updated>
    
    <content type="html"><![CDATA[<p>程序&#x3D;数据+计算。类型确定了数据的定义、数据支持的计算。是程序的基础。</p><p>概要介绍C、C++、JAVA、Go、Python的数据类型和运算符。</p><span id="more"></span><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><p>C语言类型主要有整型Integer，浮点型Floating Point，字符型Character，枚举类型Enumeration，数组Array，指针Pointer，结构体Structure，共用体Union，空类型void</p><p>C 语言支持的运算符，按优先级从高到低排列</p><ol><li><code>() [] -&gt; .</code>，括号、数组下标、成员访问</li><li><code>! ~ ++ -- - +</code>，逻辑非、按位取反、自增、自减、取负、正号; <code>* &amp; (type) sizeof</code> 解引用、取地址、类型转换、大小计算</li><li><code>* / %</code> 乘法、除法、取模</li><li><code>+ -</code>加法、减法</li><li><code>&lt;&lt; &gt;&gt;</code>左移、右移</li><li><code>&lt; &lt;= &gt; &gt;=</code>小于、小于等于、大于、大于等于</li><li><code>== !=</code>等于、不等于</li><li><code>&amp;</code> 按位与</li><li><code>^</code>按位异或</li><li><code>|</code> 按位或</li><li><code>&amp;&amp;</code> 逻辑与</li><li><code>||</code> 逻辑或</li><li><code>?:</code> </li><li><code>= += -= *= /= %= &lt;&lt;= &gt;&gt;= &amp;= ^=</code> 赋值及复合赋值</li><li><code>,</code> 逗号</li></ol><h4 id="具体类型"><a href="#具体类型" class="headerlink" title="具体类型"></a>具体类型</h4><p>整型，整型几乎支持所有运算，包括加减乘除算数运算，左移右移，大于等于比较运算，按位运算，逻辑运算(0表示false，其余整型表示true)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="comment">//基本整型，4字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">short</span> <span class="type">int</span>  <span class="comment">// 短整型，2字节</span></span><br><span class="line"><span class="type">short</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">int</span>  <span class="comment">// 长整型，8字节。</span></span><br><span class="line"><span class="type">long</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="comment">// 无符号整型，即正整数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x %x \n&quot;</span>, a&amp;b, a|b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x %x \n&quot;</span>, a&amp;&amp;b, a||b);</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">0</span> f </span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>浮点型，<strong>浮点型不支持左移右移、按位运算</strong>。支持算术、逻辑、比较运算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span>  <span class="comment">// 单精度浮点型，4字节。</span></span><br><span class="line"><span class="type">double</span>  <span class="comment">// 双精度浮点型，8字节。</span></span><br></pre></td></tr></table></figure><p>字符型，<strong>字符型实际等于8位无符号整型</strong>，整数支持的运算它都支持，运算等价于ACCSI码整数运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>  <span class="comment">// 字符型，1字节，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用整数定义char</span></span><br><span class="line"><span class="type">char</span> c = <span class="number">68</span>; </span><br></pre></td></tr></table></figure><p>枚举类型，C语言的枚举类型同样等价于整型，整数支持的运算它都支持</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;RED, GREEN, BLUE&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED = <span class="number">10</span>,    </span><br><span class="line">    GREEN,  </span><br><span class="line">    BLUE </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Color</span> Color1 = RED;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Color</span> Color2 = GREEN;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, Color1, Color2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, Color1||Color2, Color1|Color2, Color1&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">10</span> <span class="number">11</span></span><br><span class="line"><span class="number">1</span> <span class="number">11</span> <span class="number">40</span></span><br></pre></td></tr></table></figure><p>数组，数组本身支持<code>[index]</code>索引查询。另外，数组名相当于数组第一个元素的地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr1[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr2[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr3[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, arr1[<span class="number">0</span>], arr2[<span class="number">1</span>], arr3[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x %d %d\n&quot;</span>, arr1, *arr1, *(arr1<span class="number">+2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span>d941bd0 <span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>指针，指针本身是一个64位的整型。但<strong>不支持乘除、移位、按位运算</strong>。支持加减，逻辑运算。当然还支持<code>*</code>解引用运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br></pre></td></tr></table></figure><p>结构体, 结构体支持使用<code>.</code>找到成员变量, 结构体指针则使用<code>-&gt;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>共用体，共享内存。共用体的size是size最大的成员变量的size。共用体运算同结构体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>void类型, 主要应用于void指针。void指针支持加减，逻辑运算。但不支持<code>*</code>解引用运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *ptr;</span><br></pre></td></tr></table></figure><p>函数指针。函数指针除了支持指针运算，还支持使用<code>()</code>执行函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个函数指针，指向返回 int，接收两个 int 参数的函数</span></span><br><span class="line">    <span class="built_in">int</span> (*func_ptr)(<span class="type">int</span>, <span class="type">int</span>) = add;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, *func_ptr);</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">func_ptr</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">182948169</span></span><br><span class="line">Result: <span class="number">30</span></span><br></pre></td></tr></table></figure><h4 id="转型"><a href="#转型" class="headerlink" title="转型"></a>转型</h4><p>C语言支持隐式转型和强制转型。强制转型和隐式转型都发生在编译期。</p><p><strong>C语言运算符的两侧必须是相同类型，如果不是，就会发生隐式转型</strong>。隐式转型规则，隐式转型主要针对整型和浮点型。隐式转型规则是size小的转为size大的，例如char转为int，int 转换为 unsigned&#x2F;float, float 转换为 double</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">-2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, (i + j) &gt;= <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出.原因，在执行(i + j)时，i转为unsigned int再和j加。0在这里转成了unsigned int</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>C语言的转型很复杂，比如下面的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">-2</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ((<span class="type">int</span>)i + (<span class="type">int</span>)j) &gt;= <span class="number">0</span> );  <span class="comment">// 输出0</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ((<span class="type">int</span>)i + j) &gt;= <span class="number">0</span> );  <span class="comment">// 输出1</span></span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>C++兼容C语言的类型、操作符和转型，另外，还支持类定义和类重载运算符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> a = <span class="number">0</span>, <span class="type">int</span> b = <span class="number">0</span>) : <span class="built_in">x</span>(a), <span class="built_in">y</span>(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载赋值运算符</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Point&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> x == other.y &amp;&amp; x == other.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载输出运算符</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Point&amp; p) &#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载加法运算符</span></span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="type">const</span> Point&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(x + other.y, x + other.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">1</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; p1 &lt;&lt; std::endl;  <span class="comment">// 输出：(3, 4)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p1==p2);</span><br><span class="line">    Point p3 = p1 + p2;</span><br><span class="line">    std::cout &lt;&lt; p3 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line">(<span class="number">7</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>C++ 支持bool型，bool型基本等同于1bit的整型，支持加减、移位等运算符，默认false(0)</p><p>C语言只能通过malloc申请进程堆内存，把地址给指针，并通过free释放内存。C++提供了new关键字在堆内存创建对象，new后面可以跟int, float, char, 数组等基本类型，也可以跟自定义类型。对应的释放关键字是delete。</p><p>在值和指针类型之上，C++增加了引用类型。引用必须在定义的同时初始化，对引用的修改等价于对原值的修改。引用可作为参数和函数返回值（如果函数内部创建的对象，返回的对引用无效）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> &amp;ref = a;</span><br><span class="line">    ref = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>&amp;b = <span class="built_in">func</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure><p>在C语言的隐式和显示转换之上，C++还增加了四个显示类型转换</p><ol><li>static_cast，编译期间类型转换，基于类型信息</li><li>dynamic_cast，运行时多态向下转型</li><li>const_cast，修改本不可变的const对象</li><li>reinterpret_cast，等价于指针强制转换</li></ol><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><p>JAVA运算符基本和C++一致，除了</p><ol><li>取消指针和引用相关运算符，包括<code>*</code>, <code>-&gt;</code>, <code>&amp;</code></li></ol><p>JAVA类型默认值是0, JAVA的boolean型不再和整型互通</p><p><strong>基本数据类型</strong>, 存储值本身</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">数据类型存储大小（字节）</span><br><span class="line"><span class="type">byte</span><span class="number">1</span></span><br><span class="line"><span class="type">short</span><span class="number">2</span></span><br><span class="line"><span class="type">int</span>    <span class="number">4</span></span><br><span class="line"><span class="type">long</span><span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span><span class="number">4</span></span><br><span class="line"><span class="type">double</span><span class="number">8</span></span><br><span class="line"><span class="type">char</span><span class="number">2</span> (unicode范围)</span><br><span class="line"><span class="type">boolean</span>依赖 JVM 实现</span><br></pre></td></tr></table></figure><p><strong>引用类型</strong>, 存储对象的引用。引用类型默认值是null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED, GREEN, BLUE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JAVA提供包装类型为基本数据类型提供引用, 默认值是null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">基本数据类型包装类型</span><br><span class="line"><span class="type">byte</span>Byte</span><br><span class="line"><span class="type">short</span>Short</span><br><span class="line"><span class="type">int</span>Integer</span><br><span class="line"><span class="type">long</span>Long</span><br><span class="line"><span class="type">float</span>Float</span><br><span class="line"><span class="type">double</span>Double</span><br><span class="line"><span class="type">char</span>Character</span><br><span class="line"><span class="type">boolean</span>Boolean</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      System.out.println(x.compareTo(y));</span><br><span class="line">      System.out.println(x.equals(y));</span><br><span class="line">      System.out.println(z==<span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>JAVA包装类型的常用函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类静态方法</span></span><br><span class="line">Integer.valueOf(<span class="type">int</span> i) <span class="comment">// 返回表示指定值的 Integer 实例（缓存范围内重用对象）</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例方法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">intValue</span><span class="params">()</span>  <span class="comment">// 返回包装对象的 int 值, 同样还有doubleValue等</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x.intValue();  <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Integer anotherInteger)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">System.out.println(x.compareTo(y));</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>  <span class="comment">// 比较两个对象的值是否相等。</span></span><br></pre></td></tr></table></figure><p>JAVA提供隐式转换和显示转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> dog;  <span class="comment">// 子类对象自动转换为父类引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal;  <span class="comment">// 强制将父类引用转换为子类类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// instanceof 关键字检查对象是否是某个类型, 用于向下转型</span></span><br><span class="line"><span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JAVA中，所有类都直接或间接继承自 Object 类。Object类提供的成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br></pre></td></tr></table></figure><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p>Golang的运算符和C++的也类似，区别在于</p><ol><li>指针类型不支持算术运算，只支持引用和解引用运算。指针的零值是nil。golang使用 new 分配内存，并返回指针。指针对象引用成员变量也用<code>.</code></li></ol><p>golang支持的类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">类型长度(字节)</span><br><span class="line"><span class="comment">// 以下是值类型</span></span><br><span class="line"><span class="type">bool</span><span class="number">1</span></span><br><span class="line"><span class="type">byte</span><span class="number">1</span></span><br><span class="line"><span class="type">int32</span>, <span class="type">uint32</span><span class="number">4</span></span><br><span class="line"><span class="type">int64</span>, <span class="type">uint64</span><span class="number">8</span></span><br><span class="line"><span class="type">float32</span><span class="number">4</span></span><br><span class="line"><span class="type">float64</span> <span class="number">8</span></span><br><span class="line">array</span><br><span class="line"><span class="keyword">struct</span></span><br><span class="line"><span class="type">string</span>（字符串如果想要修改，需要转成[]<span class="type">byte</span>类型）</span><br><span class="line"></span><br><span class="line">，默认值是<span class="literal">nil</span></span><br><span class="line">slice, 例如[]<span class="type">byte</span></span><br><span class="line"><span class="keyword">map</span></span><br><span class="line">channel</span><br><span class="line"><span class="keyword">interface</span></span><br><span class="line">function</span><br></pre></td></tr></table></figure><p>Go中只有强制类型转换，没有隐式类型转换。<code>a:=(int)(xxx)</code>。另外, golang支持类型断言将接口转换为其具体类型。<code>对象.(类型)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="number">42</span> <span class="comment">// 接口存储了具体类型 int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型断言</span></span><br><span class="line">    value, ok := i.(<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Converted value:&quot;</span>, value) <span class="comment">// 输出：Converted value: 42</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Conversion failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Golang中，所有struct都实现<code>interface&#123;&#125;</code>空接口</p><h4 id="golang-运行时类型信息"><a href="#golang-运行时类型信息" class="headerlink" title="golang 运行时类型信息"></a>golang 运行时类型信息</h4><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>相比以上的强类型语言，python的操作符比较特殊。按照优先级排序为</p><ol><li>小括号<code>()</code></li><li>索引运算符 <code>x[i] 或 x[i1: i2 [:i3]]</code></li><li>属性访问 <code>x.attribute</code></li><li>乘方 <code>**</code></li><li>按位取反 <code>~</code></li><li>符号运算符 <code>+（正号）、-（负号）</code></li><li>乘除<code>*、/、//、%</code></li><li>加减<code>+、-</code></li><li>位移<code>&gt;&gt;、&lt;&lt;</code></li><li>按位与 <code>&amp;</code></li><li>按位异或<code>^</code></li><li>按位或<code>|</code></li><li>比较运算符<code>==、!=、&gt;、&gt;=、&lt;、&lt;=</code></li><li>is 运算符<code>is、is not</code></li><li>in 运算符 <code>in、not in</code></li><li>逻辑非 <code>not</code></li><li>逻辑与 <code>and</code></li><li>逻辑或 <code>or</code></li><li>逗号<code>exp1, exp2</code></li></ol><p>Python的类型如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">类型描述</span><br><span class="line"><span class="built_in">int</span>整型 支持任意大小</span><br><span class="line"><span class="built_in">float</span>浮点数</span><br><span class="line"><span class="built_in">complex</span>复数，形式为 a + bj</span><br><span class="line"><span class="built_in">bool</span>布尔值，<span class="literal">True</span> 和 <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span>Unicode 文本数据</span><br><span class="line">NoneType<span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>可变的有序集合  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">tuple</span>不可变的有序集合  (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">range</span>表示数字范围<span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>可变集合，支持哈希操作&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">dict</span>可变键值对集合&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">iterator迭代器<span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p><strong>Python变量的类型是在运行时决定的，不需要显式声明。Python 不允许隐式类型转换。</strong></p><p>类型检查</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">42</span>))  <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="number">42</span>, <span class="built_in">int</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>python类型转换也非常灵活</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">int</span>(<span class="number">3.5</span>)   <span class="comment"># 3</span></span><br><span class="line">y = <span class="built_in">float</span>(<span class="number">3</span>)   <span class="comment"># 3.0</span></span><br><span class="line"></span><br><span class="line">lst = <span class="built_in">list</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))       <span class="comment"># [1, 2, 3]</span></span><br><span class="line">tpl = <span class="built_in">tuple</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])      <span class="comment"># (1, 2, 3)</span></span><br><span class="line">st = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>])      <span class="comment"># &#123;1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure><p>类似JAVA，在python中，object是所有类的基类。object类的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__init__(<span class="variable language_">self</span>)初始化方法，用于对象创建后初始化属性。</span><br><span class="line">__del__(<span class="variable language_">self</span>)析构方法，用于对象销毁时清理资源。</span><br><span class="line">__str__(<span class="variable language_">self</span>)返回对象的字符串表示，通常用于打印或转换为字符串时调用。</span><br><span class="line">__repr__(<span class="variable language_">self</span>)返回对象的官方表示，通常用于调试。</span><br><span class="line">__eq__(<span class="variable language_">self</span>, other)比较对象是否相等，默认比较引用地址，可重写实现值比较。</span><br><span class="line">__ne__(<span class="variable language_">self</span>, other)比较对象是否不等，默认基于 __eq__ 结果。</span><br><span class="line">__hash__(<span class="variable language_">self</span>)返回对象的哈希值，用于哈希表等数据结构。</span><br><span class="line">__getattribute__(<span class="variable language_">self</span>, name)获取对象属性的值，所有属性访问都会调用此方法，可重写以自定义行为。</span><br><span class="line">__setattr__(<span class="variable language_">self</span>, name, value)设置对象属性的值。</span><br><span class="line">__delattr__(<span class="variable language_">self</span>, name)删除对象属性。</span><br><span class="line">__dir__(<span class="variable language_">self</span>)返回对象的属性和方法列表，供 <span class="built_in">dir</span>() 函数使用。</span><br><span class="line">__class__返回对象的类。</span><br></pre></td></tr></table></figure><h4 id="Python对象和传值-引用"><a href="#Python对象和传值-引用" class="headerlink" title="Python对象和传值&#x2F;引用"></a>Python对象和传值&#x2F;引用</h4><p>python类型分为两类，可变类型和不可变类型。<strong>如果修改一个不可变对象，Python 将会创建一个新的对象</strong>。不可变对象包括整数（int）、浮点数（float）、字符串（str）、元组（tuple）等。</p><p>可变变量的值可以原地修改。可变对象包括列表（list）、字典（dict）、集合（set）等。</p><p>不可变对象作为函数参数，无法在函数内部改变不可变对象的值，相当于传对象拷贝。可变对象作为参数，函数内部修改可变对象的内容会影响外部变量，相当于传引用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">modify</span>(<span class="params">x</span>):</span><br><span class="line">    x = <span class="number">10</span></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line">modify(a)</span><br><span class="line"><span class="built_in">print</span>(a)  </span><br><span class="line"><span class="comment"># 输出：5，a的值未变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modify</span>(<span class="params">lst</span>):</span><br><span class="line">    lst.append(<span class="number">4</span>)</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">modify(nums)</span><br><span class="line"><span class="built_in">print</span>(nums)  </span><br><span class="line"><span class="comment"># 输出：[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;程序&amp;#x3D;数据+计算。类型确定了数据的定义、数据支持的计算。是程序的基础。&lt;/p&gt;
&lt;p&gt;概要介绍C、C++、JAVA、Go、Python的数据类型和运算符。&lt;/p&gt;</summary>
    
    
    
    <category term="base" scheme="https://larrystd.github.io/categories/base/"/>
    
    
    <category term="language" scheme="https://larrystd.github.io/tags/language/"/>
    
  </entry>
  
  <entry>
    <title>编程语言(1)—概览</title>
    <link href="https://larrystd.github.io/2024/12/25/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(1)%E2%80%94%E6%A6%82%E8%A7%88/"/>
    <id>https://larrystd.github.io/2024/12/25/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(1)%E2%80%94%E6%A6%82%E8%A7%88/</id>
    <published>2024-12-24T16:00:00.000Z</published>
    <updated>2025-01-04T01:15:35.928Z</updated>
    
    <content type="html"><![CDATA[<p>简谈C、C++、JAVA、Go、Python、Rust编程语言</p><span id="more"></span><p>C语言的特点</p><ol><li>原生的linux系统调用，linux系统就是C开发的，提供的系统调用是C语言函数接口。使用C语言开发的程序原生的可以利用操作系统提供的系统调用接口，执行进程管理、IO等操作。也正是由于C语言支持原生的系统调用，让C语言称为最好的linux系统二次开发语言。glibc，pthread等基础库都是C语言开发。</li><li>高自由度的指针来操纵内存。程序的指令、对象、数据本质就是排列的一段内存。通过操纵内存可以实现1. 数据零拷贝，高性能 2. 对象随意转型，随意引用对象的子变量 3. 函数类型指针。高灵活度提高了编写优秀C语言代码的难度。 </li><li>原生支持嵌入汇编语言。使用汇编语言能直接操纵CPU和寄存器，能不经由系统调用写出高性能的指令，例如设置CPU屏蔽中断。</li><li>C语言缺点也很明显，没有封装，标准库功能少。</li></ol><p>C++语言的特点</p><ol><li>兼容C语言，好处是具备C语言兼容系统调用、高性能指针等特点，缺点是C++实际没有禁止高自由度代码。兼容C语言的后果是, C++的一切规则都不是强制的规则，例如C++提供了智能指针，但程序员完全可以用写C的样子写C++，裸指针满天飞。C++空有一堆规范，但不要求强制遵守的规范很难起到效果。<a href="https://github.com/isocpp/CppCoreGuidelines">CppCoreGuidelines</a></li><li>C++ 类支持public、protected、private封装，继承，以及基于虚函数的多态。C++利用类的虚函数表和实例的虚函数指针实现了多态。C++ 还利用namespace 实现简单的包隔离。</li><li>包管理工具几乎没有。C++有cmake，bazel等较通用的编译工具，但至今没有通用的包管理工具。这是影响C++开发效率的重要原因，编译运行一个C++项目总是要在模块依赖上耗费大量时间。</li><li>标准库功能少。C++标准库主要有数据结构和算法库（STL）、标准IO库（基本没人用）、线程和同步库、智能指针库。没有常用的网络库、高级并发库（线程池，异步IO）、字符串处理库、文件系统IO库。这同样增加了C++开发的难度，重复造轮子现象严重。</li></ol><p>我不太推荐使用C++开发大型项目，即使C++项目有较高的编码规范要求，但开发期间如果项目周期缩短，“下周上线”、“能用就行”，那程序员会充分利用C++的“自由”，代码质量基本不能看了。对于把代码规范和安全交给程序员还是编译器的问题，我选择交给编译器。C++孱弱的包管理工具也让C++工程一旦开发完毕，后续的重构升级都很困难，“牵一发而动全身”。</p><p>JAVA语言的特点</p><ol><li>语言层对C++进行了扬弃，取消了指针，不需要手动管理内存。提供了全面的基础库，java.lang提供了字符串和线程类，java.util提供了容器类，java.io和java.nio提供了文件IO类，java.net提供网络类， java.util.concurrent提供并发编程支持。JAVA的基础库全面而有效，JAVA基础库的重复造轮子现象远远少于C++。</li><li>JAVA类函数默认所有实例方法都是虚函数，支持多态，final、static、private方法除外。但滥用虚函数会带来性能开销。</li><li>反射和spring框架提供了JAVA对象集中管理的能力，即所谓的控制反转。spring框架强制让程序员按照模块化，将不同的功能模块切分（AOP，面向切面编程）。JAVA程序员无须管理对象的创建（生命周期），专注于如何将分散在各个业务逻辑代码中相同的代码通过横向切割的方式抽取到一个独立的模块中。依赖框架的缺点也很明显，缺乏灵活性。</li><li>主要缺点是配置文件复杂，maven作为包管理工具配置比较复杂（可用gradle代替）。</li></ol><p>Go语言的特点</p><ol><li>语言实现对JAVA进行了扬弃，舍弃了public，protect, private封装只支持package封装，舍弃了继承用组合代替，扩展了并发库语言原生支持协程、广泛使用context、channel进行协程间通信，支持指针但不支持指针运算，重新定义了接口（只要struct实现了接口的所有方法，那就认为它实现了接口），采用默认规则（文件名以 _test.go 结尾的文件被认为是测试文件，以大写字母开头的标识符包外可见、小写包外不可见，提供 gofmt 工具统一代码格式）</li><li>包管理简单，大型项目只需要执行go build就可编译得到二进制文件，大大提高效率。</li></ol><p>Python语言特点</p><ol><li>对象定义简单, 例如{}定义map, []定义列表, ()定义元组，简单几行代码就可完成功能</li><li>自带丰富标准库和庞大扩展库，尤其是数据&#x2F;向量处理和机器学习算法库，如numpy, pandas, tensorflow, Matplotlib，lxml，python在数据处理和机器学习方面找不到语言替代者。</li><li>语法灵活，可简单可复杂。典型例子是装饰器，装饰器是一种函数修饰，用以减少通用代码。但装饰器被滥用，会严重降低代码可读性。python 函数参数没有类型检查，这导致直接从代码层面难以确定程序正确性，程序往往只有运行后才能知道问题（哪怕是很小的问题），加剧了“能用就行”的代码开发心态，同时降低了代码可读和可维护性。</li><li>虽然Python2已停止维护，但还有不少老项目还在使用python2，由于可维护性差，这些老项目难以迁移到python3。</li></ol><p>Rust 语言特点</p><ol><li>变量在默认不可变，有利于编译优化和可读性。</li><li>rust 语法上避免内存逃逸和多线程数据竞争。例如，rust 堆上变量等价于C++的unique_ptr, 复制等价于unique_ptr的移动语义，即对象所有权和转移，不会出现内存逃逸。同一作用域rust只允许一个可变引用、不允许可变引用与不可变引用同时存在，避免发生多指针写导致数据竞争。rust对于可变引用的限制是要避免多线程状态的数据安全问题，通过增加代码编写的限制和难度，来避免运行时可能的数据竞争问题。rust指针不受所有权限制，只能在unsafe块中使用</li><li>具有Cargo包管理器</li><li>TODO</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;简谈C、C++、JAVA、Go、Python、Rust编程语言&lt;/p&gt;</summary>
    
    
    
    <category term="base" scheme="https://larrystd.github.io/categories/base/"/>
    
    
    <category term="language" scheme="https://larrystd.github.io/tags/language/"/>
    
  </entry>
  
  <entry>
    <title>缓存</title>
    <link href="https://larrystd.github.io/2024/12/22/%E7%BC%93%E5%AD%98/"/>
    <id>https://larrystd.github.io/2024/12/22/%E7%BC%93%E5%AD%98/</id>
    <published>2024-12-21T16:00:00.000Z</published>
    <updated>2025-01-04T01:26:48.200Z</updated>
    
    <content type="html"><![CDATA[<p>缓存存放的是临时数据，相比主存，缓存往往速度更快，容量更小。</p><p>缓存往往是多级的，由内而外，cpu cache -&gt; 内存 -&gt; ssd -&gt; hdd（单机） -&gt; 服务器&#x2F;多节点&#x2F;oss&#x2F;nas等</p><p><strong>只要有缓存就会有一致性问题</strong></p><span id="more"></span><h3 id="写缓存"><a href="#写缓存" class="headerlink" title="写缓存"></a>写缓存</h3><p>写缓存有两种策略，write back和write through。</p><p>write back情况下，缓存不会立刻更新到主存，这让write back是单对象的行为。如果是多对象操作缓存，write back必然存在缓存不可见问题。例如page cache，一个进程的写入对另一个进程可能不可见。</p><p><strong>一般选择的写缓存策略是write through。</strong> 相当于没有写缓存。</p><h3 id="读缓存"><a href="#读缓存" class="headerlink" title="读缓存"></a>读缓存</h3><p>为了一致性，读写一般使用同一个缓存。<strong>读缓存需要考虑的就是缓存失效问题。</strong> 读缓存需要处理，如果写操作导致大量客户端读缓存失效，产生的缓存穿透问题。</p><p>nfs3 close-and-open一致性表示，文件close后，写缓存刷到后台，文件open后，本地读缓存全部失效，需要从后台重新拿。此外，nfs3通过ctime表示缓存有效性，每次读操作nfs3 都会向后台执行getattr，如果ctime和缓存一致，则直接读本地，否则读后台。</p><p>在有lease功能后，lease 的版本id，起到ctime的作用。数据写入服务端会lease++，客户端每次读操作会从后台获取lease，如果lease 和本地一致，则直接读本地，否则本地读缓存失效，读后台。</p><p>缓存在生效前需要先预热下，也就是预读</p><h3 id="缓存的更新"><a href="#缓存的更新" class="headerlink" title="缓存的更新"></a>缓存的更新</h3><p>缓存本质是KV map，需要加锁维护。缓存可能遇到大量请求同时更新，更新时的加锁可能严重影响性能。</p><p>缓存更新有两种</p><ol><li>缓存key存在，value失效了需要更新，这种不需要加锁，很快速</li><li>缓存key被淘汰了&#x2F;不存在，需要插入，这种更新需要加锁，比较重</li></ol><p>缓存还可以根据状态更新，典型的是cpu cacheline的MSI协议（Modified, Shared和Invalid）。这个要求每个cache line能感知到其他cache line发生写操作，同时能通知其他cache line写内存。例如cpu1能感知到cpu2发生了写cache操作，于是更新自己状态为unvalid，并让cpu2 刷到内存。java的valitale 关键字就是通过让cpu将对变量的修改直接刷内存</p><p>使用范围很小。 </p><h3 id="缓存穿透，缓存雪崩"><a href="#缓存穿透，缓存雪崩" class="headerlink" title="缓存穿透，缓存雪崩"></a>缓存穿透，缓存雪崩</h3><p>读缓存场景，如果数据被写入会导致所有客户端读缓存失效，瞬时压力可能给到服务器。</p><p>如果只是写操作导致的缓存失效，则缓存穿透也可以理解<br>如果是过期引起的缓存失效，使用LRU同时防止缓存大规模同时过期</p><p>主存前面可以加队列和流控来缓解压力</p><p>流控可以考虑权重公平流控，后台统计每个client的请求数量，当总数量达到阈值，通过权重计算得到每个client的能放进去的请求数量（最小值和最大值，也不能没请求）</p><h3 id="4k对齐"><a href="#4k对齐" class="headerlink" title="4k对齐"></a>4k对齐</h3><p>场景的缓存多是对齐的，例如page cache是4K对齐</p><p>write through策略，每笔写入都会写到后台，即使不是4K写。<br>客户端读缓存也设置成4K对齐的，使page cache可以命中</p><p>自定义fuse客户最好自行管理缓存</p><h3 id="文件元数据缓存"><a href="#文件元数据缓存" class="headerlink" title="文件元数据缓存"></a>文件元数据缓存</h3><p>主要的元数据缓存</p><ol><li>inode缓存，缓存inode 元数据，atime, ctime, mtime, link, mode, size等信息，这个缓存会经常更新</li><li>inode 数据缓存，</li><li>dentry缓存，缓存目录项存的文件名，方便readdir，文件创建删除时需要更新</li></ol><p>ganesha 元数据缓存，<br>genasha每个目录项会缓存目录中子文件name-&gt;filehandle映射，目的是方便lookup。如果lookup某个name缓存未命中， 会持有目录写锁 访问后台，拿到（name, filehandle)后释放目录写锁。<br>这样的原因是不给后台太多压力，防止多个请求同时打向后台（加了写锁只有一个lookup请求能打到后台），问题是产生了lookup串行化影响性能。</p><p>缓存应该有预读的功能，即缓存失效后尽量从后台拿到局部性多的数据。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;缓存存放的是临时数据，相比主存，缓存往往速度更快，容量更小。&lt;/p&gt;
&lt;p&gt;缓存往往是多级的，由内而外，cpu cache -&amp;gt; 内存 -&amp;gt; ssd -&amp;gt; hdd（单机） -&amp;gt; 服务器&amp;#x2F;多节点&amp;#x2F;oss&amp;#x2F;nas等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只要有缓存就会有一致性问题&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="base" scheme="https://larrystd.github.io/categories/base/"/>
    
    
    <category term="base" scheme="https://larrystd.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>并发</title>
    <link href="https://larrystd.github.io/2024/12/20/%E5%B9%B6%E5%8F%91%E6%80%BB%E8%A7%88/"/>
    <id>https://larrystd.github.io/2024/12/20/%E5%B9%B6%E5%8F%91%E6%80%BB%E8%A7%88/</id>
    <published>2024-12-19T16:00:00.000Z</published>
    <updated>2025-01-04T01:25:22.528Z</updated>
    
    <content type="html"><![CDATA[<p>并发可分成并发对象和并发协调两部分。并发对象可以是进程、线程、协程、以及多机并发。并发协调包括锁（进程锁、线程锁、协程锁、分布式锁），信号，信号量，条件变量，通信队列等。</p><p>并发编程的三个特点是<strong>原子性、有序性、可见性</strong>。<strong>原子性要求写操作要么执行完要么不执行，不能中途执行一半被干扰，并发编程中需要保证所有操作都是原子的</strong>；完全要求顺序的程序无法并发，因此并发编程的特点是原子性+部分有序。<strong>可见性是针对并发读共享变量</strong>，如果并发对象之间读共享变量，就要维护共享变量的可见性，一个并发对象修改另一个并发对象可以看到。（如果只有并发写，只要考虑原子性和顺序性，不需要可见性）</p><span id="more"></span><h2 id="并发对象"><a href="#并发对象" class="headerlink" title="并发对象"></a>并发对象</h2><p>传统（或者普遍）的程序执行是串行顺序的，<strong>如果把互不依赖的逻辑由单个串行改成多个并行，就产生了并发。</strong></p><p>常见的并发场景</p><ol><li>网络访问，例如http请求、mysql连接池，创建多个链接发送接收数据，链接之间互不影响</li><li>文件IO，多个线程写不同文件，线程之间互不影响。如果多线程写相同文件，线程间可能相互影响，需要对并发进行优化</li><li>为了利用多核能力，程序创建多进程&#x2F;线程，并行计算</li><li>生产者消费者模型（任务队列模型），多线程从任务队列拿任务处理，任务之间互不影响</li></ol><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>多线程需要处理数据更新的竞争问题，例如向数据库更新一个key，可能遇到不同线程尝试更新到不同值。即使不考虑顺序性，但由于更新key无法保证原子性，还是需要加锁维护。一个解决办法是，将key的操作绑定到线程池指定线程，也就是说，对于key的更新只交给一个固定的线程做。又比如文件系统，如果保证每个文件始终由固定的线程处理，那文件的每个io操作就天然具备了原子性。</p><p><strong>数据密集型应用中，执行流的耗时主要来自IO和网络</strong>。如果我们让固定的线程处理某文件的io，该线程大部分时间都会在睡眠等待数据落盘和磁盘取数据。办法是在单线程之上进行多协程调度，一旦出现IO等待，自动切换协程。这样<strong>理想情况下，线程一直执行计算和内存操作。</strong> 单线程的最高QPS就是1&#x2F;（一次计算和内存的耗时）。</p><p>虽然golang 实现了协程自动调度，让程序员像使用线程一样方便的使用协程（golang协程使用上和线程没有区别）。但协程的手动调度还是必要存在的。<strong>手动调度的好处是，对需要原子性的操作，保证执行完且执行期间不会协程切换。</strong>例如更新数据表期间，协程不会切走（切走其他协程就可能修改该数据-&gt;就需要加锁）</p><p>协程避免回调地狱。调用一次await，函数会自动放弃的执行权，执行权交由另外随机的协程。协程避免回调地狱前提是多个函数是可以异步调用的，如果必须等待回调函数返回才能执行下一个回调，那只能用线性回调。</p><p>单线程多协程模型是并发同时减少锁争抢的有效模型，例如作为中央服务的服务端，可以用单线程处理某个client&#x2F;session独占请求和数据，从而提供了原子性，不用对client&#x2F;session独占的请求&#x2F;数据加锁。</p><p>协程的编程模型</p><ol><li>将逻辑分为处理层、IO层、回调层。每层维护一个线程池，对于相同client请求，每层由固定的线程执行。处理层线程只处理非IO逻辑，最后把IO放到IO层；IO层协程其实是负责监听IO完成，完成后交给回调层处理回调函数。相同client请求由于每层都由固定的线程处理，不用加锁。同时单线程利用协程实现并发处理client的大量请求</li><li>采用async&#x2F;await编程模型，利用同步的编程手法实现类似1的单线程多协程并发，但不用配置大量的回调函数</li></ol><p>await 后面跟无线程阻塞的异步函数，当协程执行到await时，会把当前协程注册事件到协程调度器（或把当前协程作为作为切换后协程的回调函数）。当await异步函数执行完毕，会通知给协程调度器，然后转而继续执行。</p><p>理想情况下，只有协程会阻塞，线程会一直执行处理请求的工作。线程不会进入操作系统的等待队列，从而大大提高cpu的使用率。协程模型中往往一个cpu创建一个线程就足够。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs/promises&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">readFiles</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> data1 = <span class="keyword">await</span> fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file1.txt&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> data2 = <span class="keyword">await</span> fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file2.txt&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> data3 = <span class="keyword">await</span> fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file3.txt&#x27;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data1.<span class="title function_">toString</span>(), data2.<span class="title function_">toString</span>(), data3.<span class="title function_">toString</span>());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">readFiles</span>();</span><br></pre></td></tr></table></figure><h3 id="多链接并发"><a href="#多链接并发" class="headerlink" title="多链接并发"></a>多链接并发</h3><p>一个客户端创建多个链接，并发访问服务端数据。多链接请求比单链接好。</p><h2 id="并发协调"><a href="#并发协调" class="headerlink" title="并发协调"></a>并发协调</h2><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁，可以抽象成两点</p><ol><li><strong>锁作用是对并发场景下共享资源竞争的保护。</strong></li><li><strong>获取锁也就是某并发对象获得对某资源的操作权</strong></li></ol><p>凡是某资源可能被多个对象操作，就要考虑使用锁来保护</p><p>线程锁，对多个线程操作共享资源的保护;<br>进程锁，对多个进程操作共享资源的保护;<br>分布式锁，叫机器锁容易理解，对多个机器操作共享资源的保护</p><p>单机文件系统，文件锁是一种进程锁; 多机共享文件系统，文件锁是一种分布式锁</p><p>lease也可以看做一种锁，获取lease 也是获取某对象的操作权</p><h4 id="死锁和处理"><a href="#死锁和处理" class="headerlink" title="死锁和处理"></a>死锁和处理</h4><p>持有锁就要考虑死锁，<strong>死锁产生的原因是申请释放锁顺序不一致</strong></p><ol><li><strong>如果对象不会发生，持有锁的情况申请锁，则不会有死锁</strong></li><li>对于锁序列A, B, C, D，如果多个对象有统一的加锁顺序，例如遵循加锁A释放、加锁B释放、加锁C释放，<strong>不会有环形加锁的逻辑，则不会产生死锁</strong>。类似是是文件系统树lookup pathwalk的顺序</li><li><strong>多对象加锁顺序不一致才会产生死锁</strong><ol><li>文件系统rename，hardlink 路径不是从根节点的pathwalk，可能会产生死锁。如rename需要对目录加写锁（原因是需要删除源目录文件，创建新目录文件，需要先对两个目录加锁，由于加锁顺序可以是A-&gt;B，B-&gt;A，会发生死锁），linux为了处理rename死锁，规定每个文件系统内每次只能进行一个 rename 操作。<ol><li>hardlink需要对源文件加元数据锁，新hardlink文件的目录加写锁，linux处理hardlink死锁问题，规定link 的对象不能是目录</li></ol></li></ol></li></ol><p>文件系统加锁原理</p><ol><li>写文件需加文件写锁，更新文件元数据加文件元数据写锁</li><li>创建文件和删除文件需加目录写锁</li><li>read, getattr, setattr需要对元数据加锁，因为需要更新元数据</li><li><strong>rename锁最重，需要对源和目的文件的目录加锁</strong></li></ol><p>lease也是一种锁，lease场景是多个机器试图操作同一服务器资源（例如多客户端试图操作共享资源</p><ol><li>lease由服务器管理，<strong>如果服务器运行正常，服务器可以撤销某客户端的lease锁</strong>，从而结束客户端的死锁状态</li><li>如果服务器崩溃，客户端可能处于死锁等待，这时候<strong>需要客户端设置超时，主动退避重试来避免死锁</strong></li><li>对于文件系统，通常情况下获取lease按照顺序，rename同样可能触发死锁，分析同上‘</li></ol><p>可以看到死锁的两种处理办法</p><ol><li>避免死锁，例如保证某操作全局唯一，采用单线程、无锁编程</li><li>处理死锁，超时主动&#x2F;被动释放锁，退避重试</li></ol><h4 id="顺序性"><a href="#顺序性" class="headerlink" title="顺序性"></a>顺序性</h4><p>有时候还要求，从客户端无阻塞发出两个请求A-&gt;B，处理时也要按照A-&gt;B的顺序处理</p><p>常见的是在请求附加clientid和seqid，标注请求的顺序。</p><ol><li>服务端对某clientid，严格按照seqid顺序处理，这样强顺序会损害性能</li><li>客户端维护若干slot，slot内按照seqid顺序地址，将可以并发的请求通过多个slot并发发送。服务端对每个slotid 的请求顺序处理，slot外部不保证顺序</li><li>更宽松的，对于请求序列A,B,C，A请求失败了可以处理B请求，但B如果执行完了，不能再执行A。<br>，<br>例如操作write(‘a’) -&gt; read-&gt;write(‘a’)(重试) -&gt; write(‘abc’)，如果遵循3，结果是read(‘’), write(‘abc’)，如果执行了重试，结果则是write(‘aabc’)。</li></ol><h4 id="版本序列应对一写多读场景锁"><a href="#版本序列应对一写多读场景锁" class="headerlink" title="版本序列应对一写多读场景锁"></a>版本序列应对一写多读场景锁</h4><p>版本序列是读写锁优化的有效手段</p><p>版本是一种缓存，可以是内存的ring。在有人持有写锁期间，可以利用版本读还未写入的数据，当写锁执行完毕，则更新版本。写操作是一种事务提交，这意味着，事务未提交成功之前，状态未改变，等同于没有事务。</p><h4 id="乐观锁应对多写场景锁"><a href="#乐观锁应对多写场景锁" class="headerlink" title="乐观锁应对多写场景锁"></a>乐观锁应对多写场景锁</h4><ol><li>将原数据读到一个副本</li><li>对副本执行写操作，同时获得版本号&#x2F;时间戳</li><li>原子提交，再次版本号&#x2F;时间戳，如果一致，则提交；如果有问题，则重试1</li></ol><p>原子提交也可以换成简单操作，乐观锁的写不能太重，否则可能写期间被更新。</p><h4 id="互斥锁的实现"><a href="#互斥锁的实现" class="headerlink" title="互斥锁的实现"></a>互斥锁的实现</h4><p>spinlock，</p><ol><li>spinlock 主要是保护多cpu操作对象的安全，可以是cpu共享的硬件变量，为了防止死锁，加spinlock需要屏蔽当前cpu的中断</li></ol><p>mutex，存放在内存的共享变量，维护多线程的安全</p><p>中心化数据库&#x2F;redis，zookeeper&#x2F;etcd等中心化kv，实现分布式锁</p><h4 id="客户端锁和服务端锁"><a href="#客户端锁和服务端锁" class="headerlink" title="客户端锁和服务端锁"></a>客户端锁和服务端锁</h4><p>熟悉的线程锁，进程锁是一种客户锁。在用户程序中加锁防止多线程并发修改共享变量。——如果操作系统保证每个对象只能被一个线程访问，也就是加服务端锁，就不需要客户端加锁了，当然由于性能不可能实现。</p><p>分布式锁保护共享变量可以在客户端层面实现，利用保证同一时刻只有一个客户端访问共享变量，则服务端不需要额外加锁。如果允许多客户端同时访问共享变量，服务端分布式锁的实现会异常复杂。</p><p><strong>lease也是通过客户端锁减轻服务端加锁的问题</strong>。分布式锁的损耗很大（ms级），如果经常访问的操作需要加分布式锁，会严重影响服务的性能。</p><p>库存，订单数量修改 加分布式锁的思路是将大量操作封装成事务，追求吞吐量。延迟要求高的操作应该避免服务加分布式锁，而是限制访问的客户端。</p><p><strong>分布式元数据的另一种实现是自行实现raft&#x2F;poixs协议直接保证元数据集群的一致性，同时提供高性能KV存储</strong>，该方法性能比申请加分布式锁高。</p><p>gpfs 可以控制client和server，采用client 锁和服务锁结合的形式。例如写目录文件&#x2F;rename，gpfs要求某时刻只能有一个client执行操作。但修改文件元数据应该可以允许多client操作。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;并发可分成并发对象和并发协调两部分。并发对象可以是进程、线程、协程、以及多机并发。并发协调包括锁（进程锁、线程锁、协程锁、分布式锁），信号，信号量，条件变量，通信队列等。&lt;/p&gt;
&lt;p&gt;并发编程的三个特点是&lt;strong&gt;原子性、有序性、可见性&lt;/strong&gt;。&lt;strong&gt;原子性要求写操作要么执行完要么不执行，不能中途执行一半被干扰，并发编程中需要保证所有操作都是原子的&lt;/strong&gt;；完全要求顺序的程序无法并发，因此并发编程的特点是原子性+部分有序。&lt;strong&gt;可见性是针对并发读共享变量&lt;/strong&gt;，如果并发对象之间读共享变量，就要维护共享变量的可见性，一个并发对象修改另一个并发对象可以看到。（如果只有并发写，只要考虑原子性和顺序性，不需要可见性）&lt;/p&gt;</summary>
    
    
    
    <category term="base" scheme="https://larrystd.github.io/categories/base/"/>
    
    
    <category term="base" scheme="https://larrystd.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>块存储、对象存储和文件存储</title>
    <link href="https://larrystd.github.io/2024/12/15/%E5%9D%97%E5%AD%98%E5%82%A8%E3%80%81%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%92%8C%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/"/>
    <id>https://larrystd.github.io/2024/12/15/%E5%9D%97%E5%AD%98%E5%82%A8%E3%80%81%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%92%8C%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/</id>
    <published>2024-12-14T16:00:00.000Z</published>
    <updated>2025-01-04T01:15:15.168Z</updated>
    
    <content type="html"><![CDATA[<p>块存储、对象存储、文件存储是云计算云存储的概念，我想基于云存储，但也不限于云存储，谈谈自己的想法。</p><span id="more"></span><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>首先给出chatgpt对块、对象、文件存储的定义</p><p>块存储（Block Storage），是一种高性能存储技术，主要用于对结构化或非结构化数据进行低延迟、高效存储。它将数据划分为固定大小的“块”，每个块都有唯一的地址，独立存储于存储介质上。这种存储方式广泛用于云计算、数据库和虚拟化等场景。</p><p>文件存储（File Storage），是一种常见的数据存储方式，使用文件和文件夹的层次化结构来组织和管理数据。它类似于操作系统中的文件系统，提供直观的路径访问和共享功能，适用于多个客户端访问共享数据的场景。</p><p>对象存储是一种现代化的存储架构，专为存储大量非结构化数据而设计。它将数据存储为对象，并通过唯一的标识符（Object ID）进行访问，而不是使用传统的文件系统层次结构。对象存储以高可扩展性、弹性和低成本著称，是云计算和大规模数据存储的核心技术之一。</p><p>下面从我的角度给出以上名词定义的解释版本</p><h3 id="块存储"><a href="#块存储" class="headerlink" title="块存储"></a>块存储</h3><p>块存储功能上等价于一个块设备，linux 上可以使用lsblk 查看设备。在没有虚拟化情况下，一个块设备就是一块物理意义的硬盘。linux用sda，sdb, sdc表示块设备，块设备可以分区，例如sda1, sda2, sda3就是sda设备上的三个分区。linux 常用的分区工具是fdisk，每个块设备分区可以单独格式化文件系统（类似windows C, D等区）。</p><p>块存储的访问是在文件系统层下的，linux用户io会先走内核文件系统层，文件系统会维护（文件id，offset, length）到块设备的（设备号，块号）的映射，这种映射也可以理解成一种虚拟地址到物理地址的映射。一旦得到设备号和块号，对于本地存储，操作系统会调用驱动程序读写磁盘，并利用中断实现数据读写完毕后通知cpu处理。对于云存储，操作系统会携带（设备号，块号）发送网络包，同样注册中断实现网络包返回时通知cpu处理。一般而言，TCP协议网络包可以满足要求，如果追求高性能，就要涉及到用户态tcp协议，dpdk工具链，virtio协议规范，rdma高性能网络了。</p><p>根据块存储定义“它将数据划分为固定大小的“块”，每个块都有唯一的地址，独立存储于存储介质上”，可以得到<strong>块对齐</strong>的特点</p><ol><li>块存储的单位是“块”，<strong>块是固定大小的（通常为4KB）</strong>。相较之下，文件存储的单位“文件”（File），对象存储的单位“对象”（object），是任意大小的。</li><li>由于”块”是固定大小，例如4K，那<strong>读写iosize可以设计成4K对齐</strong>。这可以大大减小存储涉及的复杂性。如果读写大小是任意的，用户可以写<code>[1023, 1025]</code>, <code>[1022, 1026]</code>等任意区间，新区间数据还应该覆盖旧区间数据。可以想到，随着不断写入，区间数量线性增长，不仅占用大量内存，读操作还由于遍历所有区间导致性能下降。块存储的读写iosize设计成4K对齐的，用户只能4K对齐写，区间管理和读性能大大降低。</li></ol><p>写区间管理是存储的重要模块，称为layout管理，可以分析得到，<br>写区间越多-&gt;内存占用越多-&gt;读性能下降，写性能不受影响</p><p>除了固定大小和iosize外，块存储的另一个重要特点是，<strong>一个块每时每刻只会被一个ip主机访问，一个云硬盘每时每刻也只会被一个ip主机访问</strong>，这很关键，这意味着，如果我们把云硬盘划分成固定大小的segment（segment可以很大，例如16GB、32GB，因为云硬盘大小很大）。我们可以把相同云硬盘的多个segment调度到多机上，而不用考虑对多机加分布式锁，甚至不用加锁! 我们可以想象块存储架构的一般实现形式，只关心segment的调度和segment中的(devid, blockid)到实际物理存储的映射，每个server记录了某个segment (devid, blockid)到实际物理存储映射（索引表），根据索引表处理读写请求，而master记录了segment和server的调度计划，如果底层采用的是类似hdfs的分布式文件系统，只需要把<strong>索引表全量复制到其他server</strong>，就可以实现segment的调度。</p><p>如果允许多个ip同时访问一块云硬盘，可以想到，为了保证数据一致性，需要保证某ip请求写数据时，其他ip无法写数据，也就是加写锁。但如果一个segment永远只有一个ip读写数据，我们只需要保证io处理顺序和客户端发出的请求顺序一致，不需要加写锁！单ip访问的特点也让块存储优化读写路径变得容易，因为不需要考虑多客户端缓存&#x2F;数据一致性。</p><p>单ip访问导致块存储的缺点是，块存储不能多机共享。这是块存储的应用上的最大劣势。</p><p>总结块存储的三大特点</p><ol><li>功能等价硬盘</li><li>块和读写iosize 4K对齐，layout管理容易</li><li>每个块设备每时每刻只有一个ip访问</li></ol><h3 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h3><p>块存储相当于硬盘块设备，文件系统相当于ext4等文件系统。块存储访问的路径是，用户程序-&gt;虚拟文件系统-&gt;ext4等单机文件系统-&gt;网络层（TCP-&gt;IP-&gt;网卡）-&gt;后端；文件系统则是，用户程序-&gt;虚拟文件系统-&gt;网络层（TCP-&gt;IP-&gt;网卡）-&gt;后端。文件系统的网络层同样可以利用块存储介绍的用户态tcp协议，dpdk工具链，virtio协议规范，rdma高性能网络了来优化。</p><p>块存储遵循的网络协议常见的是iSCSI和NVMe-oF，前者更通用后者更追求性能。文件存储的网络协议Linux是NFS协议，Windows是SMB协议。其中，Linux 内核除了提供NFS模块之外，还提供fuse接口支持用户态自定义文件系统。</p><p>相比块存储协议主要是块读写，文件存储的协议更复杂。除读写外，还有rename（移动），readdir（读目录文件），link（软硬链接），文件锁等。文件协议的全部特性实现复杂，很多选择基于fuse自定义文件存储协议。</p><p>文件系统用N叉树来组织结构，或者说二元组（父目录handle，子文件name）。子文件和父目录常常相互影响，例如创建子目录后父目录link数量需要+1，子文件删除需要父目录加锁等</p><p>除了复杂的文件存储协议，文件存储另一个挑战是多客户端共享。和块存储不同，文件存储支持多客户端同时访问一个文件系统。这给文件存储实现带来很大困难</p><ol><li>文件系统元数据难以拆分。如果一个文件系统拆分成两部分，每部分位于一个节点。那么从机器A rename文件到机器B就要加分布式锁，保证只有一个请求执行rename，否则会导致死锁。分布式锁性能代价很大。事实上rename 的死锁问题在单机文件系统也存在，linux通过保证rename操作全局唯一来避免死锁，可以参考这个文章， <a href="http://www.linuxeden.com/html/sysadmin/20090903/67802.html">Linux文件系统中元数据的加锁机制与组织方式</a>。元数据不拆分会导致元数据iops受限于单机iops，一个文件系统只能位于某个节点，那该文件系统的元数据iops受制于单节点的iops（数据可以拆分到多个节点，因此读写iops和吞吐可以水平扩展）</li><li>readdir和remove 等语义实现困难，某客户端正在readdir，另一个客户端把目录或目录下的文件remove掉。可以对readdir的目录加读锁，删目录需要申请写锁；此外由于readdir 会分批返回，因此应该对readdir 的cookie文件进行软删除，使readdir 下次请求还可以在cookie文件处继续readdir，不受cookie文件删除影响。</li><li>复杂的元数据缓存。元数据缓存至少有inode缓存，缓存inode 的size, mode, link数量, atime&#x2F;ctime&#x2F;mtime等信息，加快getattr速度；dentry缓存，缓存目录项下的文件名，提高readdir速度。带来的问题就是, lookup，create,remove,rename会写dentry缓存（缓存穿透，会读后端，结果更新缓存），写期间需要对dentry加写锁，导致缓存无法被读写（相当于缓存失效），即dentry的所有请求都需要阻塞直到缓存更新好，会拖累元数据性能。方案是考虑多shot并发写后端元数据，读操作使用多版本，在写成功之前，只能读到写成功的数据。</li><li>客户端缓存一致性困难。客户端天然pagecache缓存是write-back缓存策略，多客户端同时写文件会不可避免的导致某客户端写入的数据无法被其他客户端感知的。处理方案，1.close-and-open一致性，即close文件会把数据刷到后端，从而被其他客户端看到 2. 定期刷到后端，nfsv3使用该策略，会牺牲一部分一致性 3. 使用文件锁，保证某文件同时刻只有一个客户端执行写操作，即保证1写多读。但文件锁的实现难点是服务端failover。nfsv3协议是无状态的，好处是服务端&#x2F;客户端崩溃后重新连接不用恢复状态；客户端文件锁实现要求协议具有状态，问题就是崩溃后需要状态恢复。</li></ol><p>块存储的块大小和iosize 4K对齐，对块存储的io区间管理（称为layout管理）降低了难度。不幸的是，文件存储对这俩都没要求，文件大小不固定，iosize也不固定。为了降低layout管理的复杂度，可以通过fuse自定义客户端让客户端发往后端的iosize尽量对齐。</p><p>文件存储的实现充满了折衷，例如元数据拆分能提高getattr，readdir等元数据操作的性能，但牺牲了rename的延迟和iops。客户端文件锁的实现提高了一致性和状态管理，但牺牲了客户端的多写能力。相对容易的文件存储实现架构是后端分为协议层、元数据层和数据层。协议层负责解析协议，转发，鉴权; 元数据层管理inode, dentry和hardlink表和元数据操作，数据层管理文件layout和读写；数据拆分，元数据不拆分；fuse实现自定义的客户端取代nfs。</p><p>总结文件存储的特点</p><ol><li>功能等价文件系统</li><li>块和读写iosize 不要求对齐，layout管理困难</li><li>支持多ip共享访问</li><li>协议复杂，实现多样。主要的调用有lookup, getattr, setaddr, access, read, write, link, symlink, readlink, readdir, readdirplus, remove，rename, fsstat等</li></ol><h3 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h3><p>对象存储是文件存储简化而来的，由于文件存储实现复杂，处处需要折衷，难以元数据拆分（水平扩展），无法提供稳定的高性能。</p><ol><li>文件存储元数据难以拆分的原因是其利用（目录，文件）构建的目录树结构，对象存储取消目录概念，文件全部通过对象路径hash查找。因此对象存储的元数据就是一个简单的hash表，hash表是容易多机拆分的。只需要1. 将对象路径hash到节点ip 2. 将对象路径hash到key。因此，对象存储bucket的元数据能力远超文件存储。前者元数据iops能达到几十万上百万，后者只有几万。</li><li>对象存储没有了目录概念，自然也没有了rename，link，目录锁概念。而rename，link是文件存储最难实现的调用之一。</li><li>对象存储只有object元数据缓存，没有dentry缓存，缺点就是对象存储的listobject 性能一般</li><li>对象存储的块大小定长且很大（高达1M），对象存储原生不支持对象的随机写和追加写，没有文件存储客户端锁保证一写多读和layout管理困难的问题。</li></ol><p>对象存储在读io上类似文件存储，支持对象随机读，只需要把路径&#x2F; 解析为目录；对象存储不支持写操作。如果要对象存储和文件存储结合使用，可以 1. 写io 写文件存储，文件存储后台tiering到对象存储 2. 读io 先读文件存储，文件存储不存在再读对象存储。</p><p>对象存储协议s3协议是一种http协议，也就是说对象存储支持浏览器互联网的访问，对象存储的服务环境更复杂，这让对象存储在鉴权、安全等方面建设比文件存储&#x2F;块存储更完善，后两者一般在高可信、高速网络中使用rpc调用。</p><p>总结对象存储的特点</p><ol><li>文件系统的简化版，无目录概念，支持海量客户端访问</li><li>s3协议是一种http协议，服务更广泛（块&#x2F;对象的主要服务对象是ecs&#x2F;gpu等计算单元）</li><li>支持随机读但不支持写，几乎不需要layout管理。元数据能力容易扩展。</li></ol><h3 id="layout管理"><a href="#layout管理" class="headerlink" title="layout管理"></a>layout管理</h3><ul><li>写操作</li></ul><p>块存储的layout，（设备号、块）-&gt;后台（文件id, offset），offset和length是4K对齐的</p><p>文件存储的layout，用户（文件inode, offset）-&gt; 后台（文件id, offset），offset和length可以不对齐</p><p>对象存储的layout，用户（objectid）-&gt;后台（文件id, offset）</p><ul><li>读操作</li></ul><p>块存储的layout，（设备号、块）-&gt;后台（文件id, offset, length），offset和length是4K对齐的，后台文件offset是最新的写入</p><p>文件存储的layout，用户（文件inode, offset, length）-&gt; 后台（文件id, offset, length），offset和length可以不对齐，offset是最新的写入</p><p>对象存储的layout，用户（objectid）-&gt;后台（文件id, offset）。直接记录object在后台文件存放的起始位置，即可随机读。对象存储没有覆盖写</p><p>块存储和文件存储由于支持随机覆盖写，读操作需要保证始终读到最新写入的offset，对象存储不支持随机写，读操作只需要找到object的起始位置即可。</p><h3 id="索引表的分裂和调度"><a href="#索引表的分裂和调度" class="headerlink" title="索引表的分裂和调度"></a>索引表的分裂和调度</h3><p>块存储&#x2F;文件存储的layout表，文件存储的元数据inode&#x2F;dentry表都要记录到KV存储中。KV存储的基本能力是，</p><ol><li>如果KV体积庞大，能分裂成两个KV；</li><li>KV可以调度到任何机器中</li></ol><p>如果KV的key是有序的，KV的分裂可以按照key来拆分，小于某key的为KV1，大于的为KV2。KV分裂依赖于复制，</p><ol><li>全量复制。对旧KV复制出两个新KV，复制过程没有发生数据的复制，只是数据的引用。KV内存态的信息记录在redolog，磁盘态的信息记录在SST文件。新的KV1，2 replay redolog生成内存态KV，根据区间引用SST获得磁盘态信息。全量复制应当是复制到某个checkpoint。</li><li>增量复制。增量复制的进度单位应该是inode，设备等物理概念，当一个inode全量复制完毕，后续该inode写操作即可在新KV上进行。逐渐过渡到全部inode，设备复制完毕，把旧KV清理掉。</li></ol><p>KV的调度也依赖于复制</p><ol><li>将旧KV在新节点上复制一份。同样是先全量复制，后增量复制。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;块存储、对象存储、文件存储是云计算云存储的概念，我想基于云存储，但也不限于云存储，谈谈自己的想法。&lt;/p&gt;</summary>
    
    
    
    <category term="multi-machine" scheme="https://larrystd.github.io/categories/multi-machine/"/>
    
    
    <category term="storage" scheme="https://larrystd.github.io/tags/storage/"/>
    
  </entry>
  
  <entry>
    <title>单机存储引擎</title>
    <link href="https://larrystd.github.io/2024/12/14/%E5%8D%95%E6%9C%BA%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EB+%E6%A0%91%E5%92%8CLSM%E6%A0%91/"/>
    <id>https://larrystd.github.io/2024/12/14/%E5%8D%95%E6%9C%BA%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EB+%E6%A0%91%E5%92%8CLSM%E6%A0%91/</id>
    <published>2024-12-13T16:00:00.000Z</published>
    <updated>2025-01-04T01:14:59.752Z</updated>
    
    <content type="html"><![CDATA[<p>B+树和LSM树是最常见的单机存储引擎，前者代表是Mysql等事务性数据库，后者代表是Rocksdb等nosql KV数据库。</p><span id="more"></span><h3 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h3><p>B树是一种平衡的多叉树，通常说m 阶B树，树的阶指的是B树中节点的子节点数目的最大值。</p><p>B树必须满足如下条件：</p><ol><li>所有叶子节点都在同一层级；</li><li>除了根节点以外的<strong>其他节点包含的key值数量</strong>在<code>[m/2]-1</code>到<code>m-1</code>的数据范围；</li><li>除了根节点和叶子节点外，<strong>所有中间节点至少有m&#x2F;2个子节点</strong>；</li><li>根节点如果不是叶子节点的话，它必须包含至少2个孩子节点；</li><li><strong>拥有n-1个key值非叶子节点必须有n个孩子节点</strong>；这要求每个key的前后都有指向子节点的指针</li><li>一个节点的所有key值必须是升序排序的；</li></ol><p><img src="/../images/Btree.png" alt="Btree" title="Btree"></p><p>B+树是应文件系统所需而产生的 B 树的变形树。B+树的特征：</p><ol><li>B+树包含2种类型的节点：内部节点（也称索引节点）和叶子节点。根节点本身即可以是内部节点，也可以是叶子节点。</li><li>B+树与B树最大的不同是<strong>内部节点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子节点中；</strong></li><li>m阶B+树表示了内部节点最多有m-1个key（或者说内部节点最多有m个子树，和B树相同），<strong>阶数m同时限制了叶子节点最多存储m-1个记录</strong>；</li><li>内部节点中的key都按照从小到大的顺序排列，对于内部节点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子节点中的记录也按照key的大小排列；<br><strong>每个叶子节点都存有相邻叶子节点的指针</strong>，叶子节点本身依key的大小自小而大顺序链接；</li></ol><p><img src="/../images/B+tree.png" alt="B+tree" title="B+tree"></p><p>B+ 树相比 B 树，最大差异是<strong>非叶子节点不再存储具体数据，以及叶子节点是链表结构</strong>。非叶子节点不再存储具体数据，这使得 <strong>B+ 树更加扁平化</strong>，查找效率更高。叶子节点是链表结构，这使得 <strong>B+ 树更适合用在范围查找</strong>的场景中。</p><p>在Mysql的InnoDB中，每个数据表的索引都会有一个B+树维护。在主键索引中，B+树的节点是16K固定大小的page，page内部由记录链表构成，每个记录的key是主键，value则是行数据。B+树查询相当于一个巨大的二分查找，先根据主键和区间定位到主键所属的page，然后在page内部遍历记录链表找到key所在的记录和行数据。</p><p>B+树的优势</p><ol><li>B+树的非叶子节点不存储数据，内存可以容纳，实际磁盘IO数量只有访问叶子节点的一次。</li><li>B+树叶子节点有序，互相有链接，范围查询能充分利用磁盘的顺序读优势</li><li>B+树的节点是固定大小的page，page对齐落盘。但如果数据页没有在cache，写操作需要等待数据页从磁盘中读取，写性能不如读</li></ol><h3 id="LSM树"><a href="#LSM树" class="headerlink" title="LSM树"></a>LSM树</h3><p>LSM（Log-Structured Merge Tree）相比B+树，写性能高，读性能稍逊。</p><p>LSM 树由两部分组成：</p><ol><li>MemTable（内存表）</li></ol><p>是一个可变的有序数据结构（如红黑树或跳表），存储数据的最新写入。使用redolog保证memtable的数据安全，写操作先顺序写redolog和MemTable，提高写性能。</p><ol start="2"><li>SSTable（Sorted String Table）</li></ol><p>当 MemTable 达到一定大小时，会作为SSTable文件写入磁盘。SSTable 是不可变的。<br>SSTable 通常通过多个层级组织，使用compaction策略减少存储。</p><p>LSM的特点</p><ol><li>写性能高</li><li>读性能不稳定，随着需要读的数据位置层次由高到低，读性能逐渐下降。读操作存在大量不必要的磁盘读操作，可用布隆过滤器缓解</li><li>写放大，写操作先写redolog和memtable，memtable后台dump到sst, 旧sst再重新comapction到新的sst，后台存在大量读写。大量写放大可能增加磁盘IO压力影响前台IO，磁盘寿命。</li><li>空间放大。更新键和删除键同样写入到redolog和memtable，不同层级的SSTable可能存在相同但新旧不同的键。</li><li></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;B+树和LSM树是最常见的单机存储引擎，前者代表是Mysql等事务性数据库，后者代表是Rocksdb等nosql KV数据库。&lt;/p&gt;</summary>
    
    
    
    <category term="single-machine" scheme="https://larrystd.github.io/categories/single-machine/"/>
    
    
    <category term="single-machine" scheme="https://larrystd.github.io/tags/single-machine/"/>
    
    <category term="storage" scheme="https://larrystd.github.io/tags/storage/"/>
    
  </entry>
  
  <entry>
    <title>linux操作系统总览(2)——内存管理、文件系统、网络管理</title>
    <link href="https://larrystd.github.io/2024/12/10/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E8%A7%88(2)%E2%80%94%E5%86%85%E5%AD%98%E5%92%8CIO%E7%BD%91%E7%BB%9C/"/>
    <id>https://larrystd.github.io/2024/12/10/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E8%A7%88(2)%E2%80%94%E5%86%85%E5%AD%98%E5%92%8CIO%E7%BD%91%E7%BB%9C/</id>
    <published>2024-12-09T16:00:00.000Z</published>
    <updated>2025-01-04T01:14:38.672Z</updated>
    
    <content type="html"><![CDATA[<p>linux操作系统大致可分为进程管理、进程协调、内存管理、文件系统、网络管理等五大部分。本文讲述内存管理、文件系统、IO&#x2F;网络管理。</p><span id="more"></span><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>linux 内部管理的核心就是把虚拟内存映射到物理内存。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>为什么需要虚拟内存？</p><ol><li>虚拟内存下，用户程序无法感知真实的物理内存地址，避免用户程序直接操纵物理内存带来的风险</li><li>虚拟内存下，所有用户程序的虚拟地址是一致的，32位系统是2^32&#x3D;4GB，64位系统是2^64。操作系统给进程一致的抽象，而内部实现上，可能是物理内存，也可能是磁盘swap空间的换页。</li></ol><p>有虚拟内存和物理内存，就需要管理两种内存的映射（layout管理）。</p><h4 id="虚拟内存映射"><a href="#虚拟内存映射" class="headerlink" title="虚拟内存映射"></a>虚拟内存映射</h4><p>虚拟内存，内存由固定大小（4K）的页page组成。物理内存，内存由4K固定大小的页框Frame组.</p><p>虚拟内存地址由两部分组成：<br>页号（Page Number），定位页表中的条目。<br>页内偏移量（Offset），定位页框内的具体位置。 </p><p>虚拟内存映射过程</p><ol><li>根据虚拟地址中的页号，查找页表中的对应条目，找到物理页框。</li><li>根据页内偏移量，确定具体物理地址。</li></ol><p>页表，<strong>每个进程维护一个页表</strong>，记录虚拟内存page到物理地址frame的映射。执行虚拟内存到物理内存地址映射的是MMU单元，MMU是一个硬件，传入进程和虚拟地址，它首选使用TLB缓存，缓存不命中则去内存查找进程页表记录的物理地址。</p><p>操作系统中的页表一般是多级页表（四级），多级页表避可以避免单表过大，按需分配子页表，当进程申请内存时才创建页表，降低内存消耗。</p><h4 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h4><p>上面说到，内存会对虚拟和物理内存空间划分为固定大小的连续内存块，称为页（Page），也就是内存分页。在Linux下，每一页的大小通常为4KB。虚拟地址与物理地址之间通过页表进行映射。</p><p>除了分页，虚拟内存还会将进程地址空间的用户区域分段，地址从高到低分别是栈、内存内核空间映射区域、堆、已初始化数据段 (.data)、未初始化数据段 (.bss) 、代码段 (.text)。初始化数据段包括已初始化的全局变量和静态变量，未初始化数据段则包括未初始化的全局变量 和 静态变量，在程序运行时会被自动初始化为 0。.bss 段在可执行文件中不占用实际空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------+ 高地址</span><br><span class="line">|        栈 (Stack)           | 动态分配，向下增长</span><br><span class="line">+-----------------------------+</span><br><span class="line">|       内核映射区域          | 受保护的内核空间</span><br><span class="line">+-----------------------------+</span><br><span class="line">|          堆 (Heap)          | 动态分配，向上增长</span><br><span class="line">+-----------------------------+</span><br><span class="line">|     已初始化数据段 (.data)   |</span><br><span class="line">+-----------------------------+</span><br><span class="line">|   未初始化数据段 (.bss)      |</span><br><span class="line">+-----------------------------+</span><br><span class="line">|        代码段 (.text)        | 固定大小，只读</span><br><span class="line">+-----------------------------+ 低地址</span><br></pre></td></tr></table></figure><p>linux使用<strong>伙伴系统算法(Buddy system)管理物理内存的页框</strong>frame。把空闲页框分组为11个块链表，每个块链表分别包含大小为1，2，4，8，16，32，64，128，256，512和1024个连续页框的页框块。Buddy system算法物理内存分配的最小单位是页框，由于任何整数可以由若干2^n的和组成，在内存足够的情况下，任意数量的页框Buddy算法都可配置。</p><p>slab分配器负责管理少于一个页框的小内存，分配内存以Byte为单位。每个SLAB 包含若干个同类型的对象，这些对象通常大小相同。内核为常用的内核对象（如任务结构、网络缓冲区）建立的 Cache，Cache 负责管理slab对象的分配、初始化、释放等操作。</p><p>slab分配器的对象是内核结构体，用户程序、文件的内存分配直接使用buddy算法分配4K对齐的内存。而ptmalloc, tcmalloc等内存分配器是在buddy算法已经分配的物理页的页内部进一步分配。</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件系统可以认为是linux系统的用户界面。启动linux系统后，呈现在用户眼前的是文件系统，用户编写时程序、运行指令是在文件系统。用户感知不到进程、内存的存在，只能感知到目录、文件的存在。</p><h4 id="文件系统外层"><a href="#文件系统外层" class="headerlink" title="文件系统外层"></a>文件系统外层</h4><p>文件系统的外层提供文件属主、权限功能。文件属主提供了多用户访问操作系统的能力，每个文件提供属主owner，用户组group，其他组other的权限隔离和读r、写w、可执行x 三种权限。linux的用户信息记录在&#x2F;etc&#x2F;passwd文件，用户组信息记录在&#x2F;etc&#x2F;group文件。</p><p>文件由数据和元数据组成，文件的元数据包括文件类型、文件权限、文件所有权，文件时间戳atime, ctime, mtime，文件大小，硬链接数，inode号，块大小和块数量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件类型</span></span><br><span class="line">-：普通文件</span><br><span class="line">d：目录</span><br><span class="line">l：符号链接</span><br><span class="line">b：块设备</span><br><span class="line">c：字符设备</span><br><span class="line">p：命名管道</span><br><span class="line">s：套接字</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件权限，三组三位表示（rwxrwxrwx）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件所有权，包括文件所有者的用户 ID，文件所属组的组 ID。</span></span><br></pre></td></tr></table></figure><h4 id="文件fd"><a href="#文件fd" class="headerlink" title="文件fd"></a>文件fd</h4><p>文件fd是进程内部标识文件的方法，文件inode则是文件系统内部标识文件。因此应当管理映射（进程id，fd）-&gt;（文件系统id，文件inode）。</p><p>进程会使用file对象维护进程已经打开的文件, file对象会记录当前文件偏移量、文件的访问模式（如只读、只写）、指向inode的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">file</span> &#123;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">llist_node</span>fu_llist;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rcu_head</span> fu_rcuhead;</span><br><span class="line">&#125; f_u;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">path</span>f_path;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">inode</span>*f_inode;<span class="comment">/* cached value */</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span>*f_op;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Protects f_ep_links, f_flags.</span></span><br><span class="line"><span class="comment"> * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">spinlock_t</span>f_lock;</span><br><span class="line"><span class="type">atomic_long_t</span>f_count;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> f_flags;</span><br><span class="line"><span class="type">fmode_t</span>f_mode;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mutex</span>f_pos_lock;</span><br><span class="line"><span class="type">loff_t</span>f_pos;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fown_struct</span>f_owner;</span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">cred</span>*f_cred;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">file_ra_state</span>f_ra;</span><br><span class="line"></span><br><span class="line">u64f_version;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">address_space</span>*f_mapping;</span><br><span class="line">&#125; __attribute__((<span class="built_in">aligned</span>(<span class="number">4</span>)));<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">file_operations</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">module</span> *owner;</span><br><span class="line"><span class="built_in">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line"><span class="built_in">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="built_in">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="built_in">ssize_t</span> (*read_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line"><span class="built_in">ssize_t</span> (*write_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line"><span class="built_in">int</span> (*iterate) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line"><span class="built_in">int</span> (*iterate_shared) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span></span>;</span><br><span class="line"><span class="built_in">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="built_in">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="built_in">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line"><span class="built_in">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="built_in">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line"><span class="built_in">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="built_in">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line"><span class="built_in">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line"><span class="built_in">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line"><span class="built_in">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span></span>;</span><br><span class="line"><span class="built_in">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line"><span class="built_in">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line"><span class="built_in">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="built_in">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="built_in">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **, <span class="type">void</span> **);</span><br><span class="line"><span class="built_in">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,</span><br><span class="line">  <span class="type">loff_t</span> len);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="文件inode"><a href="#文件inode" class="headerlink" title="文件inode"></a>文件inode</h4><p>inode 需要管理文件使用page cache的页框，这是物理内存。inode使用address_space这个结构管理page cache的页框。adress_space采用基数树管理inode的页，为什么不使用链表？链表查找慢O(n)；为什么不使用数组?数据查找虽然快，但删除（即淘汰一个page）慢。</p><p>address_space负责从page cache申请空闲内存页，跟踪文件脏页的flush。address_space前台（例如找page，读page）由用户进程执行，后台操作（例如刷page，缺页中断）由kworker线程执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line"><span class="type">umode_t</span>i_mode;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>i_opflags;</span><br><span class="line"><span class="type">kuid_t</span>i_uid;</span><br><span class="line"><span class="type">kgid_t</span>i_gid;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>i_flags;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>*<span class="title">i_op</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>*<span class="title">i_sb</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>*<span class="title">i_mapping</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Stat data, not accessed from path walking */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>i_ino;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Filesystems may only read i_nlink directly.  They shall use the</span></span><br><span class="line"><span class="comment"> * following functions for modification:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    (set|clear|inc|drop)_nlink</span></span><br><span class="line"><span class="comment"> *    inode_(inc|dec)_link_count</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> i_nlink;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __i_nlink;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">dev_t</span>i_rdev;</span><br><span class="line"><span class="type">loff_t</span>i_size;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span><span class="title">i_atime</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span><span class="title">i_mtime</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span><span class="title">i_ctime</span>;</span></span><br><span class="line"><span class="type">spinlock_t</span>i_lock;<span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>          i_bytes;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>i_blkbits;</span><br><span class="line"><span class="type">blkcnt_t</span>i_blocks;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Misc */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>i_state;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span><span class="title">i_rwsem</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>dirtied_when;<span class="comment">/* jiffies of first dirtying */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>dirtied_time_when;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span><span class="title">i_hash</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">i_io_list</span>;</span><span class="comment">/* backing dev IO list */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">i_lru</span>;</span><span class="comment">/* inode LRU list */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">i_sb_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">i_wb_list</span>;</span><span class="comment">/* backing dev writeback list */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span><span class="title">i_dentry</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">i_rcu</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">u64i_version;</span><br><span class="line"><span class="type">atomic_t</span>i_count;</span><br><span class="line"><span class="type">atomic_t</span>i_dio_count;</span><br><span class="line"><span class="type">atomic_t</span>i_writecount;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>*<span class="title">i_fop</span>;</span><span class="comment">/* former -&gt;i_op-&gt;default_file_ops */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_lock_context</span>*<span class="title">i_flctx</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span><span class="title">i_data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">i_devices</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>*<span class="title">i_pipe</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>*<span class="title">i_bdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>*<span class="title">i_cdev</span>;</span></span><br><span class="line"><span class="type">char</span>*i_link;</span><br><span class="line"><span class="type">unsigned</span>i_dir_seq;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__u32i_generation;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>*i_private; <span class="comment">/* fs or device private pointer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>inode_operations，这些实际是文件系统操作函数接口，也就是“虚拟文件系统”。实现了这些函数的，是真实文件系统。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">inode_operations</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dentry</span> * (*lookup) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * (*get_link) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> inode *, <span class="keyword">struct</span> delayed_call *);</span><br><span class="line"><span class="built_in">int</span> (*permission) (<span class="keyword">struct</span> inode *, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">posix_acl</span> * (*get_acl)(<span class="keyword">struct</span> inode *, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*readlink) (<span class="keyword">struct</span> dentry *, <span class="type">char</span> __user *,<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*create) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *, <span class="type">umode_t</span>, <span class="type">bool</span>);</span><br><span class="line"><span class="built_in">int</span> (*link) (<span class="keyword">struct</span> dentry *,<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *);</span><br><span class="line"><span class="built_in">int</span> (*unlink) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *);</span><br><span class="line"><span class="built_in">int</span> (*symlink) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,<span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line"><span class="built_in">int</span> (*mkdir) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,<span class="type">umode_t</span>);</span><br><span class="line"><span class="built_in">int</span> (*rmdir) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *);</span><br><span class="line"><span class="built_in">int</span> (*mknod) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,<span class="type">umode_t</span>,<span class="type">dev_t</span>);</span><br><span class="line"><span class="built_in">int</span> (*rename) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *,</span><br><span class="line"><span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="built_in">int</span> (*setattr) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> iattr *);</span><br><span class="line"><span class="built_in">int</span> (*getattr) (<span class="keyword">struct</span> vfsmount *mnt, <span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> kstat *);</span><br><span class="line"><span class="built_in">ssize_t</span> (*listxattr) (<span class="keyword">struct</span> dentry *, <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line"><span class="built_in">int</span> (*fiemap)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> fiemap_extent_info *, u64 start,</span><br><span class="line">      u64 len);</span><br><span class="line"><span class="built_in">int</span> (*update_time)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> timespec *, <span class="type">int</span>);</span><br><span class="line"><span class="built_in">int</span> (*atomic_open)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *,</span><br><span class="line">   <span class="keyword">struct</span> file *, <span class="type">unsigned</span> open_flag,</span><br><span class="line">   <span class="type">umode_t</span> create_mode, <span class="type">int</span> *opened);</span><br><span class="line"><span class="built_in">int</span> (*tmpfile) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *, <span class="type">umode_t</span>);</span><br><span class="line"><span class="built_in">int</span> (*set_acl)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> posix_acl *, <span class="type">int</span>);</span><br><span class="line">&#125; ____cacheline_aligned;</span><br></pre></td></tr></table></figure><h4 id="文件write接口"><a href="#文件write接口" class="headerlink" title="文件write接口"></a>文件write接口</h4><p>多进程读文件不用考虑竞争，因为没有修改文件。但写文件需要考虑多线程&#x2F;并发的竞争问题。</p><p>进程会记录操作文件的pos，读写文件从pos位置开始读写指定字节。pos 使用lseek系统调用设置。如果在指定位置写数据，需要先lseek到位置，再调用write调用写数据。write调用执行完pos位置会自动修改为旧pos+length。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">off_t</span> <span class="title">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span></span>;  <span class="comment">// whence可以选择SEEK_SET，SEEK_CUR，SEEK_END。offset是相对whence的位置</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> buf[.count], <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>lseek+write调用不是原子的，多进程&#x2F;线程写相同文件情况下，会导致数据错乱。linux提供pread&#x2F;pwrite调用支持传入offset 来随机读写文件，其内部是lseek+read&#x2F;write，但保证原子性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">pread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> buf[.count], <span class="type">size_t</span> count, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">pwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> buf[.count], <span class="type">size_t</span> count, <span class="type">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><p>多线程读写文件的原子性很重要，原子性有两层意思————不能数据错乱、也不能数据丢失。例如，多进程&#x2F;线程各自打开文件，向fd各自发出写请求A和B。原子性要求1. 不要求写入顺序，但要么A写完再写B、要么B写完再写A，不能存在A写了一半、然后B写、最后A写另一半这种场景，也就是说，不能数据错乱；2. 不能数据丢失，也就是说要么AB、要么BA，不能写完只有A或只有B。</p><p>除了pwrite, linux的append写也保证写入的原子性。append 标识在open时设置。因此，append写除了能利用磁盘顺序写提高性能，也容易实现并发原子性，相比随机写，是理想的底层存储写入策略。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags,  <span class="type">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>flag可以选择</p><ol><li>O_APPEND，The modification of the file offset and the write operation are performed as a single atomic step. </li><li>O_ASYNC，Enable signal-driven I&#x2F;O: generate a signal SIGIO bydefault</li><li>O_CLOEXEC，Enable the close-on-exec flag for the new file descriptor. 利用execve()执行子进程函数时，父进程的fd会关闭，防止传给新函数，避免资源逃逸导致泄露</li><li>O_CREAT，If pathname does not exist, create it as a regular file.</li><li>O_DIRECTORY，If pathname is not a directory, cause the open to fail.</li><li>O_NOFOLLOW，If the trailing component (i.e., basename) of pathname is a symbolic link, then the open fails, with the error ELOOP.</li><li>O_NONBLOCK，When possible, the file is opened in nonblocking mode.</li><li>O_PATH，Obtain a file descriptor that can be used for two purposes: to <strong>indicate a location in the filesystem tree</strong> and to perform operations that act purely at the file descriptor level</li><li>O_TRUNC，If the file already exists and is a regular file and the access mode allows writing (i.e., is O_RDWR or O_WRONLY) it will be truncated to length 0.</li><li>O_SYNC，O_DSYNC。Write operations on the file will complete according to the requirements of synchronized I&#x2F;O file integrity completion. 即分别保证元数据+数据、数据的完整性（落盘）</li><li>O_DIRECT，Try to minimize cache effects of the I&#x2F;O to and from this file. 即相较于O_SYNC, O_DIRECT是try best，不保证一定落盘（try best是兼顾性能和一致性的手段）</li><li>O_RDONLY，O_WRONLY，O_RDWR 打开方式</li><li></li></ol><p>mode_t 对新建文件有效，表示文件权限。</p><h3 id="page-cache"><a href="#page-cache" class="headerlink" title="page_cache"></a>page_cache</h3><p>page_cache维护，活跃队列（Active List）、不活跃队列（Inactive List）、脏页队列（Dirty Pages）、清理队列（Clean Pages）、写回队列（Writeback Pages）。<br>page_cache对page设置活跃页（Active Pages）、不活跃页（Inactive Pages）、脏页（Dirty Pages）、干净页（Clean Pages）四种状态。</p><p>page_cache采用write_back策略，原因是单机缓存，不用考虑多客户端访问的客户端缓存不一致问题。（服务端缓存可以write_back，客户端缓存需要write_through）</p><ol><li>page_cache处理和address_space的联系，如利用buddy算法申请一个空闲的内存页作为新的页缓存，page添加到 address_space 结构的 page_tree 中。</li><li>page_cache作为lru，实现缓存淘汰。lru_cache_add 函数把页缓存添加到 LRU 队列中。LRU 队列用于当系统内存不足时，对页缓存进行清理时使用。</li></ol><p>缺页中断由CPU触发，是一种硬中断。</p><ol><li>当 CPU 尝试访问某个虚拟地址时，检测到虚拟地址无效，无法通过页表找到对应的物理页面。触发缺页中断。</li><li>缺页中断处理函数尝试定位页来源，尝试从硬盘swap空间读page</li><li>当address_space发现要读的文件offset, length不在page cache中，不需要触发中断，直接调用处理函数从swap空间读page</li><li>page 读完后，唤醒阻塞的进程继续执行。</li></ol><h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><h3 id="网络协议栈"><a href="#网络协议栈" class="headerlink" title="网络协议栈"></a>网络协议栈</h3><p>传输层，确保数据可靠传输（TCP）或快速传输（UDP）。</p><ol><li>TCP Transmission Control Protocol面向连接、可靠传输，提供流量控制、拥塞控制、重传机制。</li><li>UDP User Datagram Protocol面向无连接、低延迟。</li></ol><p>网络层，负责数据包的寻址和路由，从源主机传输到目标主机。网络层数据包是网络间数据传输的基本单位。</p><ol><li>IP协议Internet Protocol，IPv4：经典的网络协议，基于 32 位地址。IPv6：下一代协议，基于 128 位地址，支持更大的地址空间。</li><li>TCMP协议Internet Control Message Protocol，用于网络诊断（如 ping）</li></ol><p>链路层，负责数据帧的封装与传输，连接网络接口（网卡），网卡使用MAC地址</p><ol><li>Ethernet：以太网协议。</li><li>PPP（Point-to-Point Protocol）：点对点协议。</li><li>802.11：无线局域网协议（Wi-Fi）</li></ol><h3 id="网络包"><a href="#网络包" class="headerlink" title="网络包"></a>网络包</h3><p>TCP网络包需要考虑飞着的请求，例如连接关闭时数据包可能还在网络中没有收到，所以连接主动关闭方需要TimeWait等待2MSL（Maximum Segment Lifetime，最大报文生存时间），等待对方数据包接收完毕，防止当前链接中飞着的数据包干扰下次链接。MSL 通常为30秒，因此TIME_WAIT状态持续2 × MSL，即60秒。</p><p>IP协议头中有一个TTL字段（time to live），TTL由源主机设置初始值，表示ip数据包可以经过的最大路由数，每经过一个路由器此值就减1，值为0则数据包将被丢弃</p><p>IPv4 包的最大总大小为 65,535 字节（由 16 位总长度字段决定）。</p><ul><li>最小大小：20 字节（没有数据）</li><li>最大大小：65,535 字节（包括头部和数据）</li></ul><h3 id="linux网络的可配置参数"><a href="#linux网络的可配置参数" class="headerlink" title="linux网络的可配置参数"></a>linux网络的可配置参数</h3><p>TODO</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;linux操作系统大致可分为进程管理、进程协调、内存管理、文件系统、网络管理等五大部分。本文讲述内存管理、文件系统、IO&amp;#x2F;网络管理。&lt;/p&gt;</summary>
    
    
    
    <category term="single-machine" scheme="https://larrystd.github.io/categories/single-machine/"/>
    
    
    <category term="single-machine" scheme="https://larrystd.github.io/tags/single-machine/"/>
    
    <category term="os" scheme="https://larrystd.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>linux操作系统总览(1)——进程管理，进程协调</title>
    <link href="https://larrystd.github.io/2024/12/06/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E8%A7%88(1)%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%92%8C%E5%8D%8F%E8%B0%83/"/>
    <id>https://larrystd.github.io/2024/12/06/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E8%A7%88(1)%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%92%8C%E5%8D%8F%E8%B0%83/</id>
    <published>2024-12-05T16:00:00.000Z</published>
    <updated>2025-01-04T01:14:30.196Z</updated>
    
    <content type="html"><![CDATA[<p>linux操作系统大致可分为进程管理、进程协调、内存管理、文件系统、网络管理等五大部分。本文讲述进程管理和进程协调。</p><span id="more"></span><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>进程管理的目的是将用户和内核创建的进程&#x2F;程序调度到cpu上执行，这些进程有三种</p><ol><li>用户程序创建的一次性运行完的进程</li><li>systemd等维护了常驻后台的后台进程，例如nginx，sshd</li><li>操作系统内核进程，例如kworker处理硬中断、信号、IO操作（包括cpu时间片硬中断调度、软中断抢占），kswapd管理页缓存和内存淘汰swap空间，watchdog检查内核死锁、防止系统卡死，ksoftirqd处理软中断，kblockd处理块设备IO，系统空闲线程（idle 线程）。这些进程一般定时执行。</li></ol><p>为什么cpu要执行idle线程？因为CPU需要执行指令才能保持正常运行。CPU按照“取指令（Fetch）—解码（Decode）—执行（Execute）”的周期运行。如果没有指令可以取，或者取到的指令无法正确解码，CPU无法正常工作。程序计数器（PC）用于指示下一条需要执行的指令地址。如果没有明确的任务，PC可能指向无效地址，导致不可预测的行为。</p><h3 id="进程队列"><a href="#进程队列" class="headerlink" title="进程队列"></a>进程队列</h3><p>进程管理器需要把已经创建的进程放入队列中, 进程排队接受多核cpu的处理。</p><p>进程调度器有很多设计值得学习的，例如</p><ol><li>就绪任务采用优先级队列组织，支持任务公平调度和任务抢占</li><li>存在等待队列存放需要等待较长时间，需要唤醒的任务</li><li>停止队列支持任务暂停和断点继续执行</li><li>任务执行前创建结构，执行完销毁结构</li></ol><h4 id="就绪队列（Ready-Queue）"><a href="#就绪队列（Ready-Queue）" class="headerlink" title="就绪队列（Ready Queue）"></a>就绪队列（Ready Queue）</h4><p>就绪队列是一个<strong>优先级队列</strong>。</p><p>新创建的进程会放入就绪队列Ready Queue，等待队列是进程调度的对象，将这些进程调度给CPU执行。Linux使用 CFS调度器（完全公平调度器） 管理就绪队列。CFS调度器通过一个红黑树（rb_tree）来组织进程，就绪队列中的每个进程以其虚拟运行时间作为排序依据。</p><p>调度器从红黑树中选择虚拟运行时间最小的进程进行执行。当进程时间片用完，或被抢占，进程更新虚拟运行时间后重新插入到就绪队列</p><p>就绪队列中进程的状态是R (TASK_RUNNING)</p><h4 id="等待队列（Wait-Queue）"><a href="#等待队列（Wait-Queue）" class="headerlink" title="等待队列（Wait Queue）"></a>等待队列（Wait Queue）</h4><p>进程在等待某些事件（如IO完成、信号到达、锁释放）时进入该队列。对应进程S状态和D状态</p><p>进程S状态TASK_INTERRUPTIBLE，可中断的睡眠状态。例如等待锁，等待socket事件。该状态进程可被调度器调度。</p><p>D状态TASK_UNINTERRUPTIBLE，不可中断的睡眠状态。该状态进程无法响应信号，无法被调度，只能等待IO执行完毕（但可以响应硬中断）。例如进程等待磁盘IO期间无法中断，原因1. 进程没必要被中断，数据到不了中断也处理不了什么 2. 简化实现，防止IO读写没有进程处理导致问题 3. 避免由于磁盘等故障导致大量进程持续中断。</p><p>对于持有spinlock的进程需要屏蔽中断，但这时候的进程不是等待状态。</p><h4 id="停止队列（Stopped-Queue）"><a href="#停止队列（Stopped-Queue）" class="headerlink" title="停止队列（Stopped Queue）"></a>停止队列（Stopped Queue）</h4><p>进程被暂停（例如接收到SIGSTOP信号）后进入该队列，例如ptrace机制调试进程时会暂停某些进程，放入停止队列中。</p><p>停止队列中的进程不会被调度器调度，直到接收到恢复信号（如SIGCONT）。</p><h4 id="僵尸队列（Zombie-Queue）"><a href="#僵尸队列（Zombie-Queue）" class="headerlink" title="僵尸队列（Zombie Queue）"></a>僵尸队列（Zombie Queue）</h4><p>包含所有处于TASK_ZOMBIE状态的进程。僵尸进程是已结束执行但尚未被其父进程回收的进程。</p><p>父进程调用wait族函数等待子进程执行完并回收时，僵尸进程会被从队列中移除。</p><p>TASK_DEAD状态的进程会被系统回收所有资源，释放进程控制块（PCB）。</p><h3 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h3><p>实时进程优先级：范围从 1 到 99（高优先级）。实时进程调度时，高优先级的进程必须执行完毕或主动放弃 CPU，低优先级的进程才能运行。</p><p>普通进程优先级：范围从 100 到 139（低优先级）。默认优先级为 120。普通进程使用 完全公平调度器（CFS），CFS中，执行时间少的进程在计算时会有较高的动态优先级。</p><h4 id="普通进程优先级"><a href="#普通进程优先级" class="headerlink" title="普通进程优先级"></a>普通进程优先级</h4><p>可以通过 nice 或 renice 命令设置普通进程的静态优先级。范围：-20（最高优先级）到 19（最低优先级）。<strong>nice默认值为 0。</strong><br>nice 值越低，进程优先级越高。</p><p>内核线程是由内核创建并运行的任务，通常用于关键系统功能，优先级由内核自行分配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进程类别优先级范围优先级特点</span><br><span class="line">kswapd高内存页面交换线程，优先级较高</span><br><span class="line">kworker高内核工作队列处理线程</span><br><span class="line">khugepaged中大页面分配优化</span><br><span class="line">jbd2中日志缓冲区管理线程</span><br></pre></td></tr></table></figure><p>系统服务和守护进程通常负责后台任务，默认优先级设置中等，以确保它们不会过多占用 CPU，但仍能及时响应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">进程类别默认 Nice 值优先级特点</span><br><span class="line">init/systemd0系统初始化进程，优先级适中</span><br><span class="line">cron0定时任务调度器，重要但无需实时响应</span><br><span class="line">sshd0远程登录服务，优先级适中</span><br><span class="line">udevd0设备管理服务，实时性要求中等</span><br><span class="line">NetworkManager0网络管理，重要性较高</span><br><span class="line">rsyslogd0日志服务，优先级适中</span><br></pre></td></tr></table></figure><h3 id="完全公平调度CFS"><a href="#完全公平调度CFS" class="headerlink" title="完全公平调度CFS"></a>完全公平调度CFS</h3><ol><li>操作系统统计周期内每个进程的执行时间，这个执行时间是个虚拟执行时间vriture_runtime，计算时会考虑进程优先级，优先级高的进程统计的执行时间会偏少。</li><li>执行时间少的进程在下个周期优先执行</li></ol><p>进程切换，Linux内核使用定时器硬中断来实现时间片轮转调度。当定时器中断发生时，内核会检查当前运行的进程是否超过其时间片。是则进行进程切换。定时器中断的频率通常为100Hz或1000Hz，表示每隔10ms或1ms中断一次。</p><h2 id="进程协调"><a href="#进程协调" class="headerlink" title="进程协调"></a>进程协调</h2><p>进程协调的手段包括两个部分</p><ol><li>协调进程切换，包括信号、硬&#x2F;软中断、系统调用</li><li>协调进程&#x2F;线程同步，包括锁、条件变量、信号量等</li></ol><h3 id="协调进程切换"><a href="#协调进程切换" class="headerlink" title="协调进程切换"></a>协调进程切换</h3><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>当进程从执行用户代码转向执行内核代码时，就发生系统调用。需要注意该过程不发生进程切换。</p><ol><li>进入内核代码前，进程首先调用<code>int $0x80</code>或<code>syscall指令</code>，该指令会让CPU转向执行（entry_INT80_32或entry_SYSCALL_64）汇编代码，即根据系统调⽤号调⽤对应的内核处理函数。</li><li>执行内核处理函数前，cpu 将当前寄存器内容保存到用户栈，使用内核栈执行内核处理函数</li><li>内核处理函数执行完后，调用sysret 指令从用户栈恢复寄存器内容，使用用户栈继续执行用户程序</li></ol><p>为什么执行内核代码需要调用<code>int $0x80</code>或syscall指令，而不是直接函数调用的形式执行？<br>因为系统调用状态的保存是CPU硬件实现的，CPU的两个寄存器</p><p>MSR_LSTAR：保存内核系统调用入口的地址。<br>MSR_STAR：保存用户态和内核态的代码段选择器。</p><p>在syscall指令中，寄存器保存用户栈，执行内核函数，恢复用户栈都是硬件实现的。只需要调用CPU指令。操作系统只需要配置相关寄存器然后调用指令即可。</p><p>在<code>int $0x80</code>中，寄存器保存用户栈，执行内核函数，恢复用户栈是操作系统软件实现的（性能差于syscall，现代CPU基本使用后者），操作系统把处理函数注册到中断向量表IDT的0x80位置。当进程执行int $0x80指令，CPU会自动从寄存器找到IDT地址，转向执行处理函数（IDT的地址存放在寄存器IDT 寄存器（IDTR））。“CPU从寄存器找到IDT，转向执行处理函数”这是硬件实现的。</p><h4 id="硬中断和中断向量表"><a href="#硬中断和中断向量表" class="headerlink" title="硬中断和中断向量表"></a>硬中断和中断向量表</h4><p>上面说到，系统调用可以通过发起<code>int $0x80</code>指令，CPU自动从中断向量表找到处理函数。中断向量表IDT是中断执行的核心，中断函数由操作系统注册，但无法直接执行，只能借助cpu中断表执行。中断优先级与向量号直接相关，向量号越低优先级越高。</p><p>硬中断和中断向量表，中断的对象是CPU。通过CPU引脚信号&#x2F;CPU指令来触发中断。硬中断可以抢占CPU，一般来说，如果用户态进程发生了硬中断&#x2F;异常，执行硬中断处理函数的进程和用户态进程是一个。如果硬中断不是由用户态进程产生，例如时间片用尽、磁盘网络IO中断，中断处理函数由kworker 执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  Vectors   0 ...  31 : system traps and exceptions - hardcoded events</span></span><br><span class="line"><span class="comment">*  Vectors  32 ... 127 : device interrupts</span></span><br><span class="line"><span class="comment">*  Vector  128         : legacy int80 syscall interface</span></span><br><span class="line"><span class="comment">*  Vectors 129 ... INVALIDATE_TLB_VECTOR_START-1 except 204 : device interrupts</span></span><br><span class="line"><span class="comment">*  Vectors INVALIDATE_TLB_VECTOR_START ... 255 : special interrupts</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>0-31中保存的是异常的中断向量，这些异常包括除0、断点调试、边界溢出、段错误、浮点数异常等，中断处理会转向执行查找进程对应的异常处理函数，默认是异常退出进程（向进程发SIGINT信号,程序异常退出）</p><p>为什么使用中断处理异常？因为异常是运行态的，程序编译后并不知道异常会不会执行。<strong>当CPU执行遇到异常后，不能继续执行原程序的指令。</strong> 只能去IDT执行异常函数的处理指令。</p><p>CPU转向执行异常，需要1. 停止当前指令执行; 2. 保存 CPU 状态; 3. 跳转到指定的处理程序处理。</p><p>CPU&#x2F;进程上下文切换也是通过硬中断实现，同样需要1. 停止当前进程指令执行; 2. 保存 CPU 状态; 3. 跳转转型下一个进程的指令。CPU&#x2F;进程上下文是否切换 等价于 是否出现硬中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Interrupts/Exceptions */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">X86_TRAP_DE = <span class="number">0</span>,<span class="comment">/*  0, Divide-by-zero */</span></span><br><span class="line">X86_TRAP_DB,<span class="comment">/*  1, Debug */</span></span><br><span class="line">X86_TRAP_NMI,<span class="comment">/*  2, Non-maskable Interrupt */</span></span><br><span class="line">X86_TRAP_BP,<span class="comment">/*  3, Breakpoint */</span></span><br><span class="line">X86_TRAP_OF,<span class="comment">/*  4, Overflow */</span></span><br><span class="line">X86_TRAP_BR,<span class="comment">/*  5, Bound Range Exceeded */</span></span><br><span class="line">X86_TRAP_UD,<span class="comment">/*  6, Invalid Opcode */</span></span><br><span class="line">X86_TRAP_NM,<span class="comment">/*  7, Device Not Available */</span></span><br><span class="line">X86_TRAP_DF,<span class="comment">/*  8, Double Fault */</span></span><br><span class="line">X86_TRAP_OLD_MF,<span class="comment">/*  9, Coprocessor Segment Overrun */</span></span><br><span class="line">X86_TRAP_TS,<span class="comment">/* 10, Invalid TSS */</span></span><br><span class="line">X86_TRAP_NP,<span class="comment">/* 11, Segment Not Present */</span></span><br><span class="line">X86_TRAP_SS,<span class="comment">/* 12, Stack Segment Fault */</span></span><br><span class="line">X86_TRAP_GP,<span class="comment">/* 13, General Protection Fault */</span></span><br><span class="line">X86_TRAP_PF,<span class="comment">/* 14, Page Fault */</span></span><br><span class="line">X86_TRAP_SPURIOUS,<span class="comment">/* 15, Spurious Interrupt */</span></span><br><span class="line">X86_TRAP_MF,<span class="comment">/* 16, x87 Floating-Point Exception */</span></span><br><span class="line">X86_TRAP_AC,<span class="comment">/* 17, Alignment Check */</span></span><br><span class="line">X86_TRAP_MC,<span class="comment">/* 18, Machine Check */</span></span><br><span class="line">X86_TRAP_XF,<span class="comment">/* 19, SIMD Floating-Point Exception */</span></span><br><span class="line">X86_TRAP_IRET = <span class="number">32</span>,<span class="comment">/* 32, IRET Exception */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>向量 32 到 127，分配给硬件中断和其他系统用途。硬件中断的触发，连接cpu引脚的硬件会向引脚发送信号，cpu收到信号会立即暂停当前程序处理（屏蔽中断的除外），从idt中找到硬件中断处理函数执行。</p><p>对需要较长时间处理的中断，例如网卡磁盘收发数据。为了时效性，硬件中断处理函数只是创建一个异步任务到队列就返回，任务具体的处理由后续软中断负责。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">IRQ    中断号用途</span><br><span class="line">IRQ 032系统定时器（时钟中断）</span><br><span class="line">IRQ 133键盘</span><br><span class="line">IRQ 234可编程中断控制器级联</span><br><span class="line">IRQ 335串口 2</span><br><span class="line">IRQ 436串口 1</span><br><span class="line">IRQ 537并口 2 / 声卡</span><br><span class="line">IRQ 638软盘控制器</span><br><span class="line">IRQ 739并口 1</span><br><span class="line">IRQ 840CMOS 实时时钟</span><br><span class="line">IRQ 941可用（通常用于 ACPI）</span><br><span class="line">IRQ 1042可用</span><br><span class="line">IRQ 1143可用</span><br><span class="line">IRQ 1244PS/2 鼠标</span><br><span class="line">IRQ 1345协处理器 / FPU</span><br><span class="line">IRQ 1446主 IDE 控制器</span><br><span class="line">IRQ 1547从 IDE 控制器</span><br></pre></td></tr></table></figure><p>向量 128（0x80），用于系统调用（如 int $0x80）。</p><p>向量 129 到 255，用户自定义的硬中断。例如，int 0x81：某些调试工具可能使用该中断来与内核交互；int 0xFF：某些实时系统可能定义为特殊的系统功能调用；APIC 定时器通常分配到高向量。</p><h4 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h4><p>软中断和软中断向量表，是内核软件层实现的（软中断号，处理函数）的映射，目的是异步任务延迟调度，没有直接影响到CPU，不抢占CPU。软中断和是否出现CPU&#x2F;进程上下文切换没有联系。</p><p>软中断通过内核代码调用 raise_softirq() 触发。主要可以分为1. 定时器（很重要，比如处理超时锁等待，sleep超时） 2. 网络发送接收 3. 块设备IO 4. Tasklet 等类型。Tasklet是用户注册的一种函数，该函数和软中断一起被执行。</p><p>每个cpu维护一个软中断队列，软中断的执行不会切换CPU。如果CPU软中断占用时间长，可能是网络包是大量的小包，也可能是磁盘&#x2F;网络处理慢。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">软中断号名称用途</span><br><span class="line">0HI_SOFTIRQ高优先级任务，通常用于调度紧急操作。</span><br><span class="line">1TIMER_SOFTIRQ定时器中断，用于触发周期性任务，如更新系统时间，超时唤醒等待的进程。</span><br><span class="line">2NET_TX_SOFTIRQ网络发送中断，用于网络数据的发送操作。</span><br><span class="line">3NET_RX_SOFTIRQ网络接收中断，用于处理接收到的网络数据包。</span><br><span class="line">4BLOCK_SOFTIRQ块设备中断，用于处理块设备的异步 I/O 操作。</span><br><span class="line">5IRQ_POLL_SOFTIRQ中断轮询，用于处理某些设备的中断轮询机制。</span><br><span class="line">6TASKLET_SOFTIRQTasklet 中断，用于调度较低优先级的任务。</span><br><span class="line">7SCHED_SOFTIRQ调度中断，用于进程调度器的运行队列更新。</span><br><span class="line">8HRTIMER_SOFTIRQ高精度定时器中断，用于处理精确的定时器任务。</span><br><span class="line">9RCU_SOFTIRQRCU（Read-Copy-Update）机制，用于内存管理。</span><br></pre></td></tr></table></figure><p>软中断的处理时机</p><ol><li><strong>硬中断处理完成后</strong>，内核会检查是否有挂起的软中断。如果有则执行</li><li><strong>在某些内核路径中</strong>，内核会主动调用 do_softirq() 来检查和执行挂起的软中断。例如网络协议栈处理数据包时，通过 net_rx_action() 调用软中断；高精度定时器中，触发 hrtimer 相关软中断。</li></ol><p>软中断的优先级高于普通任务。当软中断执行时间较长、内核会将剩余未处理的软中断交给专用线程 ksoftirqd 来执行。</p><h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><p>软中断和信号的区别是，软中断是CPU级别的，软中断得到的网络包、磁盘数据包需要另外拷贝到进程空间才能被进程使用。而信号是针对进程的。也就是说，操作系统为每个CPU维护一个软中断任务队列，但每个进程都维护了自己的信号任务队列。</p><p>信号执行的时机</p><ol><li>进程从系统态返回到用户态的前夕，也就是一个用户态的进程由于系统调用、硬中断（进程切换）或异常而进入系统空间，执行完后返回用户态前，处理信号</li><li>进程在进入等待队列后刚被唤醒的时候</li></ol><p>信号可以由内核发起（内核想影响某进程的执行，主要是通知某进程终止）就给该进程发个信号，虽然都是通知进程退出，但退出原因不同。退出原因可以是终端中断，中断退出，杀死，运算错误，段错误等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#define SIGHUP 1终端挂起或控制进程终止</span><br><span class="line">#define SIGINT 2终端中断(Ctrl+C 组合键)</span><br><span class="line">#define SIGQUIT 3终端退出(Ctrl+\组合键)</span><br><span class="line">#define SIGILL 4非法指令</span><br><span class="line">#define SIGTRAP 5debug 使用，有断点指令产生</span><br><span class="line">#define SIGABRT 6由 abort(3)发出的退出指令</span><br><span class="line">#define SIGIOT 6IOT 指令</span><br><span class="line">#define SIGBUS 7总线错误</span><br><span class="line">#define SIGFPE 8浮点运算错误</span><br><span class="line">#define SIGKILL 9杀死、终止进程</span><br><span class="line">#define SIGUSR1 10用户自定义信号 1</span><br><span class="line">#define SIGSEGV 11段违例(无效的内存段)</span><br><span class="line">#define SIGUSR2 12用户自定义信号 2</span><br><span class="line">#define SIGPIPE 13向非读管道写入数据</span><br><span class="line">#define SIGALRM 14闹钟</span><br><span class="line">#define SIGTERM 15软件终止</span><br><span class="line">#define SIGSTKFLT 16栈异常</span><br><span class="line">#define SIGCHLD 17子进程结束</span><br><span class="line">#define SIGCONT 18进程继续</span><br><span class="line">#define SIGSTOP 19停止进程的执行，只是暂停</span><br><span class="line">#define SIGTSTP 20停止进程的运行(Ctrl+Z 组合键)</span><br><span class="line">#define SIGTTIN 21后台进程需要从终端读取数据</span><br><span class="line">#define SIGTTOU 22后台进程需要向终端写数据</span><br><span class="line">#define SIGURG 23有&quot;紧急&quot;数据</span><br><span class="line">#define SIGXCPU 24超过 CPU 资源限制</span><br><span class="line">#define SIGXFSZ 25文件大小超额</span><br><span class="line">#define SIGVTALRM 26虚拟时钟信号</span><br><span class="line">#define SIGPROF 27时钟信号描述</span><br><span class="line">#define SIGWINCH 28窗口大小改变</span><br><span class="line">#define SIGIO 29可以进行输入/输出操作</span><br><span class="line">#define SIGPOLLSIGIO</span><br><span class="line">#define SIGPWR 30断点重启</span><br><span class="line">#define SIGSYS 31非法的系统调用</span><br><span class="line">#define SIGUNUSED 32未使用信号</span><br></pre></td></tr></table></figure><p>磁盘&#x2F;网络数据可读可写也可以通过SIGIO信号通知到进程，也就是所说的“信号驱动式IO”。但更广泛的是通过事件通知。除了信号驱动和事件通知（非阻塞IO），进程默认是阻塞等待数据可读可写，这是通过软中断实现。软中断获得数据并把数据拷贝到进程空间后，会唤醒正在睡眠的进程，将进程从等待队列转到就绪队列。</p><h4 id="事件通知"><a href="#事件通知" class="headerlink" title="事件通知"></a>事件通知</h4><p>采用阻塞IO的进程会有先进入等待队列，数据就绪后重新进入就绪队列的逻辑。如果采用非阻塞IO，进程不会进入等待队列。</p><p>linux的字符设备&#x2F;块设备&#x2F;网络IO ，在进程中可以用文件描述符fd标识。设置文件描述符为非阻塞模式（O_NONBLOCK）从而采用非阻塞IO。</p><p>文件描述符可以与多个事件关联，这些事件表示文件描述符的状态变化，例如数据可读、可写或发生错误。linux 内部采用了事件通知的模型</p><ol><li>消费者（进程）注册感兴趣的事件和事件回调函数，例如进程注册感兴趣的读写事件</li><li>软中断将数据拷贝到用户进程空间后，会匹配注册的事件，执行对应的事件处理函数。<ol><li>如果是select&#x2F;poll，事件处理函数就是把事件设置到select 列表对应的fd，等待进程轮询找到满足事件的fd</li><li>如果是epoll，事件处理函数就是从红黑树找到对应等待的文件描述符，将fd转移到就绪队列，唤醒阻塞在epoll_wait等待的进程。epoll_wait还会通过超时解除阻塞。</li></ol></li></ol><p>事件通知驱动和主动轮询驱动 对协调模块的设计，例如消息队列， 也具有很大参考意义</p><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>锁是协调多个任务对临界区的执行，锁保证，一个任务要么独占执行完临界区，要么不执行临界区，不允许临界区同时被多个任务执行。</p><p>单机锁主要有三种，自旋锁，互斥锁，读写锁。自旋锁是互斥锁一种特殊实现</p><ol><li>spinlock 主要是保护多cpu操作对象的安全，可以是cpu共享的硬件变量，为了防止死锁，加spinlock需要屏蔽当前cpu的中断。<a href="https://www.cnblogs.com/dream397/p/15902203.html">为了防止死锁，spinlock需要关中断和禁止抢占</a></li><li>mutex，存放在内存的共享变量，维护多线程的安全</li><li>读写锁，使用count实现。读锁count-1，写锁count-很大的magic number。通过count值能知道目前持有读锁还是写锁。读写锁问题是读操作不需要等待，如果对象持续被读，写会被饿死。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;linux操作系统大致可分为进程管理、进程协调、内存管理、文件系统、网络管理等五大部分。本文讲述进程管理和进程协调。&lt;/p&gt;</summary>
    
    
    
    <category term="single-machine" scheme="https://larrystd.github.io/categories/single-machine/"/>
    
    
    <category term="single-machine" scheme="https://larrystd.github.io/tags/single-machine/"/>
    
    <category term="os" scheme="https://larrystd.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://larrystd.github.io/2024/12/05/hello-world/"/>
    <id>https://larrystd.github.io/2024/12/05/hello-world/</id>
    <published>2024-12-04T16:00:00.000Z</published>
    <updated>2025-01-04T01:14:22.232Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    <category term="hello" scheme="https://larrystd.github.io/categories/hello/"/>
    
    
    <category term="hello" scheme="https://larrystd.github.io/tags/hello/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建之旅</title>
    <link href="https://larrystd.github.io/2024/12/05/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E6%97%85/"/>
    <id>https://larrystd.github.io/2024/12/05/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E6%97%85/</id>
    <published>2024-12-04T16:00:00.000Z</published>
    <updated>2025-01-04T01:15:07.408Z</updated>
    
    <content type="html"><![CDATA[<p>使用hexo 搭建博客</p><span id="more"></span><h2 id="hexo-博客搭建"><a href="#hexo-博客搭建" class="headerlink" title="hexo 博客搭建"></a>hexo 博客搭建</h2><h3 id="step1，准备node-npm环境"><a href="#step1，准备node-npm环境" class="headerlink" title="step1，准备node, npm环境"></a>step1，准备node, npm环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh | bash</span><br><span class="line">nvm install node</span><br><span class="line"></span><br><span class="line">node -v</span><br><span class="line">npm install npm -g  </span><br></pre></td></tr></table></figure><h3 id="step2，安装和部署hexo"><a href="#step2，安装和部署hexo" class="headerlink" title="step2，安装和部署hexo"></a>step2，安装和部署hexo</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装hexo</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line">npm install -g hexo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">部署hexo</span></span><br><span class="line">hexo init tech-blog</span><br><span class="line">cd tech-blog</span><br><span class="line">npm install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载主题到themes目录，这里选择maupassant主题</span></span><br><span class="line">git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant</span><br><span class="line">npm install hexo-renderer-pug --save</span><br><span class="line">npm install hexo-renderer-sass-next --save</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个页面</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行博客，本地执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><h3 id="3-配置github-pages"><a href="#3-配置github-pages" class="headerlink" title="3. 配置github pages"></a>3. 配置github pages</h3><p>在github创建{username}.github.io仓库，例如我的github用户名为larrystd，仓库名就是larrystd.github.io。仓库需要设置成public</p><p>在.&#x2F;_config.yml文件增加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:larrystd/larrystd.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>之后执行hexo g &amp;&amp; hexo d，可自动将打包后的静态文件上传到github的仓库</p><p>在larrystd.github.io仓库点击Settings-Pages，Build and deployment-source选择Deploy from branch，branch选择master &#x2F;(root)</p><h3 id="4-配置本地搜索"><a href="#4-配置本地搜索" class="headerlink" title="4. 配置本地搜索"></a>4. 配置本地搜索</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./themes/manupassant/_config.yml增加</span></span><br><span class="line">self_search: true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令行执行</span></span><br><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><h3 id="5-配置字数统计"><a href="#5-配置字数统计" class="headerlink" title="5. 配置字数统计"></a>5. 配置字数统计</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./themes/manupassant/_config.yml增加</span></span><br><span class="line">wordcount: true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令行执行</span></span><br><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><h3 id="6-配置gitalk评论插件"><a href="#6-配置gitalk评论插件" class="headerlink" title="6. 配置gitalk评论插件"></a>6. 配置gitalk评论插件</h3><p>点击<a href="https://github.com/settings/applications/new%EF%BC%8C%E7%94%B3%E8%AF%B7OAuth">https://github.com/settings/applications/new，申请OAuth</a> application。Homepage URL和Authorization callback URL均填写{username}.github.io</p><p>复制Client ID和Client secrets</p><p>github再创一个repo，例如blog</p><p>.&#x2F;themes&#x2F;manupassant&#x2F;_config.yml增加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gitalk: ## See: https://github.com/gitalk/gitalk</span><br><span class="line">  enable: true ## If you want to use Gitment comment system please set the value to true.</span><br><span class="line">  owner: $&#123;username&#125; ## Your GitHub ID, e.g. username</span><br><span class="line">  repo: blog ## The repository to store your comments, make sure you&#x27;re the repo&#x27;s owner, e.g. gitalk.github.io</span><br><span class="line">  client_id: xxx ## GitHub client ID, e.g. 75752dafe7907a897619</span><br><span class="line">  client_secret: xxx ## GitHub client secret, e.g. ec2fb9054972c891289640354993b662f4cccc50</span><br><span class="line">  admin: $&#123;username&#125; ## Github repo owner and collaborators, only these guys can initialize github issues.</span><br></pre></td></tr></table></figure><p>最终的.&#x2F;_config.yml配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Infinity</span> <span class="string">Code</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;Simplicity is the soul of efficiency.&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">infinity</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitrssHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://larrystd.github.io</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># Apply to the whole site</span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">syntax_highlighter:</span> <span class="string">highlight.js</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">prismjs:</span></span><br><span class="line">  <span class="attr">preprocess:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">mathjax2:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Metadata elements</span></span><br><span class="line"><span class="comment">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span></span><br><span class="line"><span class="attr">meta_generator:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="string">HH:mm:ss</span></span><br><span class="line"><span class="comment">## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;</span></span><br><span class="line"><span class="attr">updated_option:</span> <span class="string">&#x27;mtime&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Include / Exclude file(s)</span></span><br><span class="line"><span class="comment">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span></span><br><span class="line"><span class="attr">include:</span></span><br><span class="line"><span class="attr">exclude:</span></span><br><span class="line"><span class="attr">ignore:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">maupassant</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:larrystd/larrystd.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>themes&#x2F;maupassant&#x2F;_config.yml 配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">disqus:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment">## If you want to use Disqus comment system, please set the value to true.</span></span><br><span class="line">  <span class="attr">shortname:</span> <span class="comment">## Your disqus_shortname, e.g. username</span></span><br><span class="line">  <span class="attr">api:</span> <span class="comment">## You can visit Disqus comments in China mainland without barriers using Disqus API, e.g. https://disqus.skk.moe/disqus/</span></span><br><span class="line">  <span class="attr">apikey:</span> <span class="comment">## Your API key obtained in Disqus API Application, e.g. yk00ZB1fjYGRkrCrDDRYDUjpp26GJWJiJRZQZ5SY0r3th5FMW6pnSzQMnWH7ua7r</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="comment">## Username of your Disqus moderator, e.g. username</span></span><br><span class="line">  <span class="attr">admin_label:</span> <span class="comment">## The text of Disqus moderator badge, e.g. Mod</span></span><br><span class="line"><span class="attr">uyan:</span> <span class="comment">## Your uyan_id. e.g. 1234567</span></span><br><span class="line"><span class="attr">livere:</span> <span class="comment">## Your livere data-uid, e.g. MTAyMC8zMDAxOC78NTgz</span></span><br><span class="line"><span class="attr">changyan:</span> <span class="comment">## Your changyan appid, e.g. cyrALsXc8</span></span><br><span class="line"><span class="attr">changyan_conf:</span> <span class="comment">## Your changyan conf, e.g. prod_d8a508c2825ab57eeb43e7c69bba0e8b</span></span><br><span class="line"><span class="attr">gitalk:</span> <span class="comment">## See: https://github.com/gitalk/gitalk</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">## If you want to use Gitment comment system please set the value to true.</span></span><br><span class="line">  <span class="attr">owner:</span> <span class="string">larrystd</span> <span class="comment">## Your GitHub ID, e.g. username</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">blogtalk</span> <span class="comment">## The repository to store your comments, make sure you&#x27;re the repo&#x27;s owner, e.g. gitalk.github.io</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">xxx</span> <span class="comment">## GitHub client ID, e.g. 75752dafe7907a897619</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">xxx</span> <span class="comment">## GitHub client secret, e.g. ec2fb9054972c891289640354993b662f4cccc50</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="string">larrystd</span> <span class="comment">## Github repo owner and collaborators, only these guys can initialize github issues.</span></span><br><span class="line"><span class="attr">valine:</span> <span class="comment">## See: https://valine.js.org</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment">## If you want to use Valine comment system, please set the value to true.</span></span><br><span class="line">  <span class="attr">appid:</span> <span class="comment">## Your LeanCloud application App ID, e.g. pRBBL2JR4N7kLEGojrF0MsSs-gzGzoHsz</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="comment">## Your LeanCloud application App Key, e.g. tjczHpDfhjYDSYddzymYK1JJ</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment">## Mail notifier, see https://github.com/xCss/Valine/wiki/Valine-评论系统中的邮件提醒设置</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment">## Validation code.</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">Just</span> <span class="string">so</span> <span class="string">so</span> <span class="comment">## Comment box placeholders.</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">&quot;mm&quot;</span> <span class="comment">## Gravatar type, see https://github.com/xCss/Valine/wiki/avatar-setting-for-valine</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment">## Number of comments per page.</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment">## Attributes of reviewers.</span></span><br><span class="line"><span class="attr">minivaline:</span> <span class="comment">## See: https://github.com/MiniValine/MiniValine</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment">## If you want to use MiniValine comment system, please set the value to true.</span></span><br><span class="line">  <span class="attr">appId:</span> <span class="comment">## Your LeanCloud application App ID, e.g. pRBBL2JR4N7kLEGojrF0MsSs-gzGzoHsz</span></span><br><span class="line">  <span class="attr">appKey:</span> <span class="comment">## Your LeanCloud application App Key, e.g. tjczHpDfhjYDSYddzymYK1JJ</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">Write</span> <span class="string">a</span> <span class="string">Comment</span> <span class="comment">## Comment box placeholder.</span></span><br><span class="line">  <span class="attr">adminEmailMd5:</span> <span class="comment">## The MD5 of Admin Email to show Admin Flag.</span></span><br><span class="line">  <span class="attr">math:</span> <span class="literal">true</span> <span class="comment">## Support MathJax.</span></span><br><span class="line">  <span class="attr">md:</span> <span class="literal">true</span> <span class="comment">## Support Markdown.</span></span><br><span class="line">  <span class="comment"># MiniValine&#x27;s display language depends on user&#x27;s browser or system environment</span></span><br><span class="line">  <span class="comment"># If you want everyone visiting your site to see a uniform language, you can set a force language value</span></span><br><span class="line">  <span class="comment"># Available values: en  | zh-CN | (and many more)</span></span><br><span class="line">  <span class="comment"># More i18n info: https://github.com/MiniValine/minivaline-i18n</span></span><br><span class="line">  <span class="attr">lang:</span></span><br><span class="line"><span class="attr">waline:</span> <span class="comment">## See: https://waline.js.org/</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment">## If you want to use Waline comment system, please set the value to true.</span></span><br><span class="line">  <span class="attr">serverURL:</span> <span class="comment">## Your server url, e.g. https://your-domain.vercel.app</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="comment">## The desired number of comments shown in each page.</span></span><br><span class="line"><span class="attr">utterances:</span> <span class="comment">## See: https://utteranc.es</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment">## If you want to use Utterances comment system, please set the value to true.</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="comment">## The repository utterances will connect to, e.g. tufu9441/comments</span></span><br><span class="line">  <span class="attr">identifier:</span> <span class="string">title</span> <span class="comment">## The mapping between blog posts and GitHub issues.</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">github-light</span> <span class="comment">## Choose an Utterances theme which matches your blog.</span></span><br><span class="line"><span class="attr">twikoo:</span> <span class="comment">## See: https://twikoo.js.org</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment">## If you want to use twikoo comment system, please set the value to true.</span></span><br><span class="line">  <span class="attr">envId:</span> <span class="comment">## Tencent CloudBase envId</span></span><br><span class="line">  <span class="attr">region:</span> <span class="comment">## Tencent CloudBase region, e.g. ap-shanghai</span></span><br><span class="line">  <span class="attr">path:</span> <span class="comment">## Article path, e.g. window.location.pathname</span></span><br><span class="line"></span><br><span class="line"><span class="attr">google_search:</span> <span class="literal">false</span> <span class="comment">## Use Google search, true/false.</span></span><br><span class="line"><span class="attr">baidu_search:</span> <span class="literal">false</span> <span class="comment">## Use Baidu search, true/false.</span></span><br><span class="line"><span class="attr">swiftype:</span> <span class="comment">## Your swiftype_key, e.g. m7b11ZrsT8Me7gzApciT</span></span><br><span class="line"><span class="attr">self_search:</span> <span class="literal">true</span> <span class="comment">## Use a jQuery-based local search engine, true/false.</span></span><br><span class="line"><span class="attr">google_analytics:</span> <span class="comment">## Your Google Analytics tracking id, e.g. UA-42425684-2</span></span><br><span class="line"><span class="attr">baidu_analytics:</span> <span class="comment">## Your Baidu Analytics tracking id, e.g. 8006843039519956000</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span> <span class="comment">## If you want to use fancybox please set the value to true.</span></span><br><span class="line"><span class="attr">show_category_count:</span> <span class="literal">false</span> <span class="comment">## If you want to show the count of categories in the sidebar widget please set the value to true.</span></span><br><span class="line"><span class="attr">toc_number:</span> <span class="literal">true</span> <span class="comment">## If you want to add list number to toc please set the value to true.</span></span><br><span class="line"><span class="attr">shareto:</span> <span class="literal">false</span> <span class="comment">## If you want to use the share button please set the value to true, and you must have hexo-helper-qrcode installed.</span></span><br><span class="line"><span class="attr">busuanzi:</span> <span class="literal">false</span> <span class="comment">## If you want to use Busuanzi page views please set the value to true.</span></span><br><span class="line"><span class="attr">wordcount:</span> <span class="literal">true</span> <span class="comment">## If you want to display the word counter and the reading time expected to spend of each post please set the value to true, and you must have hexo-wordcount installed.</span></span><br><span class="line"><span class="attr">widgets_on_small_screens:</span> <span class="literal">false</span> <span class="comment">## Set to true to enable widgets on small screens.</span></span><br><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment">## If you want to use dynamic background please set the value to true, you can also fill the following parameters to customize the dynamic effect, or just leave them blank to keep the default effect.</span></span><br><span class="line">  <span class="attr">color:</span> <span class="comment">## RGB value of the color, e.g. &quot;100,99,98&quot;</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="comment">## Transparency of lines, e.g. &quot;0.7&quot;</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="comment">## The z-index property of the background, e.g. &quot;-1&quot;</span></span><br><span class="line">  <span class="attr">count:</span> <span class="comment">## Quantity of lines, e.g. &quot;150&quot;</span></span><br><span class="line"><span class="attr">donate:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment">## If you want to display the donate button after each post, please set the value to true and fill the following items on your need. You can also enable donate button in a page by adding a &quot;donate: true&quot; item to the front-matter.</span></span><br><span class="line">  <span class="attr">github:</span> <span class="comment">## GitHub URL, e.g. https://github.com/Kaiyuan/donate-page</span></span><br><span class="line">  <span class="attr">alipay_qr:</span> <span class="comment">## Path of Alipay QRcode image, e.g. /img/AliPayQR.png</span></span><br><span class="line">  <span class="attr">wechat_qr:</span> <span class="comment">## Path of Wechat QRcode image, e.g. /img/WeChatQR.png</span></span><br><span class="line">  <span class="attr">btc_qr:</span> <span class="comment">## Path of Bitcoin QRcode image, e.g. /img/BTCQR.png</span></span><br><span class="line">  <span class="attr">btc_key:</span> <span class="comment">## Bitcoin key, e.g. 1KuK5eK2BLsqpsFVXXSBG5wbSAwZVadt6L</span></span><br><span class="line">  <span class="attr">paypal_url:</span> <span class="comment">## Paypal URL, e.g. https://www.paypal.me/tufu9441</span></span><br><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">## If you want to display the copyright info after each post, please set the value to true and fill the following items on your need.</span></span><br><span class="line">  <span class="attr">author:</span> <span class="string">Infinity</span> <span class="comment">## Your author name, e.g. tufu9441</span></span><br><span class="line">  <span class="attr">copyright_text:</span> <span class="comment">## Your copyright text, e.g. The author owns the copyright, please indicate the source reproduced.</span></span><br><span class="line"><span class="attr">love:</span> <span class="literal">false</span> <span class="comment">## If you want the peach heart to appear when you click anywhere, set the value to true.</span></span><br><span class="line"><span class="attr">plantuml:</span> <span class="comment">## Using PlantUML to generate UML diagram, must install hexo-filter-plantuml (https://github.com/miao1007/hexo-filter-plantuml).</span></span><br><span class="line">  <span class="attr">render:</span> <span class="string">&quot;PlantUMLServer&quot;</span> <span class="comment">##  Local or PlantUMLServer.</span></span><br><span class="line">  <span class="attr">outputFormat:</span> <span class="string">&quot;svg&quot;</span> <span class="comment">## common options: svg/png</span></span><br><span class="line"><span class="attr">copycode:</span> <span class="literal">true</span> <span class="comment">## If you want to enable one-click copy of the code blocks, set the value to true.</span></span><br><span class="line"><span class="attr">dark:</span> <span class="literal">true</span> <span class="comment">## If you want to toggle between light/dark themes, set the value to true.</span></span><br><span class="line"><span class="attr">totop:</span> <span class="literal">true</span> <span class="comment">## If you want to use the rocketship button to return to the top, set the value to true.</span></span><br><span class="line"><span class="attr">external_css:</span> <span class="literal">false</span> <span class="comment">## If you want to load an external CSS file, set the value to true and create a file named &quot;external.css&quot; in the source/css folder.</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/images/favicon.ico</span></span><br><span class="line"></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">page:</span> <span class="string">home</span></span><br><span class="line">    <span class="attr">directory:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">page:</span> <span class="string">archive</span></span><br><span class="line">    <span class="attr">directory:</span> <span class="string">archives/</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">page:</span> <span class="string">tags</span></span><br><span class="line">    <span class="attr">directory:</span> <span class="string">tags/</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">page:</span> <span class="string">about</span></span><br><span class="line">    <span class="attr">directory:</span> <span class="string">about/</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">page:</span> <span class="string">rss</span></span><br><span class="line">    <span class="attr">directory:</span> <span class="string">atom.xml</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa-rss</span></span><br><span class="line"></span><br><span class="line"><span class="attr">widgets:</span> <span class="comment">## Six widgets in sidebar provided: search, category, tag, recent_posts, recent_comments and links.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">search</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">info</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">category</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">tag</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">recent_posts</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">recent_comments</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">links</span></span><br><span class="line"></span><br><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">/img/avatar.png</span></span><br><span class="line">  <span class="attr">discription:</span> <span class="string">To</span> <span class="string">be</span> <span class="string">a</span> <span class="string">better</span> <span class="string">man.</span></span><br><span class="line">  <span class="attr">outlinkitem:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envelope</span></span><br><span class="line">      <span class="attr">outlink:</span> <span class="string">venray.kong@outlook.com</span></span><br><span class="line">      <span class="attr">message:</span> <span class="string">Email</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">github</span></span><br><span class="line">      <span class="attr">outlink:</span> <span class="string">https://github.com/larrystd</span></span><br><span class="line">      <span class="attr">message:</span> <span class="string">Github</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">rss</span></span><br><span class="line">      <span class="attr">outlink:</span> <span class="string">/atom.xml</span></span><br><span class="line">      <span class="attr">message:</span> <span class="string">RSS</span></span><br><span class="line"></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">title:</span> <span class="string">todo</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.example1.com/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">timeline:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">num:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">word:</span> <span class="number">2014</span><span class="string">/06/12-Start</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">num:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">word:</span> <span class="number">2014</span><span class="string">/11/29-XXX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">num:</span> <span class="number">3</span></span><br><span class="line">    <span class="attr">word:</span> <span class="number">2015</span><span class="string">/02/18-DDD</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">num:</span> <span class="number">4</span></span><br><span class="line">    <span class="attr">word:</span> <span class="string">More</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Static files</span></span><br><span class="line"><span class="attr">js:</span> <span class="string">js</span></span><br><span class="line"><span class="attr">css:</span> <span class="string">css</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Theme version</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><h2 id="hexo-原理"><a href="#hexo-原理" class="headerlink" title="hexo 原理"></a>hexo 原理</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>themes&#x2F;maupassant 模板下面的目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── languages</span><br><span class="line">│   ├── de-DE.yml</span><br><span class="line">│   ├── en.yml</span><br><span class="line">│   ├── zh-CN.yml</span><br><span class="line">│   └── zh-TW.yml</span><br><span class="line">├── layout</span><br><span class="line">│   ├── archive.pug</span><br><span class="line">│   ├── base.pug</span><br><span class="line">│   ├── base-without-sidebar.pug</span><br><span class="line">│   ├── blogroll.pug</span><br><span class="line">│   ├── index.pug</span><br><span class="line">│   ├── page.pug</span><br><span class="line">│   ├── _partial</span><br><span class="line">│   ├── post.pug</span><br><span class="line">│   └── _widget</span><br><span class="line">├── LICENSE</span><br><span class="line">├── package.json</span><br><span class="line">├── README.md</span><br><span class="line">└── source</span><br><span class="line">    ├── css</span><br><span class="line">    ├── img</span><br><span class="line">    └── js</span><br><span class="line">        ├── codeblock-resizer.js</span><br><span class="line">        ├── copycode.js</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><h4 id="layout目录"><a href="#layout目录" class="headerlink" title="layout目录"></a>layout目录</h4><p>layout 目录下面的*.pug文件 是html template模板，定义了主要页面的布局</p><p>hexo的主要页面有三个</p><ol><li>post，表示文章的布局</li><li>page，表示目录的布局，如主页、archieve页，页面都是文章标题的目录</li><li>draft， 这个应用的比较少</li></ol><p>hexo 创建页面的命令<br><code>hexo new page &quot;&#123;name&#125;&quot;</code>, <code>hexo new post &quot;&#123;name&#125;&quot;</code></p><h4 id="source目录"><a href="#source目录" class="headerlink" title="source目录"></a>source目录</h4><p>source下面有三个目录,css,img, js，这三个都会被layout下面定义的模板所引用</p><h3 id="hexo-自定义内容"><a href="#hexo-自定义内容" class="headerlink" title="hexo 自定义内容"></a>hexo 自定义内容</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── db.json</span><br><span class="line">├── node_modules</span><br><span class="line">│   ├── abab</span><br><span class="line">│   ├── abbrev</span><br><span class="line">│   ├── acorn</span><br><span class="line">│   ├── acorn-globals</span><br><span class="line">├── package.json</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── public</span><br><span class="line">│   ├── 2024</span><br><span class="line">│   ├── about</span><br><span class="line">│   ├── archives</span><br><span class="line">│   ├── atom.xml</span><br><span class="line">│   ├── categories</span><br><span class="line">│   ├── css</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   ├── img</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── js</span><br><span class="line">│   ├── search.xml</span><br><span class="line">│   └── tags</span><br><span class="line">├── scaffolds</span><br><span class="line">│   ├── draft.md</span><br><span class="line">│   ├── page.md</span><br><span class="line">│   └── post.md</span><br><span class="line">├── source</span><br><span class="line">│   ├── about</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   ├── images</span><br><span class="line">│   ├── _posts</span><br><span class="line">│   │   └── hello-world.md</span><br><span class="line">│   └── tags</span><br><span class="line">├── themes</span><br><span class="line">│   └── maupassant</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure><p>node_modules 是npm install xxx –save下载到当前目录的模块</p><p>scaffolds目录定义了post，page, draft三个主要页面的构造模板</p><p>source下面是定义的页面，src&#x2F;_posts 下面是文档</p><p>public目录下是打包形成的静态文件</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用hexo 搭建博客&lt;/p&gt;</summary>
    
    
    
    <category term="application" scheme="https://larrystd.github.io/categories/application/"/>
    
    
    <category term="application" scheme="https://larrystd.github.io/tags/application/"/>
    
  </entry>
  
</feed>
